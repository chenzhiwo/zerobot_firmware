
zerobot.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006520  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000006e8  080066b0  080066b0  000166b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08006d98  08006d98  00016d98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08006da0  08006da0  00016da0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08006da4  08006da4  00016da4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000208  20000000  08006da8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020208  2**0
                  CONTENTS
  8 .bss          00004c98  20000208  20000208  00020208  2**2
                  ALLOC
  9 ._user_heap_stack 00001000  20004ea0  20004ea0  00020208  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020208  2**0
                  CONTENTS, READONLY
 11 .debug_info   0003f7d6  00000000  00000000  00020238  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007555  00000000  00000000  0005fa0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00011410  00000000  00000000  00066f63  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000017a8  00000000  00000000  00078378  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001fd8  00000000  00000000  00079b20  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000f30e  00000000  00000000  0007baf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008811  00000000  00000000  0008ae06  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007c  00000000  00000000  00093617  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004590  00000000  00000000  00093694  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000208 	.word	0x20000208
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08006698 	.word	0x08006698

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	2000020c 	.word	0x2000020c
 80001cc:	08006698 	.word	0x08006698

080001d0 <strlen>:
 80001d0:	4603      	mov	r3, r0
 80001d2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001d6:	2a00      	cmp	r2, #0
 80001d8:	d1fb      	bne.n	80001d2 <strlen+0x2>
 80001da:	1a18      	subs	r0, r3, r0
 80001dc:	3801      	subs	r0, #1
 80001de:	4770      	bx	lr

080001e0 <__aeabi_uldivmod>:
 80001e0:	b953      	cbnz	r3, 80001f8 <__aeabi_uldivmod+0x18>
 80001e2:	b94a      	cbnz	r2, 80001f8 <__aeabi_uldivmod+0x18>
 80001e4:	2900      	cmp	r1, #0
 80001e6:	bf08      	it	eq
 80001e8:	2800      	cmpeq	r0, #0
 80001ea:	bf1c      	itt	ne
 80001ec:	f04f 31ff 	movne.w	r1, #4294967295
 80001f0:	f04f 30ff 	movne.w	r0, #4294967295
 80001f4:	f000 b97a 	b.w	80004ec <__aeabi_idiv0>
 80001f8:	f1ad 0c08 	sub.w	ip, sp, #8
 80001fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000200:	f000 f806 	bl	8000210 <__udivmoddi4>
 8000204:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000208:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800020c:	b004      	add	sp, #16
 800020e:	4770      	bx	lr

08000210 <__udivmoddi4>:
 8000210:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000214:	468c      	mov	ip, r1
 8000216:	460d      	mov	r5, r1
 8000218:	4604      	mov	r4, r0
 800021a:	9e08      	ldr	r6, [sp, #32]
 800021c:	2b00      	cmp	r3, #0
 800021e:	d151      	bne.n	80002c4 <__udivmoddi4+0xb4>
 8000220:	428a      	cmp	r2, r1
 8000222:	4617      	mov	r7, r2
 8000224:	d96d      	bls.n	8000302 <__udivmoddi4+0xf2>
 8000226:	fab2 fe82 	clz	lr, r2
 800022a:	f1be 0f00 	cmp.w	lr, #0
 800022e:	d00b      	beq.n	8000248 <__udivmoddi4+0x38>
 8000230:	f1ce 0c20 	rsb	ip, lr, #32
 8000234:	fa01 f50e 	lsl.w	r5, r1, lr
 8000238:	fa20 fc0c 	lsr.w	ip, r0, ip
 800023c:	fa02 f70e 	lsl.w	r7, r2, lr
 8000240:	ea4c 0c05 	orr.w	ip, ip, r5
 8000244:	fa00 f40e 	lsl.w	r4, r0, lr
 8000248:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 800024c:	0c25      	lsrs	r5, r4, #16
 800024e:	fbbc f8fa 	udiv	r8, ip, sl
 8000252:	fa1f f987 	uxth.w	r9, r7
 8000256:	fb0a cc18 	mls	ip, sl, r8, ip
 800025a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800025e:	fb08 f309 	mul.w	r3, r8, r9
 8000262:	42ab      	cmp	r3, r5
 8000264:	d90a      	bls.n	800027c <__udivmoddi4+0x6c>
 8000266:	19ed      	adds	r5, r5, r7
 8000268:	f108 32ff 	add.w	r2, r8, #4294967295
 800026c:	f080 8123 	bcs.w	80004b6 <__udivmoddi4+0x2a6>
 8000270:	42ab      	cmp	r3, r5
 8000272:	f240 8120 	bls.w	80004b6 <__udivmoddi4+0x2a6>
 8000276:	f1a8 0802 	sub.w	r8, r8, #2
 800027a:	443d      	add	r5, r7
 800027c:	1aed      	subs	r5, r5, r3
 800027e:	b2a4      	uxth	r4, r4
 8000280:	fbb5 f0fa 	udiv	r0, r5, sl
 8000284:	fb0a 5510 	mls	r5, sl, r0, r5
 8000288:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800028c:	fb00 f909 	mul.w	r9, r0, r9
 8000290:	45a1      	cmp	r9, r4
 8000292:	d909      	bls.n	80002a8 <__udivmoddi4+0x98>
 8000294:	19e4      	adds	r4, r4, r7
 8000296:	f100 33ff 	add.w	r3, r0, #4294967295
 800029a:	f080 810a 	bcs.w	80004b2 <__udivmoddi4+0x2a2>
 800029e:	45a1      	cmp	r9, r4
 80002a0:	f240 8107 	bls.w	80004b2 <__udivmoddi4+0x2a2>
 80002a4:	3802      	subs	r0, #2
 80002a6:	443c      	add	r4, r7
 80002a8:	eba4 0409 	sub.w	r4, r4, r9
 80002ac:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80002b0:	2100      	movs	r1, #0
 80002b2:	2e00      	cmp	r6, #0
 80002b4:	d061      	beq.n	800037a <__udivmoddi4+0x16a>
 80002b6:	fa24 f40e 	lsr.w	r4, r4, lr
 80002ba:	2300      	movs	r3, #0
 80002bc:	6034      	str	r4, [r6, #0]
 80002be:	6073      	str	r3, [r6, #4]
 80002c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002c4:	428b      	cmp	r3, r1
 80002c6:	d907      	bls.n	80002d8 <__udivmoddi4+0xc8>
 80002c8:	2e00      	cmp	r6, #0
 80002ca:	d054      	beq.n	8000376 <__udivmoddi4+0x166>
 80002cc:	2100      	movs	r1, #0
 80002ce:	e886 0021 	stmia.w	r6, {r0, r5}
 80002d2:	4608      	mov	r0, r1
 80002d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002d8:	fab3 f183 	clz	r1, r3
 80002dc:	2900      	cmp	r1, #0
 80002de:	f040 808e 	bne.w	80003fe <__udivmoddi4+0x1ee>
 80002e2:	42ab      	cmp	r3, r5
 80002e4:	d302      	bcc.n	80002ec <__udivmoddi4+0xdc>
 80002e6:	4282      	cmp	r2, r0
 80002e8:	f200 80fa 	bhi.w	80004e0 <__udivmoddi4+0x2d0>
 80002ec:	1a84      	subs	r4, r0, r2
 80002ee:	eb65 0503 	sbc.w	r5, r5, r3
 80002f2:	2001      	movs	r0, #1
 80002f4:	46ac      	mov	ip, r5
 80002f6:	2e00      	cmp	r6, #0
 80002f8:	d03f      	beq.n	800037a <__udivmoddi4+0x16a>
 80002fa:	e886 1010 	stmia.w	r6, {r4, ip}
 80002fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000302:	b912      	cbnz	r2, 800030a <__udivmoddi4+0xfa>
 8000304:	2701      	movs	r7, #1
 8000306:	fbb7 f7f2 	udiv	r7, r7, r2
 800030a:	fab7 fe87 	clz	lr, r7
 800030e:	f1be 0f00 	cmp.w	lr, #0
 8000312:	d134      	bne.n	800037e <__udivmoddi4+0x16e>
 8000314:	1beb      	subs	r3, r5, r7
 8000316:	0c3a      	lsrs	r2, r7, #16
 8000318:	fa1f fc87 	uxth.w	ip, r7
 800031c:	2101      	movs	r1, #1
 800031e:	fbb3 f8f2 	udiv	r8, r3, r2
 8000322:	0c25      	lsrs	r5, r4, #16
 8000324:	fb02 3318 	mls	r3, r2, r8, r3
 8000328:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800032c:	fb0c f308 	mul.w	r3, ip, r8
 8000330:	42ab      	cmp	r3, r5
 8000332:	d907      	bls.n	8000344 <__udivmoddi4+0x134>
 8000334:	19ed      	adds	r5, r5, r7
 8000336:	f108 30ff 	add.w	r0, r8, #4294967295
 800033a:	d202      	bcs.n	8000342 <__udivmoddi4+0x132>
 800033c:	42ab      	cmp	r3, r5
 800033e:	f200 80d1 	bhi.w	80004e4 <__udivmoddi4+0x2d4>
 8000342:	4680      	mov	r8, r0
 8000344:	1aed      	subs	r5, r5, r3
 8000346:	b2a3      	uxth	r3, r4
 8000348:	fbb5 f0f2 	udiv	r0, r5, r2
 800034c:	fb02 5510 	mls	r5, r2, r0, r5
 8000350:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000354:	fb0c fc00 	mul.w	ip, ip, r0
 8000358:	45a4      	cmp	ip, r4
 800035a:	d907      	bls.n	800036c <__udivmoddi4+0x15c>
 800035c:	19e4      	adds	r4, r4, r7
 800035e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000362:	d202      	bcs.n	800036a <__udivmoddi4+0x15a>
 8000364:	45a4      	cmp	ip, r4
 8000366:	f200 80b8 	bhi.w	80004da <__udivmoddi4+0x2ca>
 800036a:	4618      	mov	r0, r3
 800036c:	eba4 040c 	sub.w	r4, r4, ip
 8000370:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000374:	e79d      	b.n	80002b2 <__udivmoddi4+0xa2>
 8000376:	4631      	mov	r1, r6
 8000378:	4630      	mov	r0, r6
 800037a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800037e:	f1ce 0420 	rsb	r4, lr, #32
 8000382:	fa05 f30e 	lsl.w	r3, r5, lr
 8000386:	fa07 f70e 	lsl.w	r7, r7, lr
 800038a:	fa20 f804 	lsr.w	r8, r0, r4
 800038e:	0c3a      	lsrs	r2, r7, #16
 8000390:	fa25 f404 	lsr.w	r4, r5, r4
 8000394:	ea48 0803 	orr.w	r8, r8, r3
 8000398:	fbb4 f1f2 	udiv	r1, r4, r2
 800039c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 80003a0:	fb02 4411 	mls	r4, r2, r1, r4
 80003a4:	fa1f fc87 	uxth.w	ip, r7
 80003a8:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 80003ac:	fb01 f30c 	mul.w	r3, r1, ip
 80003b0:	42ab      	cmp	r3, r5
 80003b2:	fa00 f40e 	lsl.w	r4, r0, lr
 80003b6:	d909      	bls.n	80003cc <__udivmoddi4+0x1bc>
 80003b8:	19ed      	adds	r5, r5, r7
 80003ba:	f101 30ff 	add.w	r0, r1, #4294967295
 80003be:	f080 808a 	bcs.w	80004d6 <__udivmoddi4+0x2c6>
 80003c2:	42ab      	cmp	r3, r5
 80003c4:	f240 8087 	bls.w	80004d6 <__udivmoddi4+0x2c6>
 80003c8:	3902      	subs	r1, #2
 80003ca:	443d      	add	r5, r7
 80003cc:	1aeb      	subs	r3, r5, r3
 80003ce:	fa1f f588 	uxth.w	r5, r8
 80003d2:	fbb3 f0f2 	udiv	r0, r3, r2
 80003d6:	fb02 3310 	mls	r3, r2, r0, r3
 80003da:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003de:	fb00 f30c 	mul.w	r3, r0, ip
 80003e2:	42ab      	cmp	r3, r5
 80003e4:	d907      	bls.n	80003f6 <__udivmoddi4+0x1e6>
 80003e6:	19ed      	adds	r5, r5, r7
 80003e8:	f100 38ff 	add.w	r8, r0, #4294967295
 80003ec:	d26f      	bcs.n	80004ce <__udivmoddi4+0x2be>
 80003ee:	42ab      	cmp	r3, r5
 80003f0:	d96d      	bls.n	80004ce <__udivmoddi4+0x2be>
 80003f2:	3802      	subs	r0, #2
 80003f4:	443d      	add	r5, r7
 80003f6:	1aeb      	subs	r3, r5, r3
 80003f8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80003fc:	e78f      	b.n	800031e <__udivmoddi4+0x10e>
 80003fe:	f1c1 0720 	rsb	r7, r1, #32
 8000402:	fa22 f807 	lsr.w	r8, r2, r7
 8000406:	408b      	lsls	r3, r1
 8000408:	fa05 f401 	lsl.w	r4, r5, r1
 800040c:	ea48 0303 	orr.w	r3, r8, r3
 8000410:	fa20 fe07 	lsr.w	lr, r0, r7
 8000414:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000418:	40fd      	lsrs	r5, r7
 800041a:	ea4e 0e04 	orr.w	lr, lr, r4
 800041e:	fbb5 f9fc 	udiv	r9, r5, ip
 8000422:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000426:	fb0c 5519 	mls	r5, ip, r9, r5
 800042a:	fa1f f883 	uxth.w	r8, r3
 800042e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000432:	fb09 f408 	mul.w	r4, r9, r8
 8000436:	42ac      	cmp	r4, r5
 8000438:	fa02 f201 	lsl.w	r2, r2, r1
 800043c:	fa00 fa01 	lsl.w	sl, r0, r1
 8000440:	d908      	bls.n	8000454 <__udivmoddi4+0x244>
 8000442:	18ed      	adds	r5, r5, r3
 8000444:	f109 30ff 	add.w	r0, r9, #4294967295
 8000448:	d243      	bcs.n	80004d2 <__udivmoddi4+0x2c2>
 800044a:	42ac      	cmp	r4, r5
 800044c:	d941      	bls.n	80004d2 <__udivmoddi4+0x2c2>
 800044e:	f1a9 0902 	sub.w	r9, r9, #2
 8000452:	441d      	add	r5, r3
 8000454:	1b2d      	subs	r5, r5, r4
 8000456:	fa1f fe8e 	uxth.w	lr, lr
 800045a:	fbb5 f0fc 	udiv	r0, r5, ip
 800045e:	fb0c 5510 	mls	r5, ip, r0, r5
 8000462:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000466:	fb00 f808 	mul.w	r8, r0, r8
 800046a:	45a0      	cmp	r8, r4
 800046c:	d907      	bls.n	800047e <__udivmoddi4+0x26e>
 800046e:	18e4      	adds	r4, r4, r3
 8000470:	f100 35ff 	add.w	r5, r0, #4294967295
 8000474:	d229      	bcs.n	80004ca <__udivmoddi4+0x2ba>
 8000476:	45a0      	cmp	r8, r4
 8000478:	d927      	bls.n	80004ca <__udivmoddi4+0x2ba>
 800047a:	3802      	subs	r0, #2
 800047c:	441c      	add	r4, r3
 800047e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000482:	eba4 0408 	sub.w	r4, r4, r8
 8000486:	fba0 8902 	umull	r8, r9, r0, r2
 800048a:	454c      	cmp	r4, r9
 800048c:	46c6      	mov	lr, r8
 800048e:	464d      	mov	r5, r9
 8000490:	d315      	bcc.n	80004be <__udivmoddi4+0x2ae>
 8000492:	d012      	beq.n	80004ba <__udivmoddi4+0x2aa>
 8000494:	b156      	cbz	r6, 80004ac <__udivmoddi4+0x29c>
 8000496:	ebba 030e 	subs.w	r3, sl, lr
 800049a:	eb64 0405 	sbc.w	r4, r4, r5
 800049e:	fa04 f707 	lsl.w	r7, r4, r7
 80004a2:	40cb      	lsrs	r3, r1
 80004a4:	431f      	orrs	r7, r3
 80004a6:	40cc      	lsrs	r4, r1
 80004a8:	6037      	str	r7, [r6, #0]
 80004aa:	6074      	str	r4, [r6, #4]
 80004ac:	2100      	movs	r1, #0
 80004ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004b2:	4618      	mov	r0, r3
 80004b4:	e6f8      	b.n	80002a8 <__udivmoddi4+0x98>
 80004b6:	4690      	mov	r8, r2
 80004b8:	e6e0      	b.n	800027c <__udivmoddi4+0x6c>
 80004ba:	45c2      	cmp	sl, r8
 80004bc:	d2ea      	bcs.n	8000494 <__udivmoddi4+0x284>
 80004be:	ebb8 0e02 	subs.w	lr, r8, r2
 80004c2:	eb69 0503 	sbc.w	r5, r9, r3
 80004c6:	3801      	subs	r0, #1
 80004c8:	e7e4      	b.n	8000494 <__udivmoddi4+0x284>
 80004ca:	4628      	mov	r0, r5
 80004cc:	e7d7      	b.n	800047e <__udivmoddi4+0x26e>
 80004ce:	4640      	mov	r0, r8
 80004d0:	e791      	b.n	80003f6 <__udivmoddi4+0x1e6>
 80004d2:	4681      	mov	r9, r0
 80004d4:	e7be      	b.n	8000454 <__udivmoddi4+0x244>
 80004d6:	4601      	mov	r1, r0
 80004d8:	e778      	b.n	80003cc <__udivmoddi4+0x1bc>
 80004da:	3802      	subs	r0, #2
 80004dc:	443c      	add	r4, r7
 80004de:	e745      	b.n	800036c <__udivmoddi4+0x15c>
 80004e0:	4608      	mov	r0, r1
 80004e2:	e708      	b.n	80002f6 <__udivmoddi4+0xe6>
 80004e4:	f1a8 0802 	sub.w	r8, r8, #2
 80004e8:	443d      	add	r5, r7
 80004ea:	e72b      	b.n	8000344 <__udivmoddi4+0x134>

080004ec <__aeabi_idiv0>:
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop

080004f0 <MX_ADC1_Init>:
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 80004f0:	b530      	push	{r4, r5, lr}
 80004f2:	b085      	sub	sp, #20
  ADC_ChannelConfTypeDef sConfig = {0};
 80004f4:	2210      	movs	r2, #16
 80004f6:	2100      	movs	r1, #0
 80004f8:	4668      	mov	r0, sp
 80004fa:	f006 f8bc 	bl	8006676 <memset>

  /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
  */
  hadc1.Instance = ADC1;
 80004fe:	4823      	ldr	r0, [pc, #140]	; (800058c <MX_ADC1_Init+0x9c>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 8000500:	4b23      	ldr	r3, [pc, #140]	; (8000590 <MX_ADC1_Init+0xa0>)
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000502:	4a24      	ldr	r2, [pc, #144]	; (8000594 <MX_ADC1_Init+0xa4>)
 8000504:	6282      	str	r2, [r0, #40]	; 0x28
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 8000506:	f44f 3e40 	mov.w	lr, #196608	; 0x30000
  hadc1.Init.ScanConvMode = ENABLE;
 800050a:	2401      	movs	r4, #1
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 800050c:	e880 4008 	stmia.w	r0, {r3, lr}
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 4;
 8000510:	2504      	movs	r5, #4
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000512:	2300      	movs	r3, #0
 8000514:	6083      	str	r3, [r0, #8]
  hadc1.Init.ScanConvMode = ENABLE;
 8000516:	6104      	str	r4, [r0, #16]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000518:	6183      	str	r3, [r0, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 800051a:	6203      	str	r3, [r0, #32]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800051c:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800051e:	60c3      	str	r3, [r0, #12]
  hadc1.Init.NbrOfConversion = 4;
 8000520:	61c5      	str	r5, [r0, #28]
  hadc1.Init.DMAContinuousRequests = ENABLE;
 8000522:	6304      	str	r4, [r0, #48]	; 0x30
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000524:	6144      	str	r4, [r0, #20]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000526:	f001 f9f5 	bl	8001914 <HAL_ADC_Init>
 800052a:	b108      	cbz	r0, 8000530 <MX_ADC1_Init+0x40>
  {
    Error_Handler();
 800052c:	f000 faea 	bl	8000b04 <Error_Handler>
  }
  /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_4;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
 8000530:	2307      	movs	r3, #7
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000532:	4669      	mov	r1, sp
 8000534:	4815      	ldr	r0, [pc, #84]	; (800058c <MX_ADC1_Init+0x9c>)
  sConfig.Channel = ADC_CHANNEL_4;
 8000536:	9500      	str	r5, [sp, #0]
  sConfig.Rank = 1;
 8000538:	9401      	str	r4, [sp, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
 800053a:	9302      	str	r3, [sp, #8]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 800053c:	f001 fa8e 	bl	8001a5c <HAL_ADC_ConfigChannel>
 8000540:	b108      	cbz	r0, 8000546 <MX_ADC1_Init+0x56>
  {
    Error_Handler();
 8000542:	f000 fadf 	bl	8000b04 <Error_Handler>
  }
  /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_9;
  sConfig.Rank = 2;
 8000546:	2009      	movs	r0, #9
 8000548:	2302      	movs	r3, #2
 800054a:	e88d 0009 	stmia.w	sp, {r0, r3}
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 800054e:	4669      	mov	r1, sp
 8000550:	480e      	ldr	r0, [pc, #56]	; (800058c <MX_ADC1_Init+0x9c>)
 8000552:	f001 fa83 	bl	8001a5c <HAL_ADC_ConfigChannel>
 8000556:	b108      	cbz	r0, 800055c <MX_ADC1_Init+0x6c>
  {
    Error_Handler();
 8000558:	f000 fad4 	bl	8000b04 <Error_Handler>
  }
  /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_11;
  sConfig.Rank = 3;
 800055c:	210b      	movs	r1, #11
 800055e:	2303      	movs	r3, #3
 8000560:	e88d 000a 	stmia.w	sp, {r1, r3}
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000564:	4809      	ldr	r0, [pc, #36]	; (800058c <MX_ADC1_Init+0x9c>)
 8000566:	4669      	mov	r1, sp
 8000568:	f001 fa78 	bl	8001a5c <HAL_ADC_ConfigChannel>
 800056c:	b108      	cbz	r0, 8000572 <MX_ADC1_Init+0x82>
  {
    Error_Handler();
 800056e:	f000 fac9 	bl	8000b04 <Error_Handler>
  }
  /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_14;
  sConfig.Rank = 4;
 8000572:	220e      	movs	r2, #14
 8000574:	2304      	movs	r3, #4
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000576:	4669      	mov	r1, sp
 8000578:	4804      	ldr	r0, [pc, #16]	; (800058c <MX_ADC1_Init+0x9c>)
  sConfig.Rank = 4;
 800057a:	e88d 000c 	stmia.w	sp, {r2, r3}
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 800057e:	f001 fa6d 	bl	8001a5c <HAL_ADC_ConfigChannel>
 8000582:	b108      	cbz	r0, 8000588 <MX_ADC1_Init+0x98>
  {
    Error_Handler();
 8000584:	f000 fabe 	bl	8000b04 <Error_Handler>
  }

}
 8000588:	b005      	add	sp, #20
 800058a:	bd30      	pop	{r4, r5, pc}
 800058c:	20004388 	.word	0x20004388
 8000590:	40012000 	.word	0x40012000
 8000594:	0f000001 	.word	0x0f000001

08000598 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8000598:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800059a:	2214      	movs	r2, #20
{
 800059c:	b08a      	sub	sp, #40	; 0x28
 800059e:	4606      	mov	r6, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80005a0:	2100      	movs	r1, #0
 80005a2:	eb0d 0002 	add.w	r0, sp, r2
 80005a6:	f006 f866 	bl	8006676 <memset>
  if(adcHandle->Instance==ADC1)
 80005aa:	6832      	ldr	r2, [r6, #0]
 80005ac:	4b30      	ldr	r3, [pc, #192]	; (8000670 <HAL_ADC_MspInit+0xd8>)
 80005ae:	429a      	cmp	r2, r3
 80005b0:	d15c      	bne.n	800066c <HAL_ADC_MspInit+0xd4>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 80005b2:	2500      	movs	r5, #0
 80005b4:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
 80005b8:	9501      	str	r5, [sp, #4]
 80005ba:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    PB1     ------> ADC1_IN9 
    */
    GPIO_InitStruct.Pin = ADC2_Pin|ADC3_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80005bc:	482d      	ldr	r0, [pc, #180]	; (8000674 <HAL_ADC_MspInit+0xdc>)
    __HAL_RCC_ADC1_CLK_ENABLE();
 80005be:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80005c2:	645a      	str	r2, [r3, #68]	; 0x44
 80005c4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80005c6:	f402 7280 	and.w	r2, r2, #256	; 0x100
 80005ca:	9201      	str	r2, [sp, #4]
 80005cc:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80005ce:	9502      	str	r5, [sp, #8]
 80005d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005d2:	f042 0204 	orr.w	r2, r2, #4
 80005d6:	631a      	str	r2, [r3, #48]	; 0x30
 80005d8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005da:	f002 0204 	and.w	r2, r2, #4
 80005de:	9202      	str	r2, [sp, #8]
 80005e0:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80005e2:	9503      	str	r5, [sp, #12]
 80005e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005e6:	f042 0201 	orr.w	r2, r2, #1
 80005ea:	631a      	str	r2, [r3, #48]	; 0x30
 80005ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005ee:	f002 0201 	and.w	r2, r2, #1
 80005f2:	9203      	str	r2, [sp, #12]
 80005f4:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80005f6:	9504      	str	r5, [sp, #16]
 80005f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80005fa:	f042 0202 	orr.w	r2, r2, #2
 80005fe:	631a      	str	r2, [r3, #48]	; 0x30
 8000600:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000602:	f003 0302 	and.w	r3, r3, #2
 8000606:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000608:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800060a:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800060c:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pin = ADC2_Pin|ADC3_Pin;
 800060e:	2312      	movs	r3, #18
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000610:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Pin = ADC2_Pin|ADC3_Pin;
 8000612:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000614:	f001 fca8 	bl	8001f68 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = ADC0_Pin;
 8000618:	2310      	movs	r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(ADC0_GPIO_Port, &GPIO_InitStruct);
 800061a:	a905      	add	r1, sp, #20
 800061c:	4816      	ldr	r0, [pc, #88]	; (8000678 <HAL_ADC_MspInit+0xe0>)
    GPIO_InitStruct.Pin = ADC0_Pin;
 800061e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000620:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000622:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(ADC0_GPIO_Port, &GPIO_InitStruct);
 8000624:	f001 fca0 	bl	8001f68 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = ADC1_Pin;
 8000628:	2302      	movs	r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(ADC1_GPIO_Port, &GPIO_InitStruct);
 800062a:	4814      	ldr	r0, [pc, #80]	; (800067c <HAL_ADC_MspInit+0xe4>)
    GPIO_InitStruct.Pin = ADC1_Pin;
 800062c:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(ADC1_GPIO_Port, &GPIO_InitStruct);
 800062e:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000630:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000632:	9507      	str	r5, [sp, #28]

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA2_Stream4;
 8000634:	4c12      	ldr	r4, [pc, #72]	; (8000680 <HAL_ADC_MspInit+0xe8>)
    HAL_GPIO_Init(ADC1_GPIO_Port, &GPIO_InitStruct);
 8000636:	f001 fc97 	bl	8001f68 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream4;
 800063a:	4b12      	ldr	r3, [pc, #72]	; (8000684 <HAL_ADC_MspInit+0xec>)
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800063c:	60a5      	str	r5, [r4, #8]
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
 800063e:	e884 0028 	stmia.w	r4, {r3, r5}
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8000642:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000646:	6123      	str	r3, [r4, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8000648:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800064c:	6163      	str	r3, [r4, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_NORMAL;
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 800064e:	4620      	mov	r0, r4
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8000650:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 8000654:	60e5      	str	r5, [r4, #12]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8000656:	61a3      	str	r3, [r4, #24]
    hdma_adc1.Init.Mode = DMA_NORMAL;
 8000658:	61e5      	str	r5, [r4, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 800065a:	6225      	str	r5, [r4, #32]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800065c:	6265      	str	r5, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 800065e:	f001 fafb 	bl	8001c58 <HAL_DMA_Init>
 8000662:	b108      	cbz	r0, 8000668 <HAL_ADC_MspInit+0xd0>
    {
      Error_Handler();
 8000664:	f000 fa4e 	bl	8000b04 <Error_Handler>
    }

    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 8000668:	63b4      	str	r4, [r6, #56]	; 0x38
 800066a:	63a6      	str	r6, [r4, #56]	; 0x38

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 800066c:	b00a      	add	sp, #40	; 0x28
 800066e:	bd70      	pop	{r4, r5, r6, pc}
 8000670:	40012000 	.word	0x40012000
 8000674:	40020800 	.word	0x40020800
 8000678:	40020000 	.word	0x40020000
 800067c:	40020400 	.word	0x40020400
 8000680:	200043d0 	.word	0x200043d0
 8000684:	40026470 	.word	0x40026470

08000688 <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 8000688:	b513      	push	{r0, r1, r4, lr}
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 800068a:	4b30      	ldr	r3, [pc, #192]	; (800074c <MX_DMA_Init+0xc4>)
 800068c:	2400      	movs	r4, #0
 800068e:	9400      	str	r4, [sp, #0]
 8000690:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000692:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8000696:	631a      	str	r2, [r3, #48]	; 0x30
 8000698:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800069a:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 800069e:	9200      	str	r2, [sp, #0]
 80006a0:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80006a2:	9401      	str	r4, [sp, #4]
 80006a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80006a6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80006aa:	631a      	str	r2, [r3, #48]	; 0x30
 80006ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80006ae:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000

  /* DMA interrupt init */
  /* DMA1_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 5, 0);
 80006b2:	4622      	mov	r2, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 80006b4:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 5, 0);
 80006b6:	2105      	movs	r1, #5
 80006b8:	200e      	movs	r0, #14
  __HAL_RCC_DMA1_CLK_ENABLE();
 80006ba:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 5, 0);
 80006bc:	f001 fa76 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);
 80006c0:	200e      	movs	r0, #14
 80006c2:	f001 faa7 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 5, 0);
 80006c6:	4622      	mov	r2, r4
 80006c8:	2105      	movs	r1, #5
 80006ca:	200f      	movs	r0, #15
 80006cc:	f001 fa6e 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn);
 80006d0:	200f      	movs	r0, #15
 80006d2:	f001 fa9f 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 5, 0);
 80006d6:	4622      	mov	r2, r4
 80006d8:	2105      	movs	r1, #5
 80006da:	2010      	movs	r0, #16
 80006dc:	f001 fa66 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
 80006e0:	2010      	movs	r0, #16
 80006e2:	f001 fa97 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 5, 0);
 80006e6:	4622      	mov	r2, r4
 80006e8:	2105      	movs	r1, #5
 80006ea:	2011      	movs	r0, #17
 80006ec:	f001 fa5e 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
 80006f0:	2011      	movs	r0, #17
 80006f2:	f001 fa8f 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 5, 0);
 80006f6:	4622      	mov	r2, r4
 80006f8:	2105      	movs	r1, #5
 80006fa:	2038      	movs	r0, #56	; 0x38
 80006fc:	f001 fa56 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 8000700:	2038      	movs	r0, #56	; 0x38
 8000702:	f001 fa87 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 5, 0);
 8000706:	4622      	mov	r2, r4
 8000708:	2105      	movs	r1, #5
 800070a:	203a      	movs	r0, #58	; 0x3a
 800070c:	f001 fa4e 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 8000710:	203a      	movs	r0, #58	; 0x3a
 8000712:	f001 fa7f 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
 8000716:	4622      	mov	r2, r4
 8000718:	2105      	movs	r1, #5
 800071a:	203b      	movs	r0, #59	; 0x3b
 800071c:	f001 fa46 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 8000720:	203b      	movs	r0, #59	; 0x3b
 8000722:	f001 fa77 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 5, 0);
 8000726:	4622      	mov	r2, r4
 8000728:	2105      	movs	r1, #5
 800072a:	203c      	movs	r0, #60	; 0x3c
 800072c:	f001 fa3e 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 8000730:	203c      	movs	r0, #60	; 0x3c
 8000732:	f001 fa6f 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 5, 0);
 8000736:	4622      	mov	r2, r4
 8000738:	2105      	movs	r1, #5
 800073a:	2046      	movs	r0, #70	; 0x46
 800073c:	f001 fa36 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
 8000740:	2046      	movs	r0, #70	; 0x46
 8000742:	f001 fa67 	bl	8001c14 <HAL_NVIC_EnableIRQ>

}
 8000746:	b002      	add	sp, #8
 8000748:	bd10      	pop	{r4, pc}
 800074a:	bf00      	nop
 800074c:	40023800 	.word	0x40023800

08000750 <MX_FREERTOS_Init>:
/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
 8000750:	b530      	push	{r4, r5, lr}
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of loop_task */
  osThreadDef(loop_task, loopTaskEntry, osPriorityNormal, 0, 128);
 8000752:	4d07      	ldr	r5, [pc, #28]	; (8000770 <MX_FREERTOS_Init+0x20>)
 8000754:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
void MX_FREERTOS_Init(void) {
 8000756:	b087      	sub	sp, #28
  osThreadDef(loop_task, loopTaskEntry, osPriorityNormal, 0, 128);
 8000758:	ac01      	add	r4, sp, #4
 800075a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800075c:	682b      	ldr	r3, [r5, #0]
 800075e:	6023      	str	r3, [r4, #0]
  loop_taskHandle = osThreadCreate(osThread(loop_task), NULL);
 8000760:	2100      	movs	r1, #0
 8000762:	a801      	add	r0, sp, #4
 8000764:	f003 fe84 	bl	8004470 <osThreadCreate>
 8000768:	4b02      	ldr	r3, [pc, #8]	; (8000774 <MX_FREERTOS_Init+0x24>)
 800076a:	6018      	str	r0, [r3, #0]
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */
}
 800076c:	b007      	add	sp, #28
 800076e:	bd30      	pop	{r4, r5, pc}
 8000770:	080066b0 	.word	0x080066b0
 8000774:	20004430 	.word	0x20004430

08000778 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000778:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800077c:	b08d      	sub	sp, #52	; 0x34

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800077e:	2214      	movs	r2, #20
 8000780:	2100      	movs	r1, #0
 8000782:	a807      	add	r0, sp, #28
 8000784:	f005 ff77 	bl	8006676 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8000788:	2400      	movs	r4, #0
 800078a:	4b5f      	ldr	r3, [pc, #380]	; (8000908 <MX_GPIO_Init+0x190>)
 800078c:	9401      	str	r4, [sp, #4]
 800078e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, DIR0_P_Pin|DIR0_N_Pin|DIR1_P_Pin|DIR1_N_Pin 
 8000790:	4e5e      	ldr	r6, [pc, #376]	; (800090c <MX_GPIO_Init+0x194>)
                          |DIR2_P_Pin|DIR2_N_Pin|DIR3_P_Pin|DIR3_N_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(TRIGGER_GPIO_Port, TRIGGER_Pin, GPIO_PIN_RESET);
 8000792:	f8df 8180 	ldr.w	r8, [pc, #384]	; 8000914 <MX_GPIO_Init+0x19c>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, FLASH0_CS_Pin|NRF_CE_Pin, GPIO_PIN_SET);
 8000796:	4f5e      	ldr	r7, [pc, #376]	; (8000910 <MX_GPIO_Init+0x198>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pins : PEPin PEPin */
  GPIO_InitStruct.Pin = KEY1_Pin|KEY0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000798:	f8df 917c 	ldr.w	r9, [pc, #380]	; 8000918 <MX_GPIO_Init+0x1a0>
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800079c:	f042 0210 	orr.w	r2, r2, #16
 80007a0:	631a      	str	r2, [r3, #48]	; 0x30
 80007a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007a4:	f002 0210 	and.w	r2, r2, #16
 80007a8:	9201      	str	r2, [sp, #4]
 80007aa:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80007ac:	9402      	str	r4, [sp, #8]
 80007ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007b0:	f042 0204 	orr.w	r2, r2, #4
 80007b4:	631a      	str	r2, [r3, #48]	; 0x30
 80007b6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007b8:	f002 0204 	and.w	r2, r2, #4
 80007bc:	9202      	str	r2, [sp, #8]
 80007be:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80007c0:	9403      	str	r4, [sp, #12]
 80007c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007c4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80007c8:	631a      	str	r2, [r3, #48]	; 0x30
 80007ca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007cc:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80007d0:	9203      	str	r2, [sp, #12]
 80007d2:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80007d4:	9404      	str	r4, [sp, #16]
 80007d6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007d8:	f042 0201 	orr.w	r2, r2, #1
 80007dc:	631a      	str	r2, [r3, #48]	; 0x30
 80007de:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007e0:	f002 0201 	and.w	r2, r2, #1
 80007e4:	9204      	str	r2, [sp, #16]
 80007e6:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80007e8:	9405      	str	r4, [sp, #20]
 80007ea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007ec:	f042 0202 	orr.w	r2, r2, #2
 80007f0:	631a      	str	r2, [r3, #48]	; 0x30
 80007f2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007f4:	f002 0202 	and.w	r2, r2, #2
 80007f8:	9205      	str	r2, [sp, #20]
 80007fa:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80007fc:	9406      	str	r4, [sp, #24]
 80007fe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000800:	f042 0208 	orr.w	r2, r2, #8
 8000804:	631a      	str	r2, [r3, #48]	; 0x30
 8000806:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000808:	f003 0308 	and.w	r3, r3, #8
 800080c:	9306      	str	r3, [sp, #24]
  HAL_GPIO_WritePin(GPIOE, DIR0_P_Pin|DIR0_N_Pin|DIR1_P_Pin|DIR1_N_Pin 
 800080e:	4630      	mov	r0, r6
 8000810:	2201      	movs	r2, #1
 8000812:	f249 51e4 	movw	r1, #38372	; 0x95e4
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000816:	9b06      	ldr	r3, [sp, #24]
  HAL_GPIO_WritePin(GPIOE, DIR0_P_Pin|DIR0_N_Pin|DIR1_P_Pin|DIR1_N_Pin 
 8000818:	f001 fc86 	bl	8002128 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(TRIGGER_GPIO_Port, TRIGGER_Pin, GPIO_PIN_RESET);
 800081c:	4622      	mov	r2, r4
 800081e:	4640      	mov	r0, r8
 8000820:	2101      	movs	r1, #1
 8000822:	f001 fc81 	bl	8002128 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, FLASH0_CS_Pin|NRF_CE_Pin, GPIO_PIN_SET);
 8000826:	4638      	mov	r0, r7
 8000828:	2201      	movs	r2, #1
 800082a:	2141      	movs	r1, #65	; 0x41
 800082c:	f001 fc7c 	bl	8002128 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, NRF_CS_Pin|LED2_Pin, GPIO_PIN_RESET);
 8000830:	4622      	mov	r2, r4
 8000832:	4638      	mov	r0, r7
 8000834:	f44f 7120 	mov.w	r1, #640	; 0x280
 8000838:	f001 fc76 	bl	8002128 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOE, LED0_Pin|LED1_Pin, GPIO_PIN_RESET);
 800083c:	4622      	mov	r2, r4
 800083e:	4630      	mov	r0, r6
 8000840:	2103      	movs	r1, #3
 8000842:	f001 fc71 	bl	8002128 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = DIR0_P_Pin|DIR0_N_Pin|DIR1_P_Pin|DIR1_N_Pin 
 8000846:	f249 53e4 	movw	r3, #38372	; 0x95e4
 800084a:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800084c:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 800084e:	2311      	movs	r3, #17
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000850:	4630      	mov	r0, r6
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000852:	2501      	movs	r5, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 8000854:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000856:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000858:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800085a:	f001 fb85 	bl	8001f68 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = KEY1_Pin|KEY0_Pin;
 800085e:	2318      	movs	r3, #24
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8000860:	a907      	add	r1, sp, #28
 8000862:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = KEY1_Pin|KEY0_Pin;
 8000864:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000866:	f8cd 9020 	str.w	r9, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800086a:	9509      	str	r5, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800086c:	f001 fb7c 	bl	8001f68 <HAL_GPIO_Init>
  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = TRIGGER_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(TRIGGER_GPIO_Port, &GPIO_InitStruct);
 8000870:	a907      	add	r1, sp, #28
 8000872:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = TRIGGER_Pin;
 8000874:	9507      	str	r5, [sp, #28]

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = FLASH0_CS_Pin|NRF_CE_Pin|NRF_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000876:	f04f 0803 	mov.w	r8, #3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800087a:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800087c:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800087e:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(TRIGGER_GPIO_Port, &GPIO_InitStruct);
 8000880:	f001 fb72 	bl	8001f68 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FLASH0_CS_Pin|NRF_CE_Pin|NRF_CS_Pin;
 8000884:	23c1      	movs	r3, #193	; 0xc1
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000886:	a907      	add	r1, sp, #28
 8000888:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = FLASH0_CS_Pin|NRF_CE_Pin|NRF_CS_Pin;
 800088a:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800088c:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800088e:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000890:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000894:	f001 fb68 	bl	8001f68 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = NRF_IRQ_Pin;
 8000898:	f44f 7380 	mov.w	r3, #256	; 0x100
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(NRF_IRQ_GPIO_Port, &GPIO_InitStruct);
 800089c:	a907      	add	r1, sp, #28
 800089e:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = NRF_IRQ_Pin;
 80008a0:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 80008a2:	f8cd 9020 	str.w	r9, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80008a6:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(NRF_IRQ_GPIO_Port, &GPIO_InitStruct);
 80008a8:	f001 fb5e 	bl	8001f68 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LED2_Pin;
 80008ac:	f44f 7300 	mov.w	r3, #512	; 0x200
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED2_GPIO_Port, &GPIO_InitStruct);
 80008b0:	a907      	add	r1, sp, #28
 80008b2:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = LED2_Pin;
 80008b4:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80008b6:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80008b8:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80008ba:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(LED2_GPIO_Port, &GPIO_InitStruct);
 80008bc:	f001 fb54 	bl	8001f68 <HAL_GPIO_Init>
  /*Configure GPIO pins : PEPin PEPin */
  GPIO_InitStruct.Pin = LED0_Pin|LED1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80008c0:	a907      	add	r1, sp, #28
 80008c2:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = LED0_Pin|LED1_Pin;
 80008c4:	f8cd 801c 	str.w	r8, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80008c8:	9508      	str	r5, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80008ca:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80008cc:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80008ce:	f001 fb4b 	bl	8001f68 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI3_IRQn, 5, 0);
 80008d2:	4622      	mov	r2, r4
 80008d4:	2105      	movs	r1, #5
 80008d6:	2009      	movs	r0, #9
 80008d8:	f001 f968 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 80008dc:	2009      	movs	r0, #9
 80008de:	f001 f999 	bl	8001c14 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI4_IRQn, 5, 0);
 80008e2:	4622      	mov	r2, r4
 80008e4:	2105      	movs	r1, #5
 80008e6:	200a      	movs	r0, #10
 80008e8:	f001 f960 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 80008ec:	200a      	movs	r0, #10
 80008ee:	f001 f991 	bl	8001c14 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
 80008f2:	4622      	mov	r2, r4
 80008f4:	2105      	movs	r1, #5
 80008f6:	2017      	movs	r0, #23
 80008f8:	f001 f958 	bl	8001bac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 80008fc:	2017      	movs	r0, #23
 80008fe:	f001 f989 	bl	8001c14 <HAL_NVIC_EnableIRQ>

}
 8000902:	b00d      	add	sp, #52	; 0x34
 8000904:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000908:	40023800 	.word	0x40023800
 800090c:	40021000 	.word	0x40021000
 8000910:	40020400 	.word	0x40020400
 8000914:	40020800 	.word	0x40020800
 8000918:	10210000 	.word	0x10210000

0800091c <MX_I2C2_Init>:

I2C_HandleTypeDef hi2c2;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
 800091c:	b508      	push	{r3, lr}

  hi2c2.Instance = I2C2;
 800091e:	480c      	ldr	r0, [pc, #48]	; (8000950 <MX_I2C2_Init+0x34>)
  hi2c2.Init.ClockSpeed = 100000;
 8000920:	4b0c      	ldr	r3, [pc, #48]	; (8000954 <MX_I2C2_Init+0x38>)
 8000922:	f8df e034 	ldr.w	lr, [pc, #52]	; 8000958 <MX_I2C2_Init+0x3c>
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000926:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  hi2c2.Init.ClockSpeed = 100000;
 800092a:	e880 4008 	stmia.w	r0, {r3, lr}
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
 800092e:	2300      	movs	r3, #0
 8000930:	6083      	str	r3, [r0, #8]
  hi2c2.Init.OwnAddress1 = 0;
 8000932:	60c3      	str	r3, [r0, #12]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000934:	6102      	str	r2, [r0, #16]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8000936:	6143      	str	r3, [r0, #20]
  hi2c2.Init.OwnAddress2 = 0;
 8000938:	6183      	str	r3, [r0, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800093a:	61c3      	str	r3, [r0, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800093c:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 800093e:	f001 fc09 	bl	8002154 <HAL_I2C_Init>
 8000942:	b118      	cbz	r0, 800094c <MX_I2C2_Init+0x30>
  {
    Error_Handler();
  }

}
 8000944:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8000948:	f000 b8dc 	b.w	8000b04 <Error_Handler>
 800094c:	bd08      	pop	{r3, pc}
 800094e:	bf00      	nop
 8000950:	20004434 	.word	0x20004434
 8000954:	40005800 	.word	0x40005800
 8000958:	000186a0 	.word	0x000186a0

0800095c <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 800095c:	b530      	push	{r4, r5, lr}
 800095e:	4604      	mov	r4, r0
 8000960:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000962:	2214      	movs	r2, #20
 8000964:	2100      	movs	r1, #0
 8000966:	a803      	add	r0, sp, #12
 8000968:	f005 fe85 	bl	8006676 <memset>
  if(i2cHandle->Instance==I2C2)
 800096c:	6822      	ldr	r2, [r4, #0]
 800096e:	4b1d      	ldr	r3, [pc, #116]	; (80009e4 <HAL_I2C_MspInit+0x88>)
 8000970:	429a      	cmp	r2, r3
 8000972:	d134      	bne.n	80009de <HAL_I2C_MspInit+0x82>
  {
  /* USER CODE BEGIN I2C2_MspInit 0 */

  /* USER CODE END I2C2_MspInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000974:	4c1c      	ldr	r4, [pc, #112]	; (80009e8 <HAL_I2C_MspInit+0x8c>)
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000976:	481d      	ldr	r0, [pc, #116]	; (80009ec <HAL_I2C_MspInit+0x90>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000978:	2500      	movs	r5, #0
 800097a:	9501      	str	r5, [sp, #4]
 800097c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800097e:	f043 0302 	orr.w	r3, r3, #2
 8000982:	6323      	str	r3, [r4, #48]	; 0x30
 8000984:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000986:	f003 0302 	and.w	r3, r3, #2
 800098a:	9301      	str	r3, [sp, #4]
 800098c:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 800098e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8000992:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8000994:	2312      	movs	r3, #18
 8000996:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000998:	2301      	movs	r3, #1
 800099a:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800099c:	2303      	movs	r3, #3
 800099e:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80009a0:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 80009a2:	2304      	movs	r3, #4
 80009a4:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80009a6:	f001 fadf 	bl	8001f68 <HAL_GPIO_Init>

    /* I2C2 clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
 80009aa:	9502      	str	r5, [sp, #8]
 80009ac:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80009ae:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80009b2:	6423      	str	r3, [r4, #64]	; 0x40
 80009b4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80009b6:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000

    /* I2C2 interrupt Init */
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 5, 0);
 80009ba:	462a      	mov	r2, r5
 80009bc:	2105      	movs	r1, #5
    __HAL_RCC_I2C2_CLK_ENABLE();
 80009be:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 5, 0);
 80009c0:	2021      	movs	r0, #33	; 0x21
    __HAL_RCC_I2C2_CLK_ENABLE();
 80009c2:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 5, 0);
 80009c4:	f001 f8f2 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
 80009c8:	2021      	movs	r0, #33	; 0x21
 80009ca:	f001 f923 	bl	8001c14 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C2_ER_IRQn, 5, 0);
 80009ce:	2022      	movs	r0, #34	; 0x22
 80009d0:	462a      	mov	r2, r5
 80009d2:	2105      	movs	r1, #5
 80009d4:	f001 f8ea 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);
 80009d8:	2022      	movs	r0, #34	; 0x22
 80009da:	f001 f91b 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
 80009de:	b009      	add	sp, #36	; 0x24
 80009e0:	bd30      	pop	{r4, r5, pc}
 80009e2:	bf00      	nop
 80009e4:	40005800 	.word	0x40005800
 80009e8:	40023800 	.word	0x40023800
 80009ec:	40020400 	.word	0x40020400

080009f0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80009f0:	b530      	push	{r4, r5, lr}
 80009f2:	b095      	sub	sp, #84	; 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80009f4:	2230      	movs	r2, #48	; 0x30
 80009f6:	2100      	movs	r1, #0
 80009f8:	a808      	add	r0, sp, #32
 80009fa:	f005 fe3c 	bl	8006676 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80009fe:	2100      	movs	r1, #0
 8000a00:	2214      	movs	r2, #20
 8000a02:	a803      	add	r0, sp, #12
 8000a04:	f005 fe37 	bl	8006676 <memset>

  /**Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8000a08:	2400      	movs	r4, #0
 8000a0a:	4b1e      	ldr	r3, [pc, #120]	; (8000a84 <SystemClock_Config+0x94>)
 8000a0c:	9401      	str	r4, [sp, #4]
 8000a0e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000a10:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000a14:	641a      	str	r2, [r3, #64]	; 0x40
 8000a16:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000a18:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000a1c:	9301      	str	r3, [sp, #4]
 8000a1e:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000a20:	4b19      	ldr	r3, [pc, #100]	; (8000a88 <SystemClock_Config+0x98>)
 8000a22:	9402      	str	r4, [sp, #8]
 8000a24:	681a      	ldr	r2, [r3, #0]
 8000a26:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000a2a:	601a      	str	r2, [r3, #0]
 8000a2c:	681b      	ldr	r3, [r3, #0]
 8000a2e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000a32:	9302      	str	r3, [sp, #8]
 8000a34:	9b02      	ldr	r3, [sp, #8]
  /**Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8000a36:	2309      	movs	r3, #9
 8000a38:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000a3a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000a3e:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8000a40:	2301      	movs	r3, #1
 8000a42:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000a44:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8000a48:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 4;
 8000a4a:	2304      	movs	r3, #4
 8000a4c:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 168;
 8000a4e:	23a8      	movs	r3, #168	; 0xa8
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000a50:	2502      	movs	r5, #2
  RCC_OscInitStruct.PLL.PLLN = 168;
 8000a52:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000a54:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8000a56:	2307      	movs	r3, #7
 8000a58:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000a5a:	950e      	str	r5, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000a5c:	9512      	str	r5, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000a5e:	f002 f91b 	bl	8002c98 <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /**Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000a62:	230f      	movs	r3, #15
 8000a64:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000a66:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000a6a:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000a6c:	2105      	movs	r1, #5
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000a6e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000a72:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000a74:	9504      	str	r5, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000a76:	9405      	str	r4, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000a78:	9307      	str	r3, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000a7a:	f002 fabd 	bl	8002ff8 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
}
 8000a7e:	b015      	add	sp, #84	; 0x54
 8000a80:	bd30      	pop	{r4, r5, pc}
 8000a82:	bf00      	nop
 8000a84:	40023800 	.word	0x40023800
 8000a88:	40007000 	.word	0x40007000

08000a8c <main>:
{
 8000a8c:	b508      	push	{r3, lr}
  HAL_Init();
 8000a8e:	f000 ff01 	bl	8001894 <HAL_Init>
  SystemClock_Config();
 8000a92:	f7ff ffad 	bl	80009f0 <SystemClock_Config>
  HAL_I2C_MspInit(&hi2c2);
 8000a96:	4815      	ldr	r0, [pc, #84]	; (8000aec <main+0x60>)
 8000a98:	f7ff ff60 	bl	800095c <HAL_I2C_MspInit>
  MX_GPIO_Init();
 8000a9c:	f7ff fe6c 	bl	8000778 <MX_GPIO_Init>
  MX_DMA_Init();
 8000aa0:	f7ff fdf2 	bl	8000688 <MX_DMA_Init>
  MX_USART1_UART_Init();
 8000aa4:	f000 fd7c 	bl	80015a0 <MX_USART1_UART_Init>
  MX_SPI1_Init();
 8000aa8:	f000 f82e 	bl	8000b08 <MX_SPI1_Init>
  MX_USB_OTG_FS_PCD_Init();
 8000aac:	f000 fe9c 	bl	80017e8 <MX_USB_OTG_FS_PCD_Init>
  MX_TIM1_Init();
 8000ab0:	f000 fd0c 	bl	80014cc <MX_TIM1_Init>
  MX_TIM2_Init();
 8000ab4:	f000 fa7c 	bl	8000fb0 <MX_TIM2_Init>
  MX_TIM3_Init();
 8000ab8:	f000 faa6 	bl	8001008 <MX_TIM3_Init>
  MX_TIM4_Init();
 8000abc:	f000 fad2 	bl	8001064 <MX_TIM4_Init>
  MX_USART2_UART_Init();
 8000ac0:	f000 fd8a 	bl	80015d8 <MX_USART2_UART_Init>
  MX_TIM8_Init();
 8000ac4:	f000 fb42 	bl	800114c <MX_TIM8_Init>
  MX_TIM5_Init();
 8000ac8:	f000 fafa 	bl	80010c0 <MX_TIM5_Init>
  MX_I2C2_Init();
 8000acc:	f7ff ff26 	bl	800091c <MX_I2C2_Init>
  MX_SPI2_Init();
 8000ad0:	f000 f83c 	bl	8000b4c <MX_SPI2_Init>
  MX_TIM12_Init();
 8000ad4:	f000 fb68 	bl	80011a8 <MX_TIM12_Init>
  MX_ADC1_Init();
 8000ad8:	f7ff fd0a 	bl	80004f0 <MX_ADC1_Init>
  appInit();
 8000adc:	f005 f920 	bl	8005d20 <appInit>
  MX_FREERTOS_Init();
 8000ae0:	f7ff fe36 	bl	8000750 <MX_FREERTOS_Init>
  osKernelStart();
 8000ae4:	f003 fcb8 	bl	8004458 <osKernelStart>
 8000ae8:	e7fe      	b.n	8000ae8 <main+0x5c>
 8000aea:	bf00      	nop
 8000aec:	20004434 	.word	0x20004434

08000af0 <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM7) {
 8000af0:	6802      	ldr	r2, [r0, #0]
 8000af2:	4b03      	ldr	r3, [pc, #12]	; (8000b00 <HAL_TIM_PeriodElapsedCallback+0x10>)
 8000af4:	429a      	cmp	r2, r3
 8000af6:	d101      	bne.n	8000afc <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
 8000af8:	f000 bee6 	b.w	80018c8 <HAL_IncTick>
 8000afc:	4770      	bx	lr
 8000afe:	bf00      	nop
 8000b00:	40001400 	.word	0x40001400

08000b04 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8000b04:	4770      	bx	lr
	...

08000b08 <MX_SPI1_Init>:
DMA_HandleTypeDef hdma_spi2_rx;
DMA_HandleTypeDef hdma_spi2_tx;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 8000b08:	b508      	push	{r3, lr}

  hspi1.Instance = SPI1;
 8000b0a:	480e      	ldr	r0, [pc, #56]	; (8000b44 <MX_SPI1_Init+0x3c>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000b0c:	4b0e      	ldr	r3, [pc, #56]	; (8000b48 <MX_SPI1_Init+0x40>)
 8000b0e:	f44f 7e82 	mov.w	lr, #260	; 0x104
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000b12:	f44f 7200 	mov.w	r2, #512	; 0x200
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000b16:	e880 4008 	stmia.w	r0, {r3, lr}
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8000b1a:	2300      	movs	r3, #0
 8000b1c:	6083      	str	r3, [r0, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8000b1e:	60c3      	str	r3, [r0, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000b20:	6103      	str	r3, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000b22:	6143      	str	r3, [r0, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000b24:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000b26:	6203      	str	r3, [r0, #32]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8000b28:	2210      	movs	r2, #16
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8000b2a:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000b2c:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 8000b2e:	230a      	movs	r3, #10
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8000b30:	61c2      	str	r2, [r0, #28]
  hspi1.Init.CRCPolynomial = 10;
 8000b32:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000b34:	f002 fb38 	bl	80031a8 <HAL_SPI_Init>
 8000b38:	b118      	cbz	r0, 8000b42 <MX_SPI1_Init+0x3a>
  {
    Error_Handler();
  }

}
 8000b3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8000b3e:	f7ff bfe1 	b.w	8000b04 <Error_Handler>
 8000b42:	bd08      	pop	{r3, pc}
 8000b44:	20004540 	.word	0x20004540
 8000b48:	40013000 	.word	0x40013000

08000b4c <MX_SPI2_Init>:
/* SPI2 init function */
void MX_SPI2_Init(void)
{
 8000b4c:	b508      	push	{r3, lr}

  hspi2.Instance = SPI2;
 8000b4e:	480e      	ldr	r0, [pc, #56]	; (8000b88 <MX_SPI2_Init+0x3c>)
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8000b50:	4b0e      	ldr	r3, [pc, #56]	; (8000b8c <MX_SPI2_Init+0x40>)
 8000b52:	f44f 7e82 	mov.w	lr, #260	; 0x104
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8000b56:	f44f 7200 	mov.w	r2, #512	; 0x200
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8000b5a:	e880 4008 	stmia.w	r0, {r3, lr}
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 8000b5e:	2300      	movs	r3, #0
 8000b60:	6083      	str	r3, [r0, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 8000b62:	60c3      	str	r3, [r0, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000b64:	6103      	str	r3, [r0, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000b66:	6143      	str	r3, [r0, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8000b68:	6182      	str	r2, [r0, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000b6a:	6203      	str	r3, [r0, #32]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8000b6c:	2208      	movs	r2, #8
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8000b6e:	6243      	str	r3, [r0, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000b70:	6283      	str	r3, [r0, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 10;
 8000b72:	230a      	movs	r3, #10
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8000b74:	61c2      	str	r2, [r0, #28]
  hspi2.Init.CRCPolynomial = 10;
 8000b76:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8000b78:	f002 fb16 	bl	80031a8 <HAL_SPI_Init>
 8000b7c:	b118      	cbz	r0, 8000b86 <MX_SPI2_Init+0x3a>
  {
    Error_Handler();
  }

}
 8000b7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8000b82:	f7ff bfbf 	b.w	8000b04 <Error_Handler>
 8000b86:	bd08      	pop	{r3, pc}
 8000b88:	20004488 	.word	0x20004488
 8000b8c:	40003800 	.word	0x40003800

08000b90 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8000b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000b94:	2214      	movs	r2, #20
{
 8000b96:	b08a      	sub	sp, #40	; 0x28
 8000b98:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000b9a:	2100      	movs	r1, #0
 8000b9c:	eb0d 0002 	add.w	r0, sp, r2
 8000ba0:	f005 fd69 	bl	8006676 <memset>
  if(spiHandle->Instance==SPI1)
 8000ba4:	682b      	ldr	r3, [r5, #0]
 8000ba6:	4a6a      	ldr	r2, [pc, #424]	; (8000d50 <HAL_SPI_MspInit+0x1c0>)
 8000ba8:	4293      	cmp	r3, r2
 8000baa:	d15e      	bne.n	8000c6a <HAL_SPI_MspInit+0xda>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000bac:	2600      	movs	r6, #0
 8000bae:	4b69      	ldr	r3, [pc, #420]	; (8000d54 <HAL_SPI_MspInit+0x1c4>)
 8000bb0:	9600      	str	r6, [sp, #0]
 8000bb2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000bb4:	4868      	ldr	r0, [pc, #416]	; (8000d58 <HAL_SPI_MspInit+0x1c8>)

    /* SPI1 DMA Init */
    /* SPI1_RX Init */
    hdma_spi1_rx.Instance = DMA2_Stream0;
 8000bb6:	4c69      	ldr	r4, [pc, #420]	; (8000d5c <HAL_SPI_MspInit+0x1cc>)
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000bb8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000bbc:	645a      	str	r2, [r3, #68]	; 0x44
 8000bbe:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000bc0:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8000bc4:	9200      	str	r2, [sp, #0]
 8000bc6:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000bc8:	9601      	str	r6, [sp, #4]
 8000bca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000bcc:	f042 0202 	orr.w	r2, r2, #2
 8000bd0:	631a      	str	r2, [r3, #48]	; 0x30
 8000bd2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000bd4:	f003 0302 	and.w	r3, r3, #2
 8000bd8:	9301      	str	r3, [sp, #4]
 8000bda:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
 8000bdc:	2338      	movs	r3, #56	; 0x38
 8000bde:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000be0:	2302      	movs	r3, #2
 8000be2:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000be4:	2303      	movs	r3, #3
 8000be6:	9308      	str	r3, [sp, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000be8:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8000bea:	2305      	movs	r3, #5
 8000bec:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000bee:	f001 f9bb 	bl	8001f68 <HAL_GPIO_Init>
    hdma_spi1_rx.Init.Channel = DMA_CHANNEL_3;
 8000bf2:	4a5b      	ldr	r2, [pc, #364]	; (8000d60 <HAL_SPI_MspInit+0x1d0>)
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8000bf4:	60a6      	str	r6, [r4, #8]
    hdma_spi1_rx.Init.Channel = DMA_CHANNEL_3;
 8000bf6:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 8000bfa:	e884 000c 	stmia.w	r4, {r2, r3}
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
 8000bfe:	4620      	mov	r0, r4
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8000c00:	f44f 6380 	mov.w	r3, #1024	; 0x400
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000c04:	60e6      	str	r6, [r4, #12]
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8000c06:	6123      	str	r3, [r4, #16]
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000c08:	6166      	str	r6, [r4, #20]
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000c0a:	61a6      	str	r6, [r4, #24]
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
 8000c0c:	61e6      	str	r6, [r4, #28]
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
 8000c0e:	6226      	str	r6, [r4, #32]
    hdma_spi1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000c10:	6266      	str	r6, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
 8000c12:	f001 f821 	bl	8001c58 <HAL_DMA_Init>
 8000c16:	b108      	cbz	r0, 8000c1c <HAL_SPI_MspInit+0x8c>
    {
      Error_Handler();
 8000c18:	f7ff ff74 	bl	8000b04 <Error_Handler>
    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi1_rx);

    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA2_Stream3;
    hdma_spi1_tx.Init.Channel = DMA_CHANNEL_3;
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000c1c:	4b51      	ldr	r3, [pc, #324]	; (8000d64 <HAL_SPI_MspInit+0x1d4>)
    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi1_rx);
 8000c1e:	64ec      	str	r4, [r5, #76]	; 0x4c
 8000c20:	63a5      	str	r5, [r4, #56]	; 0x38
    hdma_spi1_tx.Instance = DMA2_Stream3;
 8000c22:	4c51      	ldr	r4, [pc, #324]	; (8000d68 <HAL_SPI_MspInit+0x1d8>)
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000c24:	f04f 68c0 	mov.w	r8, #100663296	; 0x6000000
 8000c28:	f04f 0c40 	mov.w	ip, #64	; 0x40
 8000c2c:	e884 1108 	stmia.w	r4, {r3, r8, ip}
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000c30:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000c34:	2300      	movs	r3, #0
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_spi1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 8000c36:	4620      	mov	r0, r4
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000c38:	60e3      	str	r3, [r4, #12]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000c3a:	6122      	str	r2, [r4, #16]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000c3c:	6163      	str	r3, [r4, #20]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000c3e:	61a3      	str	r3, [r4, #24]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 8000c40:	61e3      	str	r3, [r4, #28]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8000c42:	6223      	str	r3, [r4, #32]
    hdma_spi1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000c44:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 8000c46:	f001 f807 	bl	8001c58 <HAL_DMA_Init>
 8000c4a:	b108      	cbz	r0, 8000c50 <HAL_SPI_MspInit+0xc0>
    {
      Error_Handler();
 8000c4c:	f7ff ff5a 	bl	8000b04 <Error_Handler>
    }

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi1_tx);

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
 8000c50:	2023      	movs	r0, #35	; 0x23
    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi1_tx);
 8000c52:	64ac      	str	r4, [r5, #72]	; 0x48
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
 8000c54:	2200      	movs	r2, #0
 8000c56:	2105      	movs	r1, #5
    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi1_tx);
 8000c58:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
 8000c5a:	f000 ffa7 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
 8000c5e:	2023      	movs	r0, #35	; 0x23

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi2_tx);

    /* SPI2 interrupt Init */
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 8000c60:	f000 ffd8 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 8000c64:	b00a      	add	sp, #40	; 0x28
 8000c66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(spiHandle->Instance==SPI2)
 8000c6a:	4a40      	ldr	r2, [pc, #256]	; (8000d6c <HAL_SPI_MspInit+0x1dc>)
 8000c6c:	4293      	cmp	r3, r2
 8000c6e:	d1f9      	bne.n	8000c64 <HAL_SPI_MspInit+0xd4>
    __HAL_RCC_SPI2_CLK_ENABLE();
 8000c70:	2600      	movs	r6, #0
 8000c72:	4b38      	ldr	r3, [pc, #224]	; (8000d54 <HAL_SPI_MspInit+0x1c4>)
 8000c74:	9602      	str	r6, [sp, #8]
 8000c76:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000c78:	483d      	ldr	r0, [pc, #244]	; (8000d70 <HAL_SPI_MspInit+0x1e0>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 8000c7a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000c7e:	641a      	str	r2, [r3, #64]	; 0x40
 8000c80:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000c82:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8000c86:	9202      	str	r2, [sp, #8]
 8000c88:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000c8a:	9603      	str	r6, [sp, #12]
 8000c8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000c8e:	f042 0204 	orr.w	r2, r2, #4
 8000c92:	631a      	str	r2, [r3, #48]	; 0x30
 8000c94:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000c96:	f002 0204 	and.w	r2, r2, #4
 8000c9a:	9203      	str	r2, [sp, #12]
 8000c9c:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000c9e:	9604      	str	r6, [sp, #16]
 8000ca0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000ca2:	f042 0202 	orr.w	r2, r2, #2
 8000ca6:	631a      	str	r2, [r3, #48]	; 0x30
 8000ca8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000caa:	f003 0302 	and.w	r3, r3, #2
 8000cae:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8000cb0:	2405      	movs	r4, #5
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000cb2:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8000cb4:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8000cb6:	230c      	movs	r3, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000cb8:	f04f 0802 	mov.w	r8, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000cbc:	2703      	movs	r7, #3
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000cbe:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8000cc0:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000cc2:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000cc6:	9708      	str	r7, [sp, #32]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000cc8:	f001 f94e 	bl	8001f68 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_13;
 8000ccc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000cd0:	4821      	ldr	r0, [pc, #132]	; (8000d58 <HAL_SPI_MspInit+0x1c8>)
    GPIO_InitStruct.Pin = GPIO_PIN_13;
 8000cd2:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000cd4:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8000cd6:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000cd8:	f8cd 8018 	str.w	r8, [sp, #24]
    hdma_spi2_rx.Instance = DMA1_Stream3;
 8000cdc:	4c25      	ldr	r4, [pc, #148]	; (8000d74 <HAL_SPI_MspInit+0x1e4>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000cde:	9607      	str	r6, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000ce0:	9708      	str	r7, [sp, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000ce2:	f001 f941 	bl	8001f68 <HAL_GPIO_Init>
    hdma_spi2_rx.Instance = DMA1_Stream3;
 8000ce6:	4b24      	ldr	r3, [pc, #144]	; (8000d78 <HAL_SPI_MspInit+0x1e8>)
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8000ce8:	60a6      	str	r6, [r4, #8]
    hdma_spi2_rx.Init.Channel = DMA_CHANNEL_0;
 8000cea:	e884 0048 	stmia.w	r4, {r3, r6}
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
 8000cee:	4620      	mov	r0, r4
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
 8000cf0:	f44f 6380 	mov.w	r3, #1024	; 0x400
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000cf4:	60e6      	str	r6, [r4, #12]
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
 8000cf6:	6123      	str	r3, [r4, #16]
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000cf8:	6166      	str	r6, [r4, #20]
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000cfa:	61a6      	str	r6, [r4, #24]
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
 8000cfc:	61e6      	str	r6, [r4, #28]
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_LOW;
 8000cfe:	6226      	str	r6, [r4, #32]
    hdma_spi2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000d00:	6266      	str	r6, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
 8000d02:	f000 ffa9 	bl	8001c58 <HAL_DMA_Init>
 8000d06:	b108      	cbz	r0, 8000d0c <HAL_SPI_MspInit+0x17c>
      Error_Handler();
 8000d08:	f7ff fefc 	bl	8000b04 <Error_Handler>
    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi2_rx);
 8000d0c:	64ec      	str	r4, [r5, #76]	; 0x4c
 8000d0e:	63a5      	str	r5, [r4, #56]	; 0x38
    hdma_spi2_tx.Instance = DMA1_Stream4;
 8000d10:	4c1a      	ldr	r4, [pc, #104]	; (8000d7c <HAL_SPI_MspInit+0x1ec>)
 8000d12:	4b1b      	ldr	r3, [pc, #108]	; (8000d80 <HAL_SPI_MspInit+0x1f0>)
 8000d14:	6023      	str	r3, [r4, #0]
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000d16:	2240      	movs	r2, #64	; 0x40
    hdma_spi2_tx.Init.Channel = DMA_CHANNEL_0;
 8000d18:	2300      	movs	r3, #0
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8000d1a:	60a2      	str	r2, [r4, #8]
    if (HAL_DMA_Init(&hdma_spi2_tx) != HAL_OK)
 8000d1c:	4620      	mov	r0, r4
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000d1e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_spi2_tx.Init.Channel = DMA_CHANNEL_0;
 8000d22:	6063      	str	r3, [r4, #4]
    hdma_spi2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000d24:	60e3      	str	r3, [r4, #12]
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000d26:	6122      	str	r2, [r4, #16]
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000d28:	6163      	str	r3, [r4, #20]
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000d2a:	61a3      	str	r3, [r4, #24]
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
 8000d2c:	61e3      	str	r3, [r4, #28]
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_LOW;
 8000d2e:	6223      	str	r3, [r4, #32]
    hdma_spi2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8000d30:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi2_tx) != HAL_OK)
 8000d32:	f000 ff91 	bl	8001c58 <HAL_DMA_Init>
 8000d36:	b108      	cbz	r0, 8000d3c <HAL_SPI_MspInit+0x1ac>
      Error_Handler();
 8000d38:	f7ff fee4 	bl	8000b04 <Error_Handler>
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
 8000d3c:	2024      	movs	r0, #36	; 0x24
    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi2_tx);
 8000d3e:	64ac      	str	r4, [r5, #72]	; 0x48
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
 8000d40:	2200      	movs	r2, #0
 8000d42:	2105      	movs	r1, #5
    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi2_tx);
 8000d44:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
 8000d46:	f000 ff31 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 8000d4a:	2024      	movs	r0, #36	; 0x24
 8000d4c:	e788      	b.n	8000c60 <HAL_SPI_MspInit+0xd0>
 8000d4e:	bf00      	nop
 8000d50:	40013000 	.word	0x40013000
 8000d54:	40023800 	.word	0x40023800
 8000d58:	40020400 	.word	0x40020400
 8000d5c:	20004598 	.word	0x20004598
 8000d60:	40026410 	.word	0x40026410
 8000d64:	40026458 	.word	0x40026458
 8000d68:	20004658 	.word	0x20004658
 8000d6c:	40003800 	.word	0x40003800
 8000d70:	40020800 	.word	0x40020800
 8000d74:	200044e0 	.word	0x200044e0
 8000d78:	40026058 	.word	0x40026058
 8000d7c:	200045f8 	.word	0x200045f8
 8000d80:	40026070 	.word	0x40026070

08000d84 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000d84:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d86:	4b0f      	ldr	r3, [pc, #60]	; (8000dc4 <HAL_MspInit+0x40>)
 8000d88:	2200      	movs	r2, #0
 8000d8a:	9200      	str	r2, [sp, #0]
 8000d8c:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8000d8e:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000d92:	6459      	str	r1, [r3, #68]	; 0x44
 8000d94:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8000d96:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 8000d9a:	9100      	str	r1, [sp, #0]
 8000d9c:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000d9e:	9201      	str	r2, [sp, #4]
 8000da0:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8000da2:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8000da6:	6419      	str	r1, [r3, #64]	; 0x40
 8000da8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000daa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000dae:	9301      	str	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8000db0:	210f      	movs	r1, #15
 8000db2:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 8000db6:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8000db8:	f000 fef8 	bl	8001bac <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000dbc:	b003      	add	sp, #12
 8000dbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8000dc2:	bf00      	nop
 8000dc4:	40023800 	.word	0x40023800

08000dc8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000dc8:	b530      	push	{r4, r5, lr}
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM7 IRQ priority */
  HAL_NVIC_SetPriority(TIM7_IRQn, TickPriority ,0); 
 8000dca:	4601      	mov	r1, r0
{
 8000dcc:	b089      	sub	sp, #36	; 0x24
  HAL_NVIC_SetPriority(TIM7_IRQn, TickPriority ,0); 
 8000dce:	2200      	movs	r2, #0
 8000dd0:	2037      	movs	r0, #55	; 0x37
 8000dd2:	f000 feeb 	bl	8001bac <HAL_NVIC_SetPriority>
  
  /* Enable the TIM7 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM7_IRQn); 
 8000dd6:	2037      	movs	r0, #55	; 0x37
 8000dd8:	f000 ff1c 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM7 clock */
  __HAL_RCC_TIM7_CLK_ENABLE();
 8000ddc:	2500      	movs	r5, #0
 8000dde:	4b15      	ldr	r3, [pc, #84]	; (8000e34 <HAL_InitTick+0x6c>)
 8000de0:	9502      	str	r5, [sp, #8]
 8000de2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   
  /* Compute the prescaler value to have TIM7 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM7 */
  htim7.Instance = TIM7;
 8000de4:	4c14      	ldr	r4, [pc, #80]	; (8000e38 <HAL_InitTick+0x70>)
  __HAL_RCC_TIM7_CLK_ENABLE();
 8000de6:	f042 0220 	orr.w	r2, r2, #32
 8000dea:	641a      	str	r2, [r3, #64]	; 0x40
 8000dec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000dee:	f003 0320 	and.w	r3, r3, #32
 8000df2:	9302      	str	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000df4:	a901      	add	r1, sp, #4
 8000df6:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM7_CLK_ENABLE();
 8000df8:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000dfa:	f002 f9b7 	bl	800316c <HAL_RCC_GetClockConfig>
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 8000dfe:	f002 f995 	bl	800312c <HAL_RCC_GetPCLK1Freq>
  htim7.Instance = TIM7;
 8000e02:	4b0e      	ldr	r3, [pc, #56]	; (8000e3c <HAL_InitTick+0x74>)
 8000e04:	6023      	str	r3, [r4, #0]
  + Period = [(TIM7CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim7.Init.Period = (1000000 / 1000) - 1;
 8000e06:	f240 33e7 	movw	r3, #999	; 0x3e7
 8000e0a:	60e3      	str	r3, [r4, #12]
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 8000e0c:	0040      	lsls	r0, r0, #1
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8000e0e:	4b0c      	ldr	r3, [pc, #48]	; (8000e40 <HAL_InitTick+0x78>)
 8000e10:	fbb0 f0f3 	udiv	r0, r0, r3
 8000e14:	3801      	subs	r0, #1
  htim7.Init.Prescaler = uwPrescalerValue;
 8000e16:	6060      	str	r0, [r4, #4]
  htim7.Init.ClockDivision = 0;
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim7) == HAL_OK)
 8000e18:	4620      	mov	r0, r4
  htim7.Init.ClockDivision = 0;
 8000e1a:	6125      	str	r5, [r4, #16]
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000e1c:	60a5      	str	r5, [r4, #8]
  if(HAL_TIM_Base_Init(&htim7) == HAL_OK)
 8000e1e:	f002 fc5b 	bl	80036d8 <HAL_TIM_Base_Init>
 8000e22:	b920      	cbnz	r0, 8000e2e <HAL_InitTick+0x66>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim7);
 8000e24:	4620      	mov	r0, r4
 8000e26:	f002 fafe 	bl	8003426 <HAL_TIM_Base_Start_IT>
  }
  
  /* Return function status */
  return HAL_ERROR;
}
 8000e2a:	b009      	add	sp, #36	; 0x24
 8000e2c:	bd30      	pop	{r4, r5, pc}
  return HAL_ERROR;
 8000e2e:	2001      	movs	r0, #1
 8000e30:	e7fb      	b.n	8000e2a <HAL_InitTick+0x62>
 8000e32:	bf00      	nop
 8000e34:	40023800 	.word	0x40023800
 8000e38:	200046b8 	.word	0x200046b8
 8000e3c:	40001400 	.word	0x40001400
 8000e40:	000f4240 	.word	0x000f4240

08000e44 <NMI_Handler>:
 8000e44:	4770      	bx	lr

08000e46 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000e46:	e7fe      	b.n	8000e46 <HardFault_Handler>

08000e48 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000e48:	e7fe      	b.n	8000e48 <MemManage_Handler>

08000e4a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000e4a:	e7fe      	b.n	8000e4a <BusFault_Handler>

08000e4c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000e4c:	e7fe      	b.n	8000e4c <UsageFault_Handler>

08000e4e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000e4e:	4770      	bx	lr

08000e50 <EXTI3_IRQHandler>:
void EXTI3_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI3_IRQn 0 */

  /* USER CODE END EXTI3_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
 8000e50:	2008      	movs	r0, #8
 8000e52:	f001 b973 	b.w	800213c <HAL_GPIO_EXTI_IRQHandler>

08000e56 <EXTI4_IRQHandler>:
void EXTI4_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI4_IRQn 0 */

  /* USER CODE END EXTI4_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
 8000e56:	2010      	movs	r0, #16
 8000e58:	f001 b970 	b.w	800213c <HAL_GPIO_EXTI_IRQHandler>

08000e5c <DMA1_Stream3_IRQHandler>:
void DMA1_Stream3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream3_IRQn 0 */

  /* USER CODE END DMA1_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_rx);
 8000e5c:	4801      	ldr	r0, [pc, #4]	; (8000e64 <DMA1_Stream3_IRQHandler+0x8>)
 8000e5e:	f000 bfc9 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000e62:	bf00      	nop
 8000e64:	200044e0 	.word	0x200044e0

08000e68 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream4_IRQn 0 */

  /* USER CODE END DMA1_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_tx);
 8000e68:	4801      	ldr	r0, [pc, #4]	; (8000e70 <DMA1_Stream4_IRQHandler+0x8>)
 8000e6a:	f000 bfc3 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000e6e:	bf00      	nop
 8000e70:	200045f8 	.word	0x200045f8

08000e74 <DMA1_Stream5_IRQHandler>:
void DMA1_Stream5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream5_IRQn 0 */

  /* USER CODE END DMA1_Stream5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_rx);
 8000e74:	4801      	ldr	r0, [pc, #4]	; (8000e7c <DMA1_Stream5_IRQHandler+0x8>)
 8000e76:	f000 bfbd 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000e7a:	bf00      	nop
 8000e7c:	20004898 	.word	0x20004898

08000e80 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream6_IRQn 0 */

  /* USER CODE END DMA1_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 8000e80:	4801      	ldr	r0, [pc, #4]	; (8000e88 <DMA1_Stream6_IRQHandler+0x8>)
 8000e82:	f000 bfb7 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000e86:	bf00      	nop
 8000e88:	200049b8 	.word	0x200049b8

08000e8c <EXTI9_5_IRQHandler>:
void EXTI9_5_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
 8000e8c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000e90:	f001 b954 	b.w	800213c <HAL_GPIO_EXTI_IRQHandler>

08000e94 <I2C2_EV_IRQHandler>:
void I2C2_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
 8000e94:	4801      	ldr	r0, [pc, #4]	; (8000e9c <I2C2_EV_IRQHandler+0x8>)
 8000e96:	f001 ba69 	b.w	800236c <HAL_I2C_EV_IRQHandler>
 8000e9a:	bf00      	nop
 8000e9c:	20004434 	.word	0x20004434

08000ea0 <I2C2_ER_IRQHandler>:
void I2C2_ER_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_ER_IRQn 0 */

  /* USER CODE END I2C2_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c2);
 8000ea0:	4801      	ldr	r0, [pc, #4]	; (8000ea8 <I2C2_ER_IRQHandler+0x8>)
 8000ea2:	f001 bdcd 	b.w	8002a40 <HAL_I2C_ER_IRQHandler>
 8000ea6:	bf00      	nop
 8000ea8:	20004434 	.word	0x20004434

08000eac <SPI1_IRQHandler>:
void SPI1_IRQHandler(void)
{
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
 8000eac:	4801      	ldr	r0, [pc, #4]	; (8000eb4 <SPI1_IRQHandler+0x8>)
 8000eae:	f002 b9b9 	b.w	8003224 <HAL_SPI_IRQHandler>
 8000eb2:	bf00      	nop
 8000eb4:	20004540 	.word	0x20004540

08000eb8 <SPI2_IRQHandler>:
void SPI2_IRQHandler(void)
{
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
 8000eb8:	4801      	ldr	r0, [pc, #4]	; (8000ec0 <SPI2_IRQHandler+0x8>)
 8000eba:	f002 b9b3 	b.w	8003224 <HAL_SPI_IRQHandler>
 8000ebe:	bf00      	nop
 8000ec0:	20004488 	.word	0x20004488

08000ec4 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8000ec4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART1_IRQn 0 */
  void HAL_UART_ExtraIRQHandler(UART_HandleTypeDef * huart);
  HAL_UART_ExtraIRQHandler(&huart1);
 8000ec6:	4c04      	ldr	r4, [pc, #16]	; (8000ed8 <USART1_IRQHandler+0x14>)
 8000ec8:	4620      	mov	r0, r4
 8000eca:	f005 fb3d 	bl	8006548 <HAL_UART_ExtraIRQHandler>
  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8000ece:	4620      	mov	r0, r4
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8000ed0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_IRQHandler(&huart1);
 8000ed4:	f003 b8d6 	b.w	8004084 <HAL_UART_IRQHandler>
 8000ed8:	20004a18 	.word	0x20004a18

08000edc <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 8000edc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */
  void HAL_UART_ExtraIRQHandler(UART_HandleTypeDef * huart);
  HAL_UART_ExtraIRQHandler(&huart2);
 8000ede:	4c04      	ldr	r4, [pc, #16]	; (8000ef0 <USART2_IRQHandler+0x14>)
 8000ee0:	4620      	mov	r0, r4
 8000ee2:	f005 fb31 	bl	8006548 <HAL_UART_ExtraIRQHandler>
  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8000ee6:	4620      	mov	r0, r4
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 8000ee8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_IRQHandler(&huart2);
 8000eec:	f003 b8ca 	b.w	8004084 <HAL_UART_IRQHandler>
 8000ef0:	20004a58 	.word	0x20004a58

08000ef4 <TIM8_BRK_TIM12_IRQHandler>:

/**
  * @brief This function handles TIM8 break interrupt and TIM12 global interrupt.
  */
void TIM8_BRK_TIM12_IRQHandler(void)
{
 8000ef4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM8_BRK_TIM12_IRQn 0 */

  /* USER CODE END TIM8_BRK_TIM12_IRQn 0 */
  HAL_TIM_IRQHandler(&htim8);
 8000ef6:	4804      	ldr	r0, [pc, #16]	; (8000f08 <TIM8_BRK_TIM12_IRQHandler+0x14>)
 8000ef8:	f002 fae8 	bl	80034cc <HAL_TIM_IRQHandler>
  HAL_TIM_IRQHandler(&htim12);
 8000efc:	4803      	ldr	r0, [pc, #12]	; (8000f0c <TIM8_BRK_TIM12_IRQHandler+0x18>)
  /* USER CODE BEGIN TIM8_BRK_TIM12_IRQn 1 */

  /* USER CODE END TIM8_BRK_TIM12_IRQn 1 */
}
 8000efe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_TIM_IRQHandler(&htim12);
 8000f02:	f002 bae3 	b.w	80034cc <HAL_TIM_IRQHandler>
 8000f06:	bf00      	nop
 8000f08:	200046f4 	.word	0x200046f4
 8000f0c:	2000485c 	.word	0x2000485c

08000f10 <TIM5_IRQHandler>:
void TIM5_IRQHandler(void)
{
  /* USER CODE BEGIN TIM5_IRQn 0 */

  /* USER CODE END TIM5_IRQn 0 */
  HAL_TIM_IRQHandler(&htim5);
 8000f10:	4801      	ldr	r0, [pc, #4]	; (8000f18 <TIM5_IRQHandler+0x8>)
 8000f12:	f002 badb 	b.w	80034cc <HAL_TIM_IRQHandler>
 8000f16:	bf00      	nop
 8000f18:	2000476c 	.word	0x2000476c

08000f1c <TIM7_IRQHandler>:
void TIM7_IRQHandler(void)
{
  /* USER CODE BEGIN TIM7_IRQn 0 */

  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
 8000f1c:	4801      	ldr	r0, [pc, #4]	; (8000f24 <TIM7_IRQHandler+0x8>)
 8000f1e:	f002 bad5 	b.w	80034cc <HAL_TIM_IRQHandler>
 8000f22:	bf00      	nop
 8000f24:	200046b8 	.word	0x200046b8

08000f28 <DMA2_Stream0_IRQHandler>:
void DMA2_Stream0_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
 8000f28:	4801      	ldr	r0, [pc, #4]	; (8000f30 <DMA2_Stream0_IRQHandler+0x8>)
 8000f2a:	f000 bf63 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000f2e:	bf00      	nop
 8000f30:	20004598 	.word	0x20004598

08000f34 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream2_IRQn 0 */

  /* USER CODE END DMA2_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 8000f34:	4801      	ldr	r0, [pc, #4]	; (8000f3c <DMA2_Stream2_IRQHandler+0x8>)
 8000f36:	f000 bf5d 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000f3a:	bf00      	nop
 8000f3c:	20004958 	.word	0x20004958

08000f40 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 8000f40:	4801      	ldr	r0, [pc, #4]	; (8000f48 <DMA2_Stream3_IRQHandler+0x8>)
 8000f42:	f000 bf57 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000f46:	bf00      	nop
 8000f48:	20004658 	.word	0x20004658

08000f4c <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream4_IRQn 0 */

  /* USER CODE END DMA2_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 8000f4c:	4801      	ldr	r0, [pc, #4]	; (8000f54 <DMA2_Stream4_IRQHandler+0x8>)
 8000f4e:	f000 bf51 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000f52:	bf00      	nop
 8000f54:	200043d0 	.word	0x200043d0

08000f58 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream7_IRQn 0 */

  /* USER CODE END DMA2_Stream7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 8000f58:	4801      	ldr	r0, [pc, #4]	; (8000f60 <DMA2_Stream7_IRQHandler+0x8>)
 8000f5a:	f000 bf4b 	b.w	8001df4 <HAL_DMA_IRQHandler>
 8000f5e:	bf00      	nop
 8000f60:	200048f8 	.word	0x200048f8

08000f64 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000f64:	490f      	ldr	r1, [pc, #60]	; (8000fa4 <SystemInit+0x40>)
 8000f66:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000f6a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000f6e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000f72:	4b0d      	ldr	r3, [pc, #52]	; (8000fa8 <SystemInit+0x44>)
 8000f74:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000f76:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8000f78:	f042 0201 	orr.w	r2, r2, #1
 8000f7c:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000f7e:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000f80:	681a      	ldr	r2, [r3, #0]
 8000f82:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000f86:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000f8a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000f8c:	4a07      	ldr	r2, [pc, #28]	; (8000fac <SystemInit+0x48>)
 8000f8e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000f90:	681a      	ldr	r2, [r3, #0]
 8000f92:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000f96:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000f98:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000f9a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000f9e:	608b      	str	r3, [r1, #8]
 8000fa0:	4770      	bx	lr
 8000fa2:	bf00      	nop
 8000fa4:	e000ed00 	.word	0xe000ed00
 8000fa8:	40023800 	.word	0x40023800
 8000fac:	24003010 	.word	0x24003010

08000fb0 <MX_TIM2_Init>:
  HAL_TIM_MspPostInit(&htim1);

}
/* TIM2 init function */
void MX_TIM2_Init(void)
{
 8000fb0:	b510      	push	{r4, lr}
 8000fb2:	b08c      	sub	sp, #48	; 0x30
  TIM_Encoder_InitTypeDef sConfig = {0};
 8000fb4:	2100      	movs	r1, #0
 8000fb6:	2224      	movs	r2, #36	; 0x24
 8000fb8:	a803      	add	r0, sp, #12
 8000fba:	f005 fb5c 	bl	8006676 <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  htim2.Instance = TIM2;
 8000fbe:	4811      	ldr	r0, [pc, #68]	; (8001004 <MX_TIM2_Init+0x54>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000fc0:	2400      	movs	r4, #0
  htim2.Instance = TIM2;
 8000fc2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  htim2.Init.Prescaler = 0;
 8000fc6:	e880 0018 	stmia.w	r0, {r3, r4}
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 65535;
 8000fca:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000fce:	60c3      	str	r3, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8000fd0:	2303      	movs	r3, #3
 8000fd2:	9303      	str	r3, [sp, #12]
  sConfig.IC1Filter = 0;
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 0;
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8000fd4:	a903      	add	r1, sp, #12
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8000fd6:	2301      	movs	r3, #1
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000fd8:	9401      	str	r4, [sp, #4]
 8000fda:	9402      	str	r4, [sp, #8]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000fdc:	6084      	str	r4, [r0, #8]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000fde:	6104      	str	r4, [r0, #16]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8000fe0:	9305      	str	r3, [sp, #20]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 8000fe2:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8000fe4:	f002 fbc6 	bl	8003774 <HAL_TIM_Encoder_Init>
 8000fe8:	b108      	cbz	r0, 8000fee <MX_TIM2_Init+0x3e>
  {
    Error_Handler();
 8000fea:	f7ff fd8b 	bl	8000b04 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8000fee:	a901      	add	r1, sp, #4
 8000ff0:	4804      	ldr	r0, [pc, #16]	; (8001004 <MX_TIM2_Init+0x54>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8000ff2:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000ff4:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8000ff6:	f002 fd81 	bl	8003afc <HAL_TIMEx_MasterConfigSynchronization>
 8000ffa:	b108      	cbz	r0, 8001000 <MX_TIM2_Init+0x50>
  {
    Error_Handler();
 8000ffc:	f7ff fd82 	bl	8000b04 <Error_Handler>
  }

}
 8001000:	b00c      	add	sp, #48	; 0x30
 8001002:	bd10      	pop	{r4, pc}
 8001004:	20004820 	.word	0x20004820

08001008 <MX_TIM3_Init>:
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 8001008:	b510      	push	{r4, lr}
 800100a:	b08c      	sub	sp, #48	; 0x30
  TIM_Encoder_InitTypeDef sConfig = {0};
 800100c:	2100      	movs	r1, #0
 800100e:	2224      	movs	r2, #36	; 0x24
 8001010:	a803      	add	r0, sp, #12
 8001012:	f005 fb30 	bl	8006676 <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  htim3.Instance = TIM3;
 8001016:	4811      	ldr	r0, [pc, #68]	; (800105c <MX_TIM3_Init+0x54>)
 8001018:	4b11      	ldr	r3, [pc, #68]	; (8001060 <MX_TIM3_Init+0x58>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800101a:	2400      	movs	r4, #0
  htim3.Init.Prescaler = 0;
 800101c:	e880 0018 	stmia.w	r0, {r3, r4}
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
 8001020:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001024:	60c3      	str	r3, [r0, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8001026:	2303      	movs	r3, #3
 8001028:	9303      	str	r3, [sp, #12]
  sConfig.IC1Filter = 0;
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 0;
  if (HAL_TIM_Encoder_Init(&htim3, &sConfig) != HAL_OK)
 800102a:	a903      	add	r1, sp, #12
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 800102c:	2301      	movs	r3, #1
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800102e:	9401      	str	r4, [sp, #4]
 8001030:	9402      	str	r4, [sp, #8]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001032:	6084      	str	r4, [r0, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001034:	6104      	str	r4, [r0, #16]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8001036:	9305      	str	r3, [sp, #20]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 8001038:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIM_Encoder_Init(&htim3, &sConfig) != HAL_OK)
 800103a:	f002 fb9b 	bl	8003774 <HAL_TIM_Encoder_Init>
 800103e:	b108      	cbz	r0, 8001044 <MX_TIM3_Init+0x3c>
  {
    Error_Handler();
 8001040:	f7ff fd60 	bl	8000b04 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8001044:	a901      	add	r1, sp, #4
 8001046:	4805      	ldr	r0, [pc, #20]	; (800105c <MX_TIM3_Init+0x54>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001048:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800104a:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 800104c:	f002 fd56 	bl	8003afc <HAL_TIMEx_MasterConfigSynchronization>
 8001050:	b108      	cbz	r0, 8001056 <MX_TIM3_Init+0x4e>
  {
    Error_Handler();
 8001052:	f7ff fd57 	bl	8000b04 <Error_Handler>
  }

}
 8001056:	b00c      	add	sp, #48	; 0x30
 8001058:	bd10      	pop	{r4, pc}
 800105a:	bf00      	nop
 800105c:	200047a8 	.word	0x200047a8
 8001060:	40000400 	.word	0x40000400

08001064 <MX_TIM4_Init>:
/* TIM4 init function */
void MX_TIM4_Init(void)
{
 8001064:	b510      	push	{r4, lr}
 8001066:	b08c      	sub	sp, #48	; 0x30
  TIM_Encoder_InitTypeDef sConfig = {0};
 8001068:	2100      	movs	r1, #0
 800106a:	2224      	movs	r2, #36	; 0x24
 800106c:	a803      	add	r0, sp, #12
 800106e:	f005 fb02 	bl	8006676 <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  htim4.Instance = TIM4;
 8001072:	4811      	ldr	r0, [pc, #68]	; (80010b8 <MX_TIM4_Init+0x54>)
 8001074:	4b11      	ldr	r3, [pc, #68]	; (80010bc <MX_TIM4_Init+0x58>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8001076:	2400      	movs	r4, #0
  htim4.Init.Prescaler = 0;
 8001078:	e880 0018 	stmia.w	r0, {r3, r4}
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65535;
 800107c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001080:	60c3      	str	r3, [r0, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8001082:	2303      	movs	r3, #3
 8001084:	9303      	str	r3, [sp, #12]
  sConfig.IC1Filter = 0;
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 0;
  if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)
 8001086:	a903      	add	r1, sp, #12
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8001088:	2301      	movs	r3, #1
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800108a:	9401      	str	r4, [sp, #4]
 800108c:	9402      	str	r4, [sp, #8]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 800108e:	6084      	str	r4, [r0, #8]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001090:	6104      	str	r4, [r0, #16]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8001092:	9305      	str	r3, [sp, #20]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 8001094:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)
 8001096:	f002 fb6d 	bl	8003774 <HAL_TIM_Encoder_Init>
 800109a:	b108      	cbz	r0, 80010a0 <MX_TIM4_Init+0x3c>
  {
    Error_Handler();
 800109c:	f7ff fd32 	bl	8000b04 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 80010a0:	a901      	add	r1, sp, #4
 80010a2:	4805      	ldr	r0, [pc, #20]	; (80010b8 <MX_TIM4_Init+0x54>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80010a4:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80010a6:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 80010a8:	f002 fd28 	bl	8003afc <HAL_TIMEx_MasterConfigSynchronization>
 80010ac:	b108      	cbz	r0, 80010b2 <MX_TIM4_Init+0x4e>
  {
    Error_Handler();
 80010ae:	f7ff fd29 	bl	8000b04 <Error_Handler>
  }

}
 80010b2:	b00c      	add	sp, #48	; 0x30
 80010b4:	bd10      	pop	{r4, pc}
 80010b6:	bf00      	nop
 80010b8:	20004730 	.word	0x20004730
 80010bc:	40000800 	.word	0x40000800

080010c0 <MX_TIM5_Init>:
/* TIM5 init function */
void MX_TIM5_Init(void)
{
 80010c0:	b510      	push	{r4, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80010c2:	2400      	movs	r4, #0
{
 80010c4:	b086      	sub	sp, #24
  TIM_IC_InitTypeDef sConfigIC = {0};
 80010c6:	2210      	movs	r2, #16
 80010c8:	4621      	mov	r1, r4
 80010ca:	a802      	add	r0, sp, #8
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80010cc:	9400      	str	r4, [sp, #0]
 80010ce:	9401      	str	r4, [sp, #4]
  TIM_IC_InitTypeDef sConfigIC = {0};
 80010d0:	f005 fad1 	bl	8006676 <memset>

  htim5.Instance = TIM5;
 80010d4:	481b      	ldr	r0, [pc, #108]	; (8001144 <MX_TIM5_Init+0x84>)
  htim5.Init.Prescaler = 83;
 80010d6:	4a1c      	ldr	r2, [pc, #112]	; (8001148 <MX_TIM5_Init+0x88>)
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 80010d8:	6084      	str	r4, [r0, #8]
  htim5.Init.Prescaler = 83;
 80010da:	2353      	movs	r3, #83	; 0x53
 80010dc:	e880 000c 	stmia.w	r0, {r2, r3}
  htim5.Init.Period = 4294967295;
 80010e0:	f04f 33ff 	mov.w	r3, #4294967295
 80010e4:	60c3      	str	r3, [r0, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80010e6:	6104      	str	r4, [r0, #16]
  if (HAL_TIM_IC_Init(&htim5) != HAL_OK)
 80010e8:	f002 fb2a 	bl	8003740 <HAL_TIM_IC_Init>
 80010ec:	b108      	cbz	r0, 80010f2 <MX_TIM5_Init+0x32>
  {
    Error_Handler();
 80010ee:	f7ff fd09 	bl	8000b04 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 80010f2:	4669      	mov	r1, sp
 80010f4:	4813      	ldr	r0, [pc, #76]	; (8001144 <MX_TIM5_Init+0x84>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80010f6:	9400      	str	r4, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80010f8:	9401      	str	r4, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 80010fa:	f002 fcff 	bl	8003afc <HAL_TIMEx_MasterConfigSynchronization>
 80010fe:	b108      	cbz	r0, 8001104 <MX_TIM5_Init+0x44>
  {
    Error_Handler();
 8001100:	f7ff fd00 	bl	8000b04 <Error_Handler>
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
 8001104:	2200      	movs	r2, #0
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 8001106:	2301      	movs	r3, #1
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
 8001108:	a902      	add	r1, sp, #8
 800110a:	480e      	ldr	r0, [pc, #56]	; (8001144 <MX_TIM5_Init+0x84>)
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
 800110c:	9202      	str	r2, [sp, #8]
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 800110e:	9303      	str	r3, [sp, #12]
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
 8001110:	9204      	str	r2, [sp, #16]
  sConfigIC.ICFilter = 0;
 8001112:	9205      	str	r2, [sp, #20]
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
 8001114:	f002 fbb2 	bl	800387c <HAL_TIM_IC_ConfigChannel>
 8001118:	b108      	cbz	r0, 800111e <MX_TIM5_Init+0x5e>
  {
    Error_Handler();
 800111a:	f7ff fcf3 	bl	8000b04 <Error_Handler>
  }
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_3) != HAL_OK)
 800111e:	2208      	movs	r2, #8
 8001120:	eb0d 0102 	add.w	r1, sp, r2
 8001124:	4807      	ldr	r0, [pc, #28]	; (8001144 <MX_TIM5_Init+0x84>)
 8001126:	f002 fba9 	bl	800387c <HAL_TIM_IC_ConfigChannel>
 800112a:	b108      	cbz	r0, 8001130 <MX_TIM5_Init+0x70>
  {
    Error_Handler();
 800112c:	f7ff fcea 	bl	8000b04 <Error_Handler>
  }
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_4) != HAL_OK)
 8001130:	220c      	movs	r2, #12
 8001132:	a902      	add	r1, sp, #8
 8001134:	4803      	ldr	r0, [pc, #12]	; (8001144 <MX_TIM5_Init+0x84>)
 8001136:	f002 fba1 	bl	800387c <HAL_TIM_IC_ConfigChannel>
 800113a:	b108      	cbz	r0, 8001140 <MX_TIM5_Init+0x80>
  {
    Error_Handler();
 800113c:	f7ff fce2 	bl	8000b04 <Error_Handler>
  }

}
 8001140:	b006      	add	sp, #24
 8001142:	bd10      	pop	{r4, pc}
 8001144:	2000476c 	.word	0x2000476c
 8001148:	40000c00 	.word	0x40000c00

0800114c <MX_TIM8_Init>:
/* TIM8 init function */
void MX_TIM8_Init(void)
{
 800114c:	b510      	push	{r4, lr}
 800114e:	b08c      	sub	sp, #48	; 0x30
  TIM_Encoder_InitTypeDef sConfig = {0};
 8001150:	2100      	movs	r1, #0
 8001152:	2224      	movs	r2, #36	; 0x24
 8001154:	a803      	add	r0, sp, #12
 8001156:	f005 fa8e 	bl	8006676 <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  htim8.Instance = TIM8;
 800115a:	4811      	ldr	r0, [pc, #68]	; (80011a0 <MX_TIM8_Init+0x54>)
 800115c:	4b11      	ldr	r3, [pc, #68]	; (80011a4 <MX_TIM8_Init+0x58>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800115e:	2400      	movs	r4, #0
  htim8.Init.Prescaler = 0;
 8001160:	e880 0018 	stmia.w	r0, {r3, r4}
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim8.Init.Period = 65535;
 8001164:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001168:	60c3      	str	r3, [r0, #12]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim8.Init.RepetitionCounter = 0;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 800116a:	2303      	movs	r3, #3
 800116c:	9303      	str	r3, [sp, #12]
  sConfig.IC1Filter = 0;
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = 0;
  if (HAL_TIM_Encoder_Init(&htim8, &sConfig) != HAL_OK)
 800116e:	a903      	add	r1, sp, #12
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8001170:	2301      	movs	r3, #1
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8001172:	9401      	str	r4, [sp, #4]
 8001174:	9402      	str	r4, [sp, #8]
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001176:	6084      	str	r4, [r0, #8]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001178:	6104      	str	r4, [r0, #16]
  htim8.Init.RepetitionCounter = 0;
 800117a:	6144      	str	r4, [r0, #20]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 800117c:	9305      	str	r3, [sp, #20]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 800117e:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIM_Encoder_Init(&htim8, &sConfig) != HAL_OK)
 8001180:	f002 faf8 	bl	8003774 <HAL_TIM_Encoder_Init>
 8001184:	b108      	cbz	r0, 800118a <MX_TIM8_Init+0x3e>
  {
    Error_Handler();
 8001186:	f7ff fcbd 	bl	8000b04 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 800118a:	a901      	add	r1, sp, #4
 800118c:	4804      	ldr	r0, [pc, #16]	; (80011a0 <MX_TIM8_Init+0x54>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800118e:	9401      	str	r4, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001190:	9402      	str	r4, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8001192:	f002 fcb3 	bl	8003afc <HAL_TIMEx_MasterConfigSynchronization>
 8001196:	b108      	cbz	r0, 800119c <MX_TIM8_Init+0x50>
  {
    Error_Handler();
 8001198:	f7ff fcb4 	bl	8000b04 <Error_Handler>
  }

}
 800119c:	b00c      	add	sp, #48	; 0x30
 800119e:	bd10      	pop	{r4, pc}
 80011a0:	200046f4 	.word	0x200046f4
 80011a4:	40010400 	.word	0x40010400

080011a8 <MX_TIM12_Init>:
/* TIM12 init function */
void MX_TIM12_Init(void)
{
 80011a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  TIM_IC_InitTypeDef sConfigIC = {0};
 80011aa:	2210      	movs	r2, #16
 80011ac:	2100      	movs	r1, #0
 80011ae:	4668      	mov	r0, sp
 80011b0:	f005 fa61 	bl	8006676 <memset>

  htim12.Instance = TIM12;
 80011b4:	4813      	ldr	r0, [pc, #76]	; (8001204 <MX_TIM12_Init+0x5c>)
  htim12.Init.Prescaler = 83;
 80011b6:	4b14      	ldr	r3, [pc, #80]	; (8001208 <MX_TIM12_Init+0x60>)
 80011b8:	f04f 0c53 	mov.w	ip, #83	; 0x53
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
 80011bc:	2400      	movs	r4, #0
  htim12.Init.Prescaler = 83;
 80011be:	e880 1008 	stmia.w	r0, {r3, ip}
  htim12.Init.Period = 65535;
 80011c2:	f64f 73ff 	movw	r3, #65535	; 0xffff
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
 80011c6:	6084      	str	r4, [r0, #8]
  htim12.Init.Period = 65535;
 80011c8:	60c3      	str	r3, [r0, #12]
  htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80011ca:	6104      	str	r4, [r0, #16]
  if (HAL_TIM_IC_Init(&htim12) != HAL_OK)
 80011cc:	f002 fab8 	bl	8003740 <HAL_TIM_IC_Init>
 80011d0:	b108      	cbz	r0, 80011d6 <MX_TIM12_Init+0x2e>
  {
    Error_Handler();
 80011d2:	f7ff fc97 	bl	8000b04 <Error_Handler>
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 80011d6:	2301      	movs	r3, #1
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim12, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
 80011d8:	2200      	movs	r2, #0
 80011da:	4669      	mov	r1, sp
 80011dc:	4809      	ldr	r0, [pc, #36]	; (8001204 <MX_TIM12_Init+0x5c>)
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
 80011de:	9400      	str	r4, [sp, #0]
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
 80011e0:	9301      	str	r3, [sp, #4]
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
 80011e2:	9402      	str	r4, [sp, #8]
  sConfigIC.ICFilter = 0;
 80011e4:	9403      	str	r4, [sp, #12]
  if (HAL_TIM_IC_ConfigChannel(&htim12, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
 80011e6:	f002 fb49 	bl	800387c <HAL_TIM_IC_ConfigChannel>
 80011ea:	b108      	cbz	r0, 80011f0 <MX_TIM12_Init+0x48>
  {
    Error_Handler();
 80011ec:	f7ff fc8a 	bl	8000b04 <Error_Handler>
  }
  if (HAL_TIM_IC_ConfigChannel(&htim12, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
 80011f0:	2204      	movs	r2, #4
 80011f2:	4669      	mov	r1, sp
 80011f4:	4803      	ldr	r0, [pc, #12]	; (8001204 <MX_TIM12_Init+0x5c>)
 80011f6:	f002 fb41 	bl	800387c <HAL_TIM_IC_ConfigChannel>
 80011fa:	b108      	cbz	r0, 8001200 <MX_TIM12_Init+0x58>
  {
    Error_Handler();
 80011fc:	f7ff fc82 	bl	8000b04 <Error_Handler>
  }

}
 8001200:	b004      	add	sp, #16
 8001202:	bd10      	pop	{r4, pc}
 8001204:	2000485c 	.word	0x2000485c
 8001208:	40001800 	.word	0x40001800

0800120c <HAL_TIM_PWM_MspInit>:

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle)
{

  if(tim_pwmHandle->Instance==TIM1)
 800120c:	6802      	ldr	r2, [r0, #0]
 800120e:	4b09      	ldr	r3, [pc, #36]	; (8001234 <HAL_TIM_PWM_MspInit+0x28>)
 8001210:	429a      	cmp	r2, r3
{
 8001212:	b082      	sub	sp, #8
  if(tim_pwmHandle->Instance==TIM1)
 8001214:	d10b      	bne.n	800122e <HAL_TIM_PWM_MspInit+0x22>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* TIM1 clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8001216:	2300      	movs	r3, #0
 8001218:	9301      	str	r3, [sp, #4]
 800121a:	4b07      	ldr	r3, [pc, #28]	; (8001238 <HAL_TIM_PWM_MspInit+0x2c>)
 800121c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800121e:	f042 0201 	orr.w	r2, r2, #1
 8001222:	645a      	str	r2, [r3, #68]	; 0x44
 8001224:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001226:	f003 0301 	and.w	r3, r3, #1
 800122a:	9301      	str	r3, [sp, #4]
 800122c:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
}
 800122e:	b002      	add	sp, #8
 8001230:	4770      	bx	lr
 8001232:	bf00      	nop
 8001234:	40010000 	.word	0x40010000
 8001238:	40023800 	.word	0x40023800

0800123c <HAL_TIM_Encoder_MspInit>:

void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef* tim_encoderHandle)
{
 800123c:	b510      	push	{r4, lr}
 800123e:	4604      	mov	r4, r0
 8001240:	b08e      	sub	sp, #56	; 0x38

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001242:	2214      	movs	r2, #20
 8001244:	2100      	movs	r1, #0
 8001246:	a809      	add	r0, sp, #36	; 0x24
 8001248:	f005 fa15 	bl	8006676 <memset>
  if(tim_encoderHandle->Instance==TIM2)
 800124c:	6823      	ldr	r3, [r4, #0]
 800124e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001252:	d122      	bne.n	800129a <HAL_TIM_Encoder_MspInit+0x5e>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8001254:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 8001258:	2100      	movs	r1, #0
 800125a:	9101      	str	r1, [sp, #4]
 800125c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800125e:	f042 0201 	orr.w	r2, r2, #1
 8001262:	641a      	str	r2, [r3, #64]	; 0x40
 8001264:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001266:	f002 0201 	and.w	r2, r2, #1
 800126a:	9201      	str	r2, [sp, #4]
 800126c:	9a01      	ldr	r2, [sp, #4]
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800126e:	9102      	str	r1, [sp, #8]
 8001270:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001272:	f042 0201 	orr.w	r2, r2, #1
 8001276:	631a      	str	r2, [r3, #48]	; 0x30
 8001278:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800127a:	f003 0301 	and.w	r3, r3, #1
 800127e:	9302      	str	r3, [sp, #8]
 8001280:	9b02      	ldr	r3, [sp, #8]
    /**TIM2 GPIO Configuration    
    PA1     ------> TIM2_CH2
    PA5     ------> TIM2_CH1 
    */
    GPIO_InitStruct.Pin = ENC0_B_Pin|ENC0_A_Pin;
 8001282:	2322      	movs	r3, #34	; 0x22
 8001284:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001286:	2312      	movs	r3, #18
 8001288:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800128a:	2301      	movs	r3, #1
    GPIO_InitStruct.Pin = ENC1_A_Pin|ENC1_B_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800128c:	483a      	ldr	r0, [pc, #232]	; (8001378 <HAL_TIM_Encoder_MspInit+0x13c>)
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 800128e:	930d      	str	r3, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001290:	a909      	add	r1, sp, #36	; 0x24
 8001292:	f000 fe69 	bl	8001f68 <HAL_GPIO_Init>
    HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
  /* USER CODE BEGIN TIM8_MspInit 1 */

  /* USER CODE END TIM8_MspInit 1 */
  }
}
 8001296:	b00e      	add	sp, #56	; 0x38
 8001298:	bd10      	pop	{r4, pc}
  else if(tim_encoderHandle->Instance==TIM3)
 800129a:	4a38      	ldr	r2, [pc, #224]	; (800137c <HAL_TIM_Encoder_MspInit+0x140>)
 800129c:	4293      	cmp	r3, r2
 800129e:	d11b      	bne.n	80012d8 <HAL_TIM_Encoder_MspInit+0x9c>
    __HAL_RCC_TIM3_CLK_ENABLE();
 80012a0:	4b37      	ldr	r3, [pc, #220]	; (8001380 <HAL_TIM_Encoder_MspInit+0x144>)
 80012a2:	2100      	movs	r1, #0
 80012a4:	9103      	str	r1, [sp, #12]
 80012a6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80012a8:	f042 0202 	orr.w	r2, r2, #2
 80012ac:	641a      	str	r2, [r3, #64]	; 0x40
 80012ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80012b0:	f002 0202 	and.w	r2, r2, #2
 80012b4:	9203      	str	r2, [sp, #12]
 80012b6:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80012b8:	9104      	str	r1, [sp, #16]
 80012ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80012bc:	f042 0201 	orr.w	r2, r2, #1
 80012c0:	631a      	str	r2, [r3, #48]	; 0x30
 80012c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80012c4:	f003 0301 	and.w	r3, r3, #1
 80012c8:	9304      	str	r3, [sp, #16]
 80012ca:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = ENC1_A_Pin|ENC1_B_Pin;
 80012cc:	23c0      	movs	r3, #192	; 0xc0
 80012ce:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80012d0:	2312      	movs	r3, #18
 80012d2:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 80012d4:	2302      	movs	r3, #2
 80012d6:	e7d9      	b.n	800128c <HAL_TIM_Encoder_MspInit+0x50>
  else if(tim_encoderHandle->Instance==TIM4)
 80012d8:	4a2a      	ldr	r2, [pc, #168]	; (8001384 <HAL_TIM_Encoder_MspInit+0x148>)
 80012da:	4293      	cmp	r3, r2
 80012dc:	d11f      	bne.n	800131e <HAL_TIM_Encoder_MspInit+0xe2>
    __HAL_RCC_TIM4_CLK_ENABLE();
 80012de:	4b28      	ldr	r3, [pc, #160]	; (8001380 <HAL_TIM_Encoder_MspInit+0x144>)
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80012e0:	4829      	ldr	r0, [pc, #164]	; (8001388 <HAL_TIM_Encoder_MspInit+0x14c>)
    __HAL_RCC_TIM4_CLK_ENABLE();
 80012e2:	2100      	movs	r1, #0
 80012e4:	9105      	str	r1, [sp, #20]
 80012e6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80012e8:	f042 0204 	orr.w	r2, r2, #4
 80012ec:	641a      	str	r2, [r3, #64]	; 0x40
 80012ee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80012f0:	f002 0204 	and.w	r2, r2, #4
 80012f4:	9205      	str	r2, [sp, #20]
 80012f6:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80012f8:	9106      	str	r1, [sp, #24]
 80012fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80012fc:	f042 0208 	orr.w	r2, r2, #8
 8001300:	631a      	str	r2, [r3, #48]	; 0x30
 8001302:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001304:	f003 0308 	and.w	r3, r3, #8
 8001308:	9306      	str	r3, [sp, #24]
 800130a:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = ENC2_A_Pin|ENC2_B_Pin;
 800130c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8001310:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001312:	2312      	movs	r3, #18
 8001314:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8001316:	2302      	movs	r3, #2
 8001318:	930d      	str	r3, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800131a:	a909      	add	r1, sp, #36	; 0x24
 800131c:	e7b9      	b.n	8001292 <HAL_TIM_Encoder_MspInit+0x56>
  else if(tim_encoderHandle->Instance==TIM8)
 800131e:	4a1b      	ldr	r2, [pc, #108]	; (800138c <HAL_TIM_Encoder_MspInit+0x150>)
 8001320:	4293      	cmp	r3, r2
 8001322:	d1b8      	bne.n	8001296 <HAL_TIM_Encoder_MspInit+0x5a>
    __HAL_RCC_TIM8_CLK_ENABLE();
 8001324:	4b16      	ldr	r3, [pc, #88]	; (8001380 <HAL_TIM_Encoder_MspInit+0x144>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001326:	481a      	ldr	r0, [pc, #104]	; (8001390 <HAL_TIM_Encoder_MspInit+0x154>)
    __HAL_RCC_TIM8_CLK_ENABLE();
 8001328:	2400      	movs	r4, #0
 800132a:	9407      	str	r4, [sp, #28]
 800132c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800132e:	f042 0202 	orr.w	r2, r2, #2
 8001332:	645a      	str	r2, [r3, #68]	; 0x44
 8001334:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001336:	f002 0202 	and.w	r2, r2, #2
 800133a:	9207      	str	r2, [sp, #28]
 800133c:	9a07      	ldr	r2, [sp, #28]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800133e:	9408      	str	r4, [sp, #32]
 8001340:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001342:	f042 0204 	orr.w	r2, r2, #4
 8001346:	631a      	str	r2, [r3, #48]	; 0x30
 8001348:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800134a:	f003 0304 	and.w	r3, r3, #4
 800134e:	9308      	str	r3, [sp, #32]
 8001350:	9b08      	ldr	r3, [sp, #32]
    GPIO_InitStruct.Pin = ENC3_A_Pin|ENC3_B_Pin;
 8001352:	23c0      	movs	r3, #192	; 0xc0
 8001354:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001356:	2312      	movs	r3, #18
 8001358:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800135a:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 800135c:	2303      	movs	r3, #3
 800135e:	930d      	str	r3, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001360:	f000 fe02 	bl	8001f68 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, 5, 0);
 8001364:	4622      	mov	r2, r4
 8001366:	2105      	movs	r1, #5
 8001368:	202b      	movs	r0, #43	; 0x2b
 800136a:	f000 fc1f 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
 800136e:	202b      	movs	r0, #43	; 0x2b
 8001370:	f000 fc50 	bl	8001c14 <HAL_NVIC_EnableIRQ>
}
 8001374:	e78f      	b.n	8001296 <HAL_TIM_Encoder_MspInit+0x5a>
 8001376:	bf00      	nop
 8001378:	40020000 	.word	0x40020000
 800137c:	40000400 	.word	0x40000400
 8001380:	40023800 	.word	0x40023800
 8001384:	40000800 	.word	0x40000800
 8001388:	40020c00 	.word	0x40020c00
 800138c:	40010400 	.word	0x40010400
 8001390:	40020800 	.word	0x40020800

08001394 <HAL_TIM_IC_MspInit>:

void HAL_TIM_IC_MspInit(TIM_HandleTypeDef* tim_icHandle)
{
 8001394:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001396:	2214      	movs	r2, #20
{
 8001398:	b08a      	sub	sp, #40	; 0x28
 800139a:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800139c:	2100      	movs	r1, #0
 800139e:	eb0d 0002 	add.w	r0, sp, r2
 80013a2:	f005 f968 	bl	8006676 <memset>
  if(tim_icHandle->Instance==TIM5)
 80013a6:	6823      	ldr	r3, [r4, #0]
 80013a8:	4a2d      	ldr	r2, [pc, #180]	; (8001460 <HAL_TIM_IC_MspInit+0xcc>)
 80013aa:	4293      	cmp	r3, r2
 80013ac:	d12a      	bne.n	8001404 <HAL_TIM_IC_MspInit+0x70>
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* TIM5 clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();
 80013ae:	4b2d      	ldr	r3, [pc, #180]	; (8001464 <HAL_TIM_IC_MspInit+0xd0>)
    GPIO_InitStruct.Pin = IC0_Pin|IC1_Pin|IC2_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80013b0:	482d      	ldr	r0, [pc, #180]	; (8001468 <HAL_TIM_IC_MspInit+0xd4>)
    __HAL_RCC_TIM5_CLK_ENABLE();
 80013b2:	2400      	movs	r4, #0
 80013b4:	9401      	str	r4, [sp, #4]
 80013b6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80013b8:	f042 0208 	orr.w	r2, r2, #8
 80013bc:	641a      	str	r2, [r3, #64]	; 0x40
 80013be:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80013c0:	f002 0208 	and.w	r2, r2, #8
 80013c4:	9201      	str	r2, [sp, #4]
 80013c6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80013c8:	9402      	str	r4, [sp, #8]
 80013ca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80013cc:	f042 0201 	orr.w	r2, r2, #1
 80013d0:	631a      	str	r2, [r3, #48]	; 0x30
 80013d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013d4:	f003 0301 	and.w	r3, r3, #1
 80013d8:	9302      	str	r3, [sp, #8]
 80013da:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = IC0_Pin|IC1_Pin|IC2_Pin;
 80013dc:	230d      	movs	r3, #13
 80013de:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80013e0:	2312      	movs	r3, #18
 80013e2:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80013e4:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80013e6:	2302      	movs	r3, #2
 80013e8:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 80013ea:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80013ec:	f000 fdbc 	bl	8001f68 <HAL_GPIO_Init>

    /* TIM5 interrupt Init */
    HAL_NVIC_SetPriority(TIM5_IRQn, 5, 0);
 80013f0:	2032      	movs	r0, #50	; 0x32
 80013f2:	4622      	mov	r2, r4
 80013f4:	2105      	movs	r1, #5
 80013f6:	f000 fbd9 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 80013fa:	2032      	movs	r0, #50	; 0x32
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* TIM12 interrupt Init */
    HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
 80013fc:	f000 fc0a 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM12_MspInit 1 */

  /* USER CODE END TIM12_MspInit 1 */
  }
}
 8001400:	b00a      	add	sp, #40	; 0x28
 8001402:	bd10      	pop	{r4, pc}
  else if(tim_icHandle->Instance==TIM12)
 8001404:	4a19      	ldr	r2, [pc, #100]	; (800146c <HAL_TIM_IC_MspInit+0xd8>)
 8001406:	4293      	cmp	r3, r2
 8001408:	d1fa      	bne.n	8001400 <HAL_TIM_IC_MspInit+0x6c>
    __HAL_RCC_TIM12_CLK_ENABLE();
 800140a:	4b16      	ldr	r3, [pc, #88]	; (8001464 <HAL_TIM_IC_MspInit+0xd0>)
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800140c:	4818      	ldr	r0, [pc, #96]	; (8001470 <HAL_TIM_IC_MspInit+0xdc>)
    __HAL_RCC_TIM12_CLK_ENABLE();
 800140e:	2400      	movs	r4, #0
 8001410:	9403      	str	r4, [sp, #12]
 8001412:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001414:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001418:	641a      	str	r2, [r3, #64]	; 0x40
 800141a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800141c:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8001420:	9203      	str	r2, [sp, #12]
 8001422:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001424:	9404      	str	r4, [sp, #16]
 8001426:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001428:	f042 0202 	orr.w	r2, r2, #2
 800142c:	631a      	str	r2, [r3, #48]	; 0x30
 800142e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001430:	f003 0302 	and.w	r3, r3, #2
 8001434:	9304      	str	r3, [sp, #16]
 8001436:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = IC3_Pin|IC4_Pin;
 8001438:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800143c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800143e:	2312      	movs	r3, #18
 8001440:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8001442:	2302      	movs	r3, #2
 8001444:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001446:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8001448:	2309      	movs	r3, #9
 800144a:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800144c:	f000 fd8c 	bl	8001f68 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, 5, 0);
 8001450:	202b      	movs	r0, #43	; 0x2b
 8001452:	4622      	mov	r2, r4
 8001454:	2105      	movs	r1, #5
 8001456:	f000 fba9 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);
 800145a:	202b      	movs	r0, #43	; 0x2b
 800145c:	e7ce      	b.n	80013fc <HAL_TIM_IC_MspInit+0x68>
 800145e:	bf00      	nop
 8001460:	40000c00 	.word	0x40000c00
 8001464:	40023800 	.word	0x40023800
 8001468:	40020000 	.word	0x40020000
 800146c:	40001800 	.word	0x40001800
 8001470:	40020400 	.word	0x40020400

08001474 <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 8001474:	b510      	push	{r4, lr}
 8001476:	4604      	mov	r4, r0
 8001478:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800147a:	2214      	movs	r2, #20
 800147c:	2100      	movs	r1, #0
 800147e:	a801      	add	r0, sp, #4
 8001480:	f005 f8f9 	bl	8006676 <memset>
  if(timHandle->Instance==TIM1)
 8001484:	6822      	ldr	r2, [r4, #0]
 8001486:	4b0e      	ldr	r3, [pc, #56]	; (80014c0 <HAL_TIM_MspPostInit+0x4c>)
 8001488:	429a      	cmp	r2, r3
 800148a:	d116      	bne.n	80014ba <HAL_TIM_MspPostInit+0x46>
  {
  /* USER CODE BEGIN TIM1_MspPostInit 0 */

  /* USER CODE END TIM1_MspPostInit 0 */
  
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800148c:	2300      	movs	r3, #0
 800148e:	9300      	str	r3, [sp, #0]
 8001490:	4b0c      	ldr	r3, [pc, #48]	; (80014c4 <HAL_TIM_MspPostInit+0x50>)
    GPIO_InitStruct.Pin = PWM0_Pin|PWM1_Pin|PWM2_Pin|PWM3_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001492:	480d      	ldr	r0, [pc, #52]	; (80014c8 <HAL_TIM_MspPostInit+0x54>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8001494:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001496:	f042 0210 	orr.w	r2, r2, #16
 800149a:	631a      	str	r2, [r3, #48]	; 0x30
 800149c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800149e:	f003 0310 	and.w	r3, r3, #16
 80014a2:	9300      	str	r3, [sp, #0]
 80014a4:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = PWM0_Pin|PWM1_Pin|PWM2_Pin|PWM3_Pin;
 80014a6:	f44f 43d4 	mov.w	r3, #27136	; 0x6a00
 80014aa:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80014ac:	2312      	movs	r3, #18
 80014ae:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80014b0:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80014b2:	2301      	movs	r3, #1
 80014b4:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80014b6:	f000 fd57 	bl	8001f68 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 80014ba:	b006      	add	sp, #24
 80014bc:	bd10      	pop	{r4, pc}
 80014be:	bf00      	nop
 80014c0:	40010000 	.word	0x40010000
 80014c4:	40023800 	.word	0x40023800
 80014c8:	40021000 	.word	0x40021000

080014cc <MX_TIM1_Init>:
{
 80014cc:	b510      	push	{r4, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80014ce:	2400      	movs	r4, #0
{
 80014d0:	b090      	sub	sp, #64	; 0x40
  TIM_OC_InitTypeDef sConfigOC = {0};
 80014d2:	221c      	movs	r2, #28
 80014d4:	4621      	mov	r1, r4
 80014d6:	a802      	add	r0, sp, #8
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80014d8:	9400      	str	r4, [sp, #0]
 80014da:	9401      	str	r4, [sp, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 80014dc:	f005 f8cb 	bl	8006676 <memset>
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 80014e0:	221c      	movs	r2, #28
 80014e2:	4621      	mov	r1, r4
 80014e4:	a809      	add	r0, sp, #36	; 0x24
 80014e6:	f005 f8c6 	bl	8006676 <memset>
  htim1.Instance = TIM1;
 80014ea:	482b      	ldr	r0, [pc, #172]	; (8001598 <MX_TIM1_Init+0xcc>)
 80014ec:	4b2b      	ldr	r3, [pc, #172]	; (800159c <MX_TIM1_Init+0xd0>)
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 80014ee:	6084      	str	r4, [r0, #8]
  htim1.Init.Prescaler = 0;
 80014f0:	e880 0018 	stmia.w	r0, {r3, r4}
  htim1.Init.Period = 16800;
 80014f4:	f244 13a0 	movw	r3, #16800	; 0x41a0
 80014f8:	60c3      	str	r3, [r0, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80014fa:	6104      	str	r4, [r0, #16]
  htim1.Init.RepetitionCounter = 0;
 80014fc:	6144      	str	r4, [r0, #20]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 80014fe:	f002 f905 	bl	800370c <HAL_TIM_PWM_Init>
 8001502:	b108      	cbz	r0, 8001508 <MX_TIM1_Init+0x3c>
    Error_Handler();
 8001504:	f7ff fafe 	bl	8000b04 <Error_Handler>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8001508:	4669      	mov	r1, sp
 800150a:	4823      	ldr	r0, [pc, #140]	; (8001598 <MX_TIM1_Init+0xcc>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800150c:	9400      	str	r4, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800150e:	9401      	str	r4, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8001510:	f002 faf4 	bl	8003afc <HAL_TIMEx_MasterConfigSynchronization>
 8001514:	b108      	cbz	r0, 800151a <MX_TIM1_Init+0x4e>
    Error_Handler();
 8001516:	f7ff faf5 	bl	8000b04 <Error_Handler>
  sConfigOC.Pulse = 0;
 800151a:	2200      	movs	r2, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800151c:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800151e:	a902      	add	r1, sp, #8
 8001520:	481d      	ldr	r0, [pc, #116]	; (8001598 <MX_TIM1_Init+0xcc>)
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001522:	9302      	str	r3, [sp, #8]
  sConfigOC.Pulse = 0;
 8001524:	9203      	str	r2, [sp, #12]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001526:	9204      	str	r2, [sp, #16]
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8001528:	9205      	str	r2, [sp, #20]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800152a:	9206      	str	r2, [sp, #24]
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 800152c:	9207      	str	r2, [sp, #28]
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 800152e:	9208      	str	r2, [sp, #32]
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8001530:	f002 fa5c 	bl	80039ec <HAL_TIM_PWM_ConfigChannel>
 8001534:	b108      	cbz	r0, 800153a <MX_TIM1_Init+0x6e>
    Error_Handler();
 8001536:	f7ff fae5 	bl	8000b04 <Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 800153a:	2204      	movs	r2, #4
 800153c:	a902      	add	r1, sp, #8
 800153e:	4816      	ldr	r0, [pc, #88]	; (8001598 <MX_TIM1_Init+0xcc>)
 8001540:	f002 fa54 	bl	80039ec <HAL_TIM_PWM_ConfigChannel>
 8001544:	b108      	cbz	r0, 800154a <MX_TIM1_Init+0x7e>
    Error_Handler();
 8001546:	f7ff fadd 	bl	8000b04 <Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 800154a:	2208      	movs	r2, #8
 800154c:	eb0d 0102 	add.w	r1, sp, r2
 8001550:	4811      	ldr	r0, [pc, #68]	; (8001598 <MX_TIM1_Init+0xcc>)
 8001552:	f002 fa4b 	bl	80039ec <HAL_TIM_PWM_ConfigChannel>
 8001556:	b108      	cbz	r0, 800155c <MX_TIM1_Init+0x90>
    Error_Handler();
 8001558:	f7ff fad4 	bl	8000b04 <Error_Handler>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 800155c:	220c      	movs	r2, #12
 800155e:	a902      	add	r1, sp, #8
 8001560:	480d      	ldr	r0, [pc, #52]	; (8001598 <MX_TIM1_Init+0xcc>)
 8001562:	f002 fa43 	bl	80039ec <HAL_TIM_PWM_ConfigChannel>
 8001566:	b108      	cbz	r0, 800156c <MX_TIM1_Init+0xa0>
    Error_Handler();
 8001568:	f7ff facc 	bl	8000b04 <Error_Handler>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 800156c:	2300      	movs	r3, #0
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 800156e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8001572:	a909      	add	r1, sp, #36	; 0x24
 8001574:	4808      	ldr	r0, [pc, #32]	; (8001598 <MX_TIM1_Init+0xcc>)
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8001576:	9309      	str	r3, [sp, #36]	; 0x24
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 8001578:	930a      	str	r3, [sp, #40]	; 0x28
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800157a:	930b      	str	r3, [sp, #44]	; 0x2c
  sBreakDeadTimeConfig.DeadTime = 0;
 800157c:	930c      	str	r3, [sp, #48]	; 0x30
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 800157e:	930d      	str	r3, [sp, #52]	; 0x34
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8001580:	920e      	str	r2, [sp, #56]	; 0x38
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8001582:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8001584:	f002 fadc 	bl	8003b40 <HAL_TIMEx_ConfigBreakDeadTime>
 8001588:	b108      	cbz	r0, 800158e <MX_TIM1_Init+0xc2>
    Error_Handler();
 800158a:	f7ff fabb 	bl	8000b04 <Error_Handler>
  HAL_TIM_MspPostInit(&htim1);
 800158e:	4802      	ldr	r0, [pc, #8]	; (8001598 <MX_TIM1_Init+0xcc>)
 8001590:	f7ff ff70 	bl	8001474 <HAL_TIM_MspPostInit>
}
 8001594:	b010      	add	sp, #64	; 0x40
 8001596:	bd10      	pop	{r4, pc}
 8001598:	200047e4 	.word	0x200047e4
 800159c:	40010000 	.word	0x40010000

080015a0 <MX_USART1_UART_Init>:
DMA_HandleTypeDef hdma_usart2_tx;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 80015a0:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
 80015a2:	480b      	ldr	r0, [pc, #44]	; (80015d0 <MX_USART1_UART_Init+0x30>)
  huart1.Init.BaudRate = 921600;
 80015a4:	4b0b      	ldr	r3, [pc, #44]	; (80015d4 <MX_USART1_UART_Init+0x34>)
 80015a6:	f44f 2e61 	mov.w	lr, #921600	; 0xe1000
 80015aa:	e880 4008 	stmia.w	r0, {r3, lr}
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 80015ae:	220c      	movs	r2, #12
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80015b0:	2300      	movs	r3, #0
 80015b2:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 80015b4:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 80015b6:	6103      	str	r3, [r0, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80015b8:	6142      	str	r2, [r0, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80015ba:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80015bc:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80015be:	f002 fc0f 	bl	8003de0 <HAL_UART_Init>
 80015c2:	b118      	cbz	r0, 80015cc <MX_USART1_UART_Init+0x2c>
  {
    Error_Handler();
  }

}
 80015c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 80015c8:	f7ff ba9c 	b.w	8000b04 <Error_Handler>
 80015cc:	bd08      	pop	{r3, pc}
 80015ce:	bf00      	nop
 80015d0:	20004a18 	.word	0x20004a18
 80015d4:	40011000 	.word	0x40011000

080015d8 <MX_USART2_UART_Init>:
/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 80015d8:	b508      	push	{r3, lr}

  huart2.Instance = USART2;
 80015da:	480b      	ldr	r0, [pc, #44]	; (8001608 <MX_USART2_UART_Init+0x30>)
  huart2.Init.BaudRate = 921600;
 80015dc:	4b0b      	ldr	r3, [pc, #44]	; (800160c <MX_USART2_UART_Init+0x34>)
 80015de:	f44f 2e61 	mov.w	lr, #921600	; 0xe1000
 80015e2:	e880 4008 	stmia.w	r0, {r3, lr}
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 80015e6:	220c      	movs	r2, #12
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 80015e8:	2300      	movs	r3, #0
 80015ea:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 80015ec:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 80015ee:	6103      	str	r3, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 80015f0:	6142      	str	r2, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80015f2:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 80015f4:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 80015f6:	f002 fbf3 	bl	8003de0 <HAL_UART_Init>
 80015fa:	b118      	cbz	r0, 8001604 <MX_USART2_UART_Init+0x2c>
  {
    Error_Handler();
  }

}
 80015fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8001600:	f7ff ba80 	b.w	8000b04 <Error_Handler>
 8001604:	bd08      	pop	{r3, pc}
 8001606:	bf00      	nop
 8001608:	20004a58 	.word	0x20004a58
 800160c:	40004400 	.word	0x40004400

08001610 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001610:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001612:	2214      	movs	r2, #20
{
 8001614:	b08a      	sub	sp, #40	; 0x28
 8001616:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001618:	2100      	movs	r1, #0
 800161a:	eb0d 0002 	add.w	r0, sp, r2
 800161e:	f005 f82a 	bl	8006676 <memset>
  if(uartHandle->Instance==USART1)
 8001622:	682b      	ldr	r3, [r5, #0]
 8001624:	4a63      	ldr	r2, [pc, #396]	; (80017b4 <HAL_UART_MspInit+0x1a4>)
 8001626:	4293      	cmp	r3, r2
 8001628:	d162      	bne.n	80016f0 <HAL_UART_MspInit+0xe0>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800162a:	2600      	movs	r6, #0
 800162c:	4b62      	ldr	r3, [pc, #392]	; (80017b8 <HAL_UART_MspInit+0x1a8>)
 800162e:	9601      	str	r6, [sp, #4]
 8001630:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001632:	4862      	ldr	r0, [pc, #392]	; (80017bc <HAL_UART_MspInit+0x1ac>)

    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
 8001634:	4c62      	ldr	r4, [pc, #392]	; (80017c0 <HAL_UART_MspInit+0x1b0>)
    __HAL_RCC_USART1_CLK_ENABLE();
 8001636:	f042 0210 	orr.w	r2, r2, #16
 800163a:	645a      	str	r2, [r3, #68]	; 0x44
 800163c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800163e:	f002 0210 	and.w	r2, r2, #16
 8001642:	9201      	str	r2, [sp, #4]
 8001644:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001646:	9602      	str	r6, [sp, #8]
 8001648:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800164a:	f042 0201 	orr.w	r2, r2, #1
 800164e:	631a      	str	r2, [r3, #48]	; 0x30
 8001650:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001652:	f003 0301 	and.w	r3, r3, #1
 8001656:	9302      	str	r3, [sp, #8]
 8001658:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 800165a:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800165e:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001660:	2302      	movs	r3, #2
 8001662:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001664:	2301      	movs	r3, #1
 8001666:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001668:	2303      	movs	r3, #3
 800166a:	9308      	str	r3, [sp, #32]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800166c:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 800166e:	2307      	movs	r3, #7
 8001670:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001672:	f000 fc79 	bl	8001f68 <HAL_GPIO_Init>
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 8001676:	4b53      	ldr	r3, [pc, #332]	; (80017c4 <HAL_UART_MspInit+0x1b4>)
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001678:	60a6      	str	r6, [r4, #8]
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 800167a:	f04f 6c00 	mov.w	ip, #134217728	; 0x8000000
 800167e:	e884 1008 	stmia.w	r4, {r3, ip}
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8001682:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001686:	6123      	str	r3, [r4, #16]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 8001688:	4620      	mov	r0, r4
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
 800168a:	f44f 7380 	mov.w	r3, #256	; 0x100
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 800168e:	60e6      	str	r6, [r4, #12]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001690:	6166      	str	r6, [r4, #20]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001692:	61a6      	str	r6, [r4, #24]
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
 8001694:	61e3      	str	r3, [r4, #28]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
 8001696:	6226      	str	r6, [r4, #32]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8001698:	6266      	str	r6, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 800169a:	f000 fadd 	bl	8001c58 <HAL_DMA_Init>
 800169e:	b108      	cbz	r0, 80016a4 <HAL_UART_MspInit+0x94>
    {
      Error_Handler();
 80016a0:	f7ff fa30 	bl	8000b04 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);
 80016a4:	636c      	str	r4, [r5, #52]	; 0x34

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80016a6:	4b48      	ldr	r3, [pc, #288]	; (80017c8 <HAL_UART_MspInit+0x1b8>)
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);
 80016a8:	63a5      	str	r5, [r4, #56]	; 0x38
    hdma_usart1_tx.Instance = DMA2_Stream7;
 80016aa:	4c48      	ldr	r4, [pc, #288]	; (80017cc <HAL_UART_MspInit+0x1bc>)
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80016ac:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 80016b0:	f04f 0e40 	mov.w	lr, #64	; 0x40
 80016b4:	e884 4048 	stmia.w	r4, {r3, r6, lr}
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80016b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80016bc:	2300      	movs	r3, #0
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_tx.Init.Mode = DMA_NORMAL;
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 80016be:	4620      	mov	r0, r4
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80016c0:	60e3      	str	r3, [r4, #12]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80016c2:	6122      	str	r2, [r4, #16]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80016c4:	6163      	str	r3, [r4, #20]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80016c6:	61a3      	str	r3, [r4, #24]
    hdma_usart1_tx.Init.Mode = DMA_NORMAL;
 80016c8:	61e3      	str	r3, [r4, #28]
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
 80016ca:	6223      	str	r3, [r4, #32]
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80016cc:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 80016ce:	f000 fac3 	bl	8001c58 <HAL_DMA_Init>
 80016d2:	b108      	cbz	r0, 80016d8 <HAL_UART_MspInit+0xc8>
    {
      Error_Handler();
 80016d4:	f7ff fa16 	bl	8000b04 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);
 80016d8:	632c      	str	r4, [r5, #48]	; 0x30

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 80016da:	2025      	movs	r0, #37	; 0x25
 80016dc:	2200      	movs	r2, #0
 80016de:	2105      	movs	r1, #5
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);
 80016e0:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 80016e2:	f000 fa63 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 80016e6:	2025      	movs	r0, #37	; 0x25

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 80016e8:	f000 fa94 	bl	8001c14 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 80016ec:	b00a      	add	sp, #40	; 0x28
 80016ee:	bd70      	pop	{r4, r5, r6, pc}
  else if(uartHandle->Instance==USART2)
 80016f0:	4a37      	ldr	r2, [pc, #220]	; (80017d0 <HAL_UART_MspInit+0x1c0>)
 80016f2:	4293      	cmp	r3, r2
 80016f4:	d1fa      	bne.n	80016ec <HAL_UART_MspInit+0xdc>
    __HAL_RCC_USART2_CLK_ENABLE();
 80016f6:	2600      	movs	r6, #0
 80016f8:	4b2f      	ldr	r3, [pc, #188]	; (80017b8 <HAL_UART_MspInit+0x1a8>)
 80016fa:	9603      	str	r6, [sp, #12]
 80016fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80016fe:	4835      	ldr	r0, [pc, #212]	; (80017d4 <HAL_UART_MspInit+0x1c4>)
    hdma_usart2_rx.Instance = DMA1_Stream5;
 8001700:	4c35      	ldr	r4, [pc, #212]	; (80017d8 <HAL_UART_MspInit+0x1c8>)
    __HAL_RCC_USART2_CLK_ENABLE();
 8001702:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001706:	641a      	str	r2, [r3, #64]	; 0x40
 8001708:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800170a:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800170e:	9203      	str	r2, [sp, #12]
 8001710:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8001712:	9604      	str	r6, [sp, #16]
 8001714:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001716:	f042 0208 	orr.w	r2, r2, #8
 800171a:	631a      	str	r2, [r3, #48]	; 0x30
 800171c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800171e:	f003 0308 	and.w	r3, r3, #8
 8001722:	9304      	str	r3, [sp, #16]
 8001724:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
 8001726:	2360      	movs	r3, #96	; 0x60
 8001728:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800172a:	2302      	movs	r3, #2
 800172c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800172e:	2301      	movs	r3, #1
 8001730:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001732:	2303      	movs	r3, #3
 8001734:	9308      	str	r3, [sp, #32]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001736:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8001738:	2307      	movs	r3, #7
 800173a:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800173c:	f000 fc14 	bl	8001f68 <HAL_GPIO_Init>
    hdma_usart2_rx.Init.Channel = DMA_CHANNEL_4;
 8001740:	4b26      	ldr	r3, [pc, #152]	; (80017dc <HAL_UART_MspInit+0x1cc>)
    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001742:	60a6      	str	r6, [r4, #8]
    hdma_usart2_rx.Init.Channel = DMA_CHANNEL_4;
 8001744:	f04f 6c00 	mov.w	ip, #134217728	; 0x8000000
 8001748:	e884 1008 	stmia.w	r4, {r3, ip}
    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
 800174c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001750:	6123      	str	r3, [r4, #16]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8001752:	4620      	mov	r0, r4
    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;
 8001754:	f44f 7380 	mov.w	r3, #256	; 0x100
    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001758:	60e6      	str	r6, [r4, #12]
    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800175a:	6166      	str	r6, [r4, #20]
    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800175c:	61a6      	str	r6, [r4, #24]
    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;
 800175e:	61e3      	str	r3, [r4, #28]
    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
 8001760:	6226      	str	r6, [r4, #32]
    hdma_usart2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8001762:	6266      	str	r6, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8001764:	f000 fa78 	bl	8001c58 <HAL_DMA_Init>
 8001768:	b108      	cbz	r0, 800176e <HAL_UART_MspInit+0x15e>
      Error_Handler();
 800176a:	f7ff f9cb 	bl	8000b04 <Error_Handler>
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
 800176e:	636c      	str	r4, [r5, #52]	; 0x34
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001770:	4b1b      	ldr	r3, [pc, #108]	; (80017e0 <HAL_UART_MspInit+0x1d0>)
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
 8001772:	63a5      	str	r5, [r4, #56]	; 0x38
    hdma_usart2_tx.Instance = DMA1_Stream6;
 8001774:	4c1b      	ldr	r4, [pc, #108]	; (80017e4 <HAL_UART_MspInit+0x1d4>)
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001776:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 800177a:	f04f 0e40 	mov.w	lr, #64	; 0x40
 800177e:	e884 4048 	stmia.w	r4, {r3, r6, lr}
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001782:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001786:	2300      	movs	r3, #0
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8001788:	4620      	mov	r0, r4
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800178a:	60e3      	str	r3, [r4, #12]
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 800178c:	6122      	str	r2, [r4, #16]
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800178e:	6163      	str	r3, [r4, #20]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001790:	61a3      	str	r3, [r4, #24]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 8001792:	61e3      	str	r3, [r4, #28]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 8001794:	6223      	str	r3, [r4, #32]
    hdma_usart2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8001796:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8001798:	f000 fa5e 	bl	8001c58 <HAL_DMA_Init>
 800179c:	b108      	cbz	r0, 80017a2 <HAL_UART_MspInit+0x192>
      Error_Handler();
 800179e:	f7ff f9b1 	bl	8000b04 <Error_Handler>
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 80017a2:	632c      	str	r4, [r5, #48]	; 0x30
    HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
 80017a4:	2026      	movs	r0, #38	; 0x26
 80017a6:	2200      	movs	r2, #0
 80017a8:	2105      	movs	r1, #5
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 80017aa:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
 80017ac:	f000 f9fe 	bl	8001bac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 80017b0:	2026      	movs	r0, #38	; 0x26
 80017b2:	e799      	b.n	80016e8 <HAL_UART_MspInit+0xd8>
 80017b4:	40011000 	.word	0x40011000
 80017b8:	40023800 	.word	0x40023800
 80017bc:	40020000 	.word	0x40020000
 80017c0:	20004958 	.word	0x20004958
 80017c4:	40026440 	.word	0x40026440
 80017c8:	400264b8 	.word	0x400264b8
 80017cc:	200048f8 	.word	0x200048f8
 80017d0:	40004400 	.word	0x40004400
 80017d4:	40020c00 	.word	0x40020c00
 80017d8:	20004898 	.word	0x20004898
 80017dc:	40026088 	.word	0x40026088
 80017e0:	400260a0 	.word	0x400260a0
 80017e4:	200049b8 	.word	0x200049b8

080017e8 <MX_USB_OTG_FS_PCD_Init>:
/* USB_OTG_FS init function */

void MX_USB_OTG_FS_PCD_Init(void)
{

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 80017e8:	480c      	ldr	r0, [pc, #48]	; (800181c <MX_USB_OTG_FS_PCD_Init+0x34>)
{
 80017ea:	b508      	push	{r3, lr}
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 80017ec:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 80017f0:	2304      	movs	r3, #4
 80017f2:	e880 000c 	stmia.w	r0, {r2, r3}
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 80017f6:	2300      	movs	r3, #0
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 80017f8:	2202      	movs	r2, #2
 80017fa:	60c2      	str	r2, [r0, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 80017fc:	6103      	str	r3, [r0, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 80017fe:	6143      	str	r3, [r0, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8001800:	6182      	str	r2, [r0, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8001802:	61c3      	str	r3, [r0, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8001804:	6203      	str	r3, [r0, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8001806:	6243      	str	r3, [r0, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 8001808:	62c3      	str	r3, [r0, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 800180a:	6303      	str	r3, [r0, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 800180c:	f001 f9d8 	bl	8002bc0 <HAL_PCD_Init>
 8001810:	b118      	cbz	r0, 800181a <MX_USB_OTG_FS_PCD_Init+0x32>
  {
    Error_Handler();
  }

}
 8001812:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8001816:	f7ff b975 	b.w	8000b04 <Error_Handler>
 800181a:	bd08      	pop	{r3, pc}
 800181c:	20004a98 	.word	0x20004a98

08001820 <HAL_PCD_MspInit>:

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8001820:	b530      	push	{r4, r5, lr}
 8001822:	4604      	mov	r4, r0
 8001824:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001826:	2214      	movs	r2, #20
 8001828:	2100      	movs	r1, #0
 800182a:	a803      	add	r0, sp, #12
 800182c:	f004 ff23 	bl	8006676 <memset>
  if(pcdHandle->Instance==USB_OTG_FS)
 8001830:	6823      	ldr	r3, [r4, #0]
 8001832:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8001836:	d126      	bne.n	8001886 <HAL_PCD_MspInit+0x66>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001838:	4c14      	ldr	r4, [pc, #80]	; (800188c <HAL_PCD_MspInit+0x6c>)
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800183a:	4815      	ldr	r0, [pc, #84]	; (8001890 <HAL_PCD_MspInit+0x70>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800183c:	2500      	movs	r5, #0
 800183e:	9501      	str	r5, [sp, #4]
 8001840:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001842:	f043 0301 	orr.w	r3, r3, #1
 8001846:	6323      	str	r3, [r4, #48]	; 0x30
 8001848:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800184a:	f003 0301 	and.w	r3, r3, #1
 800184e:	9301      	str	r3, [sp, #4]
 8001850:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8001852:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8001856:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001858:	2302      	movs	r3, #2
 800185a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800185c:	2303      	movs	r3, #3
 800185e:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001860:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8001862:	230a      	movs	r3, #10
 8001864:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001866:	f000 fb7f 	bl	8001f68 <HAL_GPIO_Init>

    /* USB_OTG_FS clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800186a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800186c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001870:	6363      	str	r3, [r4, #52]	; 0x34
 8001872:	9502      	str	r5, [sp, #8]
 8001874:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001876:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800187a:	6463      	str	r3, [r4, #68]	; 0x44
 800187c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800187e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001882:	9302      	str	r3, [sp, #8]
 8001884:	9b02      	ldr	r3, [sp, #8]
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8001886:	b009      	add	sp, #36	; 0x24
 8001888:	bd30      	pop	{r4, r5, pc}
 800188a:	bf00      	nop
 800188c:	40023800 	.word	0x40023800
 8001890:	40020000 	.word	0x40020000

08001894 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001894:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001896:	4b0b      	ldr	r3, [pc, #44]	; (80018c4 <HAL_Init+0x30>)
 8001898:	681a      	ldr	r2, [r3, #0]
 800189a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800189e:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 80018a0:	681a      	ldr	r2, [r3, #0]
 80018a2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80018a6:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80018a8:	681a      	ldr	r2, [r3, #0]
 80018aa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80018ae:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80018b0:	2003      	movs	r0, #3
 80018b2:	f000 f969 	bl	8001b88 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80018b6:	2000      	movs	r0, #0
 80018b8:	f7ff fa86 	bl	8000dc8 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 80018bc:	f7ff fa62 	bl	8000d84 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 80018c0:	2000      	movs	r0, #0
 80018c2:	bd08      	pop	{r3, pc}
 80018c4:	40023c00 	.word	0x40023c00

080018c8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80018c8:	4a03      	ldr	r2, [pc, #12]	; (80018d8 <HAL_IncTick+0x10>)
 80018ca:	4b04      	ldr	r3, [pc, #16]	; (80018dc <HAL_IncTick+0x14>)
 80018cc:	6811      	ldr	r1, [r2, #0]
 80018ce:	781b      	ldrb	r3, [r3, #0]
 80018d0:	440b      	add	r3, r1
 80018d2:	6013      	str	r3, [r2, #0]
 80018d4:	4770      	bx	lr
 80018d6:	bf00      	nop
 80018d8:	20004e88 	.word	0x20004e88
 80018dc:	20000004 	.word	0x20000004

080018e0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80018e0:	4b01      	ldr	r3, [pc, #4]	; (80018e8 <HAL_GetTick+0x8>)
 80018e2:	6818      	ldr	r0, [r3, #0]
}
 80018e4:	4770      	bx	lr
 80018e6:	bf00      	nop
 80018e8:	20004e88 	.word	0x20004e88

080018ec <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80018ec:	b538      	push	{r3, r4, r5, lr}
 80018ee:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80018f0:	f7ff fff6 	bl	80018e0 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80018f4:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 80018f6:	bf1c      	itt	ne
 80018f8:	4b05      	ldrne	r3, [pc, #20]	; (8001910 <HAL_Delay+0x24>)
 80018fa:	781b      	ldrbne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 80018fc:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 80018fe:	bf18      	it	ne
 8001900:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001902:	f7ff ffed 	bl	80018e0 <HAL_GetTick>
 8001906:	1b40      	subs	r0, r0, r5
 8001908:	4284      	cmp	r4, r0
 800190a:	d8fa      	bhi.n	8001902 <HAL_Delay+0x16>
  {
  }
}
 800190c:	bd38      	pop	{r3, r4, r5, pc}
 800190e:	bf00      	nop
 8001910:	20000004 	.word	0x20000004

08001914 <HAL_ADC_Init>:
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8001914:	b510      	push	{r4, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
 8001916:	4604      	mov	r4, r0
 8001918:	2800      	cmp	r0, #0
 800191a:	f000 8099 	beq.w	8001a50 <HAL_ADC_Init+0x13c>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }
  
  if(hadc->State == HAL_ADC_STATE_RESET)
 800191e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001920:	b923      	cbnz	r3, 800192c <HAL_ADC_Init+0x18>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 8001922:	6443      	str	r3, [r0, #68]	; 0x44
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8001924:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001928:	f7fe fe36 	bl	8000598 <HAL_ADC_MspInit>
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 800192c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800192e:	06db      	lsls	r3, r3, #27
 8001930:	f100 808c 	bmi.w	8001a4c <HAL_ADC_Init+0x138>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8001934:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001936:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 800193a:	f023 0302 	bic.w	r3, r3, #2
 800193e:	f043 0302 	orr.w	r3, r3, #2
 8001942:	6423      	str	r3, [r4, #64]	; 0x40
  /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
  /* control register)                                                    */
  tmpADC_Common = ADC_COMMON_REGISTER(hadc);
  
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 8001944:	4b43      	ldr	r3, [pc, #268]	; (8001a54 <HAL_ADC_Init+0x140>)
 8001946:	685a      	ldr	r2, [r3, #4]
 8001948:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800194c:	605a      	str	r2, [r3, #4]
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
 800194e:	685a      	ldr	r2, [r3, #4]
 8001950:	6861      	ldr	r1, [r4, #4]
 8001952:	430a      	orrs	r2, r1
 8001954:	605a      	str	r2, [r3, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8001956:	6823      	ldr	r3, [r4, #0]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8001958:	6921      	ldr	r1, [r4, #16]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800195a:	685a      	ldr	r2, [r3, #4]
 800195c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001960:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8001962:	685a      	ldr	r2, [r3, #4]
 8001964:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001968:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 800196a:	685a      	ldr	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 800196c:	68a1      	ldr	r1, [r4, #8]
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 800196e:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001972:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8001974:	685a      	ldr	r2, [r3, #4]
 8001976:	430a      	orrs	r2, r1
 8001978:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 800197a:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 800197c:	68e1      	ldr	r1, [r4, #12]
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 800197e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001982:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8001984:	689a      	ldr	r2, [r3, #8]
 8001986:	430a      	orrs	r2, r1
 8001988:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800198a:	4933      	ldr	r1, [pc, #204]	; (8001a58 <HAL_ADC_Init+0x144>)
 800198c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800198e:	428a      	cmp	r2, r1
 8001990:	d050      	beq.n	8001a34 <HAL_ADC_Init+0x120>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8001992:	6899      	ldr	r1, [r3, #8]
 8001994:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 8001998:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 800199a:	6899      	ldr	r1, [r3, #8]
 800199c:	430a      	orrs	r2, r1
 800199e:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80019a0:	689a      	ldr	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80019a2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80019a4:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80019a8:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80019aa:	689a      	ldr	r2, [r3, #8]
 80019ac:	430a      	orrs	r2, r1
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80019ae:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 80019b0:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 80019b2:	69a1      	ldr	r1, [r4, #24]
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 80019b4:	f022 0202 	bic.w	r2, r2, #2
 80019b8:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 80019ba:	689a      	ldr	r2, [r3, #8]
 80019bc:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
 80019c0:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 80019c2:	6a22      	ldr	r2, [r4, #32]
 80019c4:	2a00      	cmp	r2, #0
 80019c6:	d03d      	beq.n	8001a44 <HAL_ADC_Init+0x130>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80019c8:	685a      	ldr	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80019ca:	6a61      	ldr	r1, [r4, #36]	; 0x24
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80019cc:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80019d0:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 80019d2:	685a      	ldr	r2, [r3, #4]
 80019d4:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 80019d8:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80019da:	685a      	ldr	r2, [r3, #4]
 80019dc:	3901      	subs	r1, #1
 80019de:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 80019e2:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80019e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80019e6:	69e1      	ldr	r1, [r4, #28]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80019e8:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 80019ec:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80019ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80019f0:	3901      	subs	r1, #1
 80019f2:	ea42 5201 	orr.w	r2, r2, r1, lsl #20
 80019f6:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80019f8:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 80019fa:	6b21      	ldr	r1, [r4, #48]	; 0x30
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80019fc:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001a00:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 8001a02:	689a      	ldr	r2, [r3, #8]
 8001a04:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
 8001a08:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8001a0a:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8001a0c:	6961      	ldr	r1, [r4, #20]
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8001a0e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001a12:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8001a14:	689a      	ldr	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 8001a16:	2000      	movs	r0, #0
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8001a18:	ea42 2281 	orr.w	r2, r2, r1, lsl #10
 8001a1c:	609a      	str	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 8001a1e:	6460      	str	r0, [r4, #68]	; 0x44
    ADC_STATE_CLR_SET(hadc->State,
 8001a20:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001a22:	f023 0303 	bic.w	r3, r3, #3
 8001a26:	f043 0301 	orr.w	r3, r3, #1
 8001a2a:	6423      	str	r3, [r4, #64]	; 0x40
  __HAL_UNLOCK(hadc);
 8001a2c:	2300      	movs	r3, #0
 8001a2e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  return tmp_hal_status;
 8001a32:	bd10      	pop	{r4, pc}
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8001a34:	689a      	ldr	r2, [r3, #8]
 8001a36:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8001a3a:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8001a3c:	689a      	ldr	r2, [r3, #8]
 8001a3e:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8001a42:	e7b4      	b.n	80019ae <HAL_ADC_Init+0x9a>
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8001a44:	685a      	ldr	r2, [r3, #4]
 8001a46:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001a4a:	e7ca      	b.n	80019e2 <HAL_ADC_Init+0xce>
    tmp_hal_status = HAL_ERROR;
 8001a4c:	2001      	movs	r0, #1
 8001a4e:	e7ed      	b.n	8001a2c <HAL_ADC_Init+0x118>
    return HAL_ERROR;
 8001a50:	2001      	movs	r0, #1
}
 8001a52:	bd10      	pop	{r4, pc}
 8001a54:	40012300 	.word	0x40012300
 8001a58:	0f000001 	.word	0x0f000001

08001a5c <HAL_ADC_ConfigChannel>:
{
 8001a5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t counter = 0U;
 8001a5e:	2300      	movs	r3, #0
 8001a60:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 8001a62:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8001a66:	2b01      	cmp	r3, #1
 8001a68:	f000 8083 	beq.w	8001b72 <HAL_ADC_ConfigChannel+0x116>
  if (sConfig->Channel > ADC_CHANNEL_9)
 8001a6c:	680d      	ldr	r5, [r1, #0]
 8001a6e:	6804      	ldr	r4, [r0, #0]
 8001a70:	688a      	ldr	r2, [r1, #8]
  __HAL_LOCK(hadc);
 8001a72:	2301      	movs	r3, #1
  if (sConfig->Channel > ADC_CHANNEL_9)
 8001a74:	2d09      	cmp	r5, #9
  __HAL_LOCK(hadc);
 8001a76:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
 8001a7a:	b2ae      	uxth	r6, r5
  if (sConfig->Channel > ADC_CHANNEL_9)
 8001a7c:	d92a      	bls.n	8001ad4 <HAL_ADC_ConfigChannel+0x78>
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8001a7e:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 8001a82:	68e7      	ldr	r7, [r4, #12]
 8001a84:	3b1e      	subs	r3, #30
 8001a86:	f04f 0e07 	mov.w	lr, #7
 8001a8a:	fa0e fe03 	lsl.w	lr, lr, r3
 8001a8e:	ea27 070e 	bic.w	r7, r7, lr
 8001a92:	60e7      	str	r7, [r4, #12]
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8001a94:	68e7      	ldr	r7, [r4, #12]
 8001a96:	fa02 f303 	lsl.w	r3, r2, r3
 8001a9a:	433b      	orrs	r3, r7
 8001a9c:	60e3      	str	r3, [r4, #12]
  if (sConfig->Rank < 7U)
 8001a9e:	684a      	ldr	r2, [r1, #4]
 8001aa0:	2a06      	cmp	r2, #6
 8001aa2:	ea4f 0382 	mov.w	r3, r2, lsl #2
 8001aa6:	d825      	bhi.n	8001af4 <HAL_ADC_ConfigChannel+0x98>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8001aa8:	4413      	add	r3, r2
 8001aaa:	6b67      	ldr	r7, [r4, #52]	; 0x34
 8001aac:	1f59      	subs	r1, r3, #5
 8001aae:	231f      	movs	r3, #31
 8001ab0:	408b      	lsls	r3, r1
 8001ab2:	ea27 0303 	bic.w	r3, r7, r3
 8001ab6:	6363      	str	r3, [r4, #52]	; 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8001ab8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001aba:	fa06 f101 	lsl.w	r1, r6, r1
 8001abe:	4311      	orrs	r1, r2
 8001ac0:	6361      	str	r1, [r4, #52]	; 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8001ac2:	4b2d      	ldr	r3, [pc, #180]	; (8001b78 <HAL_ADC_ConfigChannel+0x11c>)
 8001ac4:	429c      	cmp	r4, r3
 8001ac6:	d034      	beq.n	8001b32 <HAL_ADC_ConfigChannel+0xd6>
  __HAL_UNLOCK(hadc);
 8001ac8:	2300      	movs	r3, #0
 8001aca:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8001ace:	4618      	mov	r0, r3
}
 8001ad0:	b003      	add	sp, #12
 8001ad2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8001ad4:	6927      	ldr	r7, [r4, #16]
 8001ad6:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8001ada:	f04f 0e07 	mov.w	lr, #7
 8001ade:	fa0e fe03 	lsl.w	lr, lr, r3
 8001ae2:	ea27 070e 	bic.w	r7, r7, lr
 8001ae6:	6127      	str	r7, [r4, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8001ae8:	6927      	ldr	r7, [r4, #16]
 8001aea:	fa02 f303 	lsl.w	r3, r2, r3
 8001aee:	433b      	orrs	r3, r7
 8001af0:	6123      	str	r3, [r4, #16]
 8001af2:	e7d4      	b.n	8001a9e <HAL_ADC_ConfigChannel+0x42>
  else if (sConfig->Rank < 13U)
 8001af4:	2a0c      	cmp	r2, #12
 8001af6:	d80e      	bhi.n	8001b16 <HAL_ADC_ConfigChannel+0xba>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8001af8:	4413      	add	r3, r2
 8001afa:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001afc:	f1a3 0223 	sub.w	r2, r3, #35	; 0x23
 8001b00:	231f      	movs	r3, #31
 8001b02:	4093      	lsls	r3, r2
 8001b04:	ea21 0303 	bic.w	r3, r1, r3
 8001b08:	6323      	str	r3, [r4, #48]	; 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8001b0a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001b0c:	fa06 f202 	lsl.w	r2, r6, r2
 8001b10:	431a      	orrs	r2, r3
 8001b12:	6322      	str	r2, [r4, #48]	; 0x30
 8001b14:	e7d5      	b.n	8001ac2 <HAL_ADC_ConfigChannel+0x66>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8001b16:	4413      	add	r3, r2
 8001b18:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001b1a:	3b41      	subs	r3, #65	; 0x41
 8001b1c:	221f      	movs	r2, #31
 8001b1e:	409a      	lsls	r2, r3
 8001b20:	ea21 0202 	bic.w	r2, r1, r2
 8001b24:	62e2      	str	r2, [r4, #44]	; 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8001b26:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001b28:	fa06 f103 	lsl.w	r1, r6, r3
 8001b2c:	4311      	orrs	r1, r2
 8001b2e:	62e1      	str	r1, [r4, #44]	; 0x2c
 8001b30:	e7c7      	b.n	8001ac2 <HAL_ADC_ConfigChannel+0x66>
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8001b32:	2d12      	cmp	r5, #18
 8001b34:	d104      	bne.n	8001b40 <HAL_ADC_ConfigChannel+0xe4>
    tmpADC_Common->CCR |= ADC_CCR_VBATE;
 8001b36:	4a11      	ldr	r2, [pc, #68]	; (8001b7c <HAL_ADC_ConfigChannel+0x120>)
 8001b38:	6853      	ldr	r3, [r2, #4]
 8001b3a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001b3e:	6053      	str	r3, [r2, #4]
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8001b40:	f1a5 0310 	sub.w	r3, r5, #16
 8001b44:	2b01      	cmp	r3, #1
 8001b46:	d8bf      	bhi.n	8001ac8 <HAL_ADC_ConfigChannel+0x6c>
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 8001b48:	4a0c      	ldr	r2, [pc, #48]	; (8001b7c <HAL_ADC_ConfigChannel+0x120>)
 8001b4a:	6853      	ldr	r3, [r2, #4]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8001b4c:	2d10      	cmp	r5, #16
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 8001b4e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8001b52:	6053      	str	r3, [r2, #4]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8001b54:	d1b8      	bne.n	8001ac8 <HAL_ADC_ConfigChannel+0x6c>
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8001b56:	4b0a      	ldr	r3, [pc, #40]	; (8001b80 <HAL_ADC_ConfigChannel+0x124>)
 8001b58:	4a0a      	ldr	r2, [pc, #40]	; (8001b84 <HAL_ADC_ConfigChannel+0x128>)
 8001b5a:	681b      	ldr	r3, [r3, #0]
 8001b5c:	fbb3 f2f2 	udiv	r2, r3, r2
 8001b60:	230a      	movs	r3, #10
 8001b62:	4353      	muls	r3, r2
        counter--;
 8001b64:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 8001b66:	9b01      	ldr	r3, [sp, #4]
 8001b68:	2b00      	cmp	r3, #0
 8001b6a:	d0ad      	beq.n	8001ac8 <HAL_ADC_ConfigChannel+0x6c>
        counter--;
 8001b6c:	9b01      	ldr	r3, [sp, #4]
 8001b6e:	3b01      	subs	r3, #1
 8001b70:	e7f8      	b.n	8001b64 <HAL_ADC_ConfigChannel+0x108>
  __HAL_LOCK(hadc);
 8001b72:	2002      	movs	r0, #2
 8001b74:	e7ac      	b.n	8001ad0 <HAL_ADC_ConfigChannel+0x74>
 8001b76:	bf00      	nop
 8001b78:	40012000 	.word	0x40012000
 8001b7c:	40012300 	.word	0x40012300
 8001b80:	20000000 	.word	0x20000000
 8001b84:	000f4240 	.word	0x000f4240

08001b88 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001b88:	4a07      	ldr	r2, [pc, #28]	; (8001ba8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001b8a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001b8c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001b90:	041b      	lsls	r3, r3, #16
 8001b92:	0c1b      	lsrs	r3, r3, #16
 8001b94:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8001b98:	0200      	lsls	r0, r0, #8
 8001b9a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001b9e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8001ba2:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8001ba4:	60d3      	str	r3, [r2, #12]
 8001ba6:	4770      	bx	lr
 8001ba8:	e000ed00 	.word	0xe000ed00

08001bac <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001bac:	4b17      	ldr	r3, [pc, #92]	; (8001c0c <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001bae:	b530      	push	{r4, r5, lr}
 8001bb0:	68dc      	ldr	r4, [r3, #12]
 8001bb2:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001bb6:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001bba:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001bbc:	2b04      	cmp	r3, #4
 8001bbe:	bf28      	it	cs
 8001bc0:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001bc2:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001bc4:	f04f 0501 	mov.w	r5, #1
 8001bc8:	fa05 f303 	lsl.w	r3, r5, r3
 8001bcc:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001bd0:	bf8c      	ite	hi
 8001bd2:	3c03      	subhi	r4, #3
 8001bd4:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001bd6:	4019      	ands	r1, r3
 8001bd8:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001bda:	fa05 f404 	lsl.w	r4, r5, r4
 8001bde:	3c01      	subs	r4, #1
 8001be0:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 8001be2:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001be4:	ea42 0201 	orr.w	r2, r2, r1
 8001be8:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001bec:	bfaf      	iteee	ge
 8001bee:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001bf2:	f000 000f 	andlt.w	r0, r0, #15
 8001bf6:	4b06      	ldrlt	r3, [pc, #24]	; (8001c10 <HAL_NVIC_SetPriority+0x64>)
 8001bf8:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001bfa:	bfa5      	ittet	ge
 8001bfc:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8001c00:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001c02:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001c04:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8001c08:	bd30      	pop	{r4, r5, pc}
 8001c0a:	bf00      	nop
 8001c0c:	e000ed00 	.word	0xe000ed00
 8001c10:	e000ed14 	.word	0xe000ed14

08001c14 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8001c14:	0942      	lsrs	r2, r0, #5
 8001c16:	2301      	movs	r3, #1
 8001c18:	f000 001f 	and.w	r0, r0, #31
 8001c1c:	fa03 f000 	lsl.w	r0, r3, r0
 8001c20:	4b01      	ldr	r3, [pc, #4]	; (8001c28 <HAL_NVIC_EnableIRQ+0x14>)
 8001c22:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8001c26:	4770      	bx	lr
 8001c28:	e000e100 	.word	0xe000e100

08001c2c <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001c2c:	6803      	ldr	r3, [r0, #0]
 8001c2e:	b2da      	uxtb	r2, r3
 8001c30:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8001c34:	f023 0303 	bic.w	r3, r3, #3
 8001c38:	2118      	movs	r1, #24
 8001c3a:	3a10      	subs	r2, #16
 8001c3c:	fbb2 f2f1 	udiv	r2, r2, r1
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001c40:	4904      	ldr	r1, [pc, #16]	; (8001c54 <DMA_CalcBaseAndBitshift+0x28>)
  
  if (stream_number > 3U)
 8001c42:	2a03      	cmp	r2, #3
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001c44:	bf88      	it	hi
 8001c46:	3304      	addhi	r3, #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001c48:	5c89      	ldrb	r1, [r1, r2]
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 8001c4a:	6583      	str	r3, [r0, #88]	; 0x58
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001c4c:	65c1      	str	r1, [r0, #92]	; 0x5c
  }
  
  return hdma->StreamBaseAddress;
}
 8001c4e:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8001c50:	4770      	bx	lr
 8001c52:	bf00      	nop
 8001c54:	080066e6 	.word	0x080066e6

08001c58 <HAL_DMA_Init>:
{
 8001c58:	b570      	push	{r4, r5, r6, lr}
 8001c5a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001c5c:	f7ff fe40 	bl	80018e0 <HAL_GetTick>
 8001c60:	4605      	mov	r5, r0
  if(hdma == NULL)
 8001c62:	2c00      	cmp	r4, #0
 8001c64:	d071      	beq.n	8001d4a <HAL_DMA_Init+0xf2>
  __HAL_UNLOCK(hdma);
 8001c66:	2300      	movs	r3, #0
 8001c68:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 8001c6c:	6822      	ldr	r2, [r4, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 8001c6e:	2302      	movs	r3, #2
 8001c70:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8001c74:	6813      	ldr	r3, [r2, #0]
 8001c76:	f023 0301 	bic.w	r3, r3, #1
 8001c7a:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8001c7c:	6821      	ldr	r1, [r4, #0]
 8001c7e:	680b      	ldr	r3, [r1, #0]
 8001c80:	07d8      	lsls	r0, r3, #31
 8001c82:	d43c      	bmi.n	8001cfe <HAL_DMA_Init+0xa6>
  tmp = hdma->Instance->CR;
 8001c84:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001c86:	4d32      	ldr	r5, [pc, #200]	; (8001d50 <HAL_DMA_Init+0xf8>)
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001c88:	6862      	ldr	r2, [r4, #4]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001c8a:	69a0      	ldr	r0, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001c8c:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001c8e:	68a3      	ldr	r3, [r4, #8]
 8001c90:	4313      	orrs	r3, r2
 8001c92:	68e2      	ldr	r2, [r4, #12]
 8001c94:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001c96:	6922      	ldr	r2, [r4, #16]
 8001c98:	4313      	orrs	r3, r2
 8001c9a:	6962      	ldr	r2, [r4, #20]
 8001c9c:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001c9e:	69e2      	ldr	r2, [r4, #28]
 8001ca0:	4303      	orrs	r3, r0
 8001ca2:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
 8001ca4:	6a22      	ldr	r2, [r4, #32]
 8001ca6:	4313      	orrs	r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001ca8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001caa:	2a04      	cmp	r2, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001cac:	ea43 0305 	orr.w	r3, r3, r5
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8001cb0:	bf01      	itttt	eq
 8001cb2:	6b26      	ldreq	r6, [r4, #48]	; 0x30
 8001cb4:	6ae5      	ldreq	r5, [r4, #44]	; 0x2c
 8001cb6:	4335      	orreq	r5, r6
 8001cb8:	432b      	orreq	r3, r5
  hdma->Instance->CR = tmp;  
 8001cba:	600b      	str	r3, [r1, #0]
  tmp = hdma->Instance->FCR;
 8001cbc:	694b      	ldr	r3, [r1, #20]
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001cbe:	2a04      	cmp	r2, #4
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001cc0:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
 8001cc4:	ea43 0302 	orr.w	r3, r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001cc8:	d10b      	bne.n	8001ce2 <HAL_DMA_Init+0x8a>
    tmp |= hdma->Init.FIFOThreshold;
 8001cca:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001ccc:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 8001cce:	4313      	orrs	r3, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001cd0:	b13d      	cbz	r5, 8001ce2 <HAL_DMA_Init+0x8a>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8001cd2:	b9f8      	cbnz	r0, 8001d14 <HAL_DMA_Init+0xbc>
  {
    switch (tmp)
 8001cd4:	2a01      	cmp	r2, #1
 8001cd6:	d02d      	beq.n	8001d34 <HAL_DMA_Init+0xdc>
 8001cd8:	d301      	bcc.n	8001cde <HAL_DMA_Init+0x86>
 8001cda:	2a02      	cmp	r2, #2
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8001cdc:	d101      	bne.n	8001ce2 <HAL_DMA_Init+0x8a>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8001cde:	01ea      	lsls	r2, r5, #7
 8001ce0:	d42b      	bmi.n	8001d3a <HAL_DMA_Init+0xe2>
  hdma->Instance->FCR = tmp;
 8001ce2:	614b      	str	r3, [r1, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8001ce4:	4620      	mov	r0, r4
 8001ce6:	f7ff ffa1 	bl	8001c2c <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001cea:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8001cec:	233f      	movs	r3, #63	; 0x3f
 8001cee:	4093      	lsls	r3, r2
 8001cf0:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001cf2:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8001cf4:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001cf6:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8001cf8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8001cfc:	bd70      	pop	{r4, r5, r6, pc}
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8001cfe:	f7ff fdef 	bl	80018e0 <HAL_GetTick>
 8001d02:	1b40      	subs	r0, r0, r5
 8001d04:	2805      	cmp	r0, #5
 8001d06:	d9b9      	bls.n	8001c7c <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8001d08:	2320      	movs	r3, #32
 8001d0a:	6563      	str	r3, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001d0c:	2003      	movs	r0, #3
        hdma->State = HAL_DMA_STATE_READY;
 8001d0e:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 8001d12:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8001d14:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8001d18:	d113      	bne.n	8001d42 <HAL_DMA_Init+0xea>
    switch (tmp)
 8001d1a:	2a03      	cmp	r2, #3
 8001d1c:	d8e1      	bhi.n	8001ce2 <HAL_DMA_Init+0x8a>
 8001d1e:	a001      	add	r0, pc, #4	; (adr r0, 8001d24 <HAL_DMA_Init+0xcc>)
 8001d20:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8001d24:	08001d3b 	.word	0x08001d3b
 8001d28:	08001cdf 	.word	0x08001cdf
 8001d2c:	08001d3b 	.word	0x08001d3b
 8001d30:	08001d35 	.word	0x08001d35
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8001d34:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 8001d38:	d1d3      	bne.n	8001ce2 <HAL_DMA_Init+0x8a>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001d3a:	2340      	movs	r3, #64	; 0x40
 8001d3c:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8001d3e:	2001      	movs	r0, #1
 8001d40:	e7e5      	b.n	8001d0e <HAL_DMA_Init+0xb6>
    switch (tmp)
 8001d42:	2a02      	cmp	r2, #2
 8001d44:	d9f9      	bls.n	8001d3a <HAL_DMA_Init+0xe2>
 8001d46:	2a03      	cmp	r2, #3
 8001d48:	e7c8      	b.n	8001cdc <HAL_DMA_Init+0x84>
    return HAL_ERROR;
 8001d4a:	2001      	movs	r0, #1
 8001d4c:	bd70      	pop	{r4, r5, r6, pc}
 8001d4e:	bf00      	nop
 8001d50:	f010803f 	.word	0xf010803f

08001d54 <HAL_DMA_Start_IT>:
{
 8001d54:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 8001d56:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 8001d5a:	2c01      	cmp	r4, #1
 8001d5c:	d036      	beq.n	8001dcc <HAL_DMA_Start_IT+0x78>
 8001d5e:	2401      	movs	r4, #1
 8001d60:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8001d64:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001d68:	6d86      	ldr	r6, [r0, #88]	; 0x58
  if(HAL_DMA_STATE_READY == hdma->State)
 8001d6a:	2c01      	cmp	r4, #1
 8001d6c:	f04f 0500 	mov.w	r5, #0
 8001d70:	f04f 0402 	mov.w	r4, #2
 8001d74:	d128      	bne.n	8001dc8 <HAL_DMA_Start_IT+0x74>
    hdma->State = HAL_DMA_STATE_BUSY;
 8001d76:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001d7a:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001d7c:	6545      	str	r5, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8001d7e:	6825      	ldr	r5, [r4, #0]
 8001d80:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 8001d84:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8001d86:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001d88:	6883      	ldr	r3, [r0, #8]
 8001d8a:	2b40      	cmp	r3, #64	; 0x40
    hdma->Instance->PAR = DstAddress;
 8001d8c:	bf0e      	itee	eq
 8001d8e:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 8001d90:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 8001d92:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001d94:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
    hdma->Instance->M0AR = SrcAddress;
 8001d96:	bf08      	it	eq
 8001d98:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001d9a:	233f      	movs	r3, #63	; 0x3f
 8001d9c:	4093      	lsls	r3, r2
 8001d9e:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8001da0:	6823      	ldr	r3, [r4, #0]
 8001da2:	f043 0316 	orr.w	r3, r3, #22
 8001da6:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8001da8:	6963      	ldr	r3, [r4, #20]
 8001daa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001dae:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 8001db0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001db2:	b11b      	cbz	r3, 8001dbc <HAL_DMA_Start_IT+0x68>
      hdma->Instance->CR  |= DMA_IT_HT;
 8001db4:	6823      	ldr	r3, [r4, #0]
 8001db6:	f043 0308 	orr.w	r3, r3, #8
 8001dba:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 8001dbc:	6823      	ldr	r3, [r4, #0]
 8001dbe:	f043 0301 	orr.w	r3, r3, #1
 8001dc2:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8001dc4:	2000      	movs	r0, #0
 8001dc6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_UNLOCK(hdma);	  
 8001dc8:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  __HAL_LOCK(hdma);
 8001dcc:	2002      	movs	r0, #2
}
 8001dce:	bd70      	pop	{r4, r5, r6, pc}

08001dd0 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8001dd0:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8001dd4:	2b02      	cmp	r3, #2
 8001dd6:	d003      	beq.n	8001de0 <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001dd8:	2380      	movs	r3, #128	; 0x80
 8001dda:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8001ddc:	2001      	movs	r0, #1
 8001dde:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 8001de0:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8001de2:	2305      	movs	r3, #5
 8001de4:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8001de8:	6813      	ldr	r3, [r2, #0]
 8001dea:	f023 0301 	bic.w	r3, r3, #1
 8001dee:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8001df0:	2000      	movs	r0, #0
}
 8001df2:	4770      	bx	lr

08001df4 <HAL_DMA_IRQHandler>:
{
 8001df4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t count = 0U;
 8001df6:	2300      	movs	r3, #0
 8001df8:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 8001dfa:	4b5a      	ldr	r3, [pc, #360]	; (8001f64 <HAL_DMA_IRQHandler+0x170>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001dfc:	6d85      	ldr	r5, [r0, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600U;
 8001dfe:	681f      	ldr	r7, [r3, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001e00:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  tmpisr = regs->ISR;
 8001e02:	682e      	ldr	r6, [r5, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001e04:	2208      	movs	r2, #8
 8001e06:	409a      	lsls	r2, r3
 8001e08:	4216      	tst	r6, r2
{
 8001e0a:	4604      	mov	r4, r0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8001e0c:	d00c      	beq.n	8001e28 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001e0e:	6801      	ldr	r1, [r0, #0]
 8001e10:	6808      	ldr	r0, [r1, #0]
 8001e12:	0740      	lsls	r0, r0, #29
 8001e14:	d508      	bpl.n	8001e28 <HAL_DMA_IRQHandler+0x34>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8001e16:	6808      	ldr	r0, [r1, #0]
 8001e18:	f020 0004 	bic.w	r0, r0, #4
 8001e1c:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8001e1e:	60aa      	str	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8001e20:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001e22:	f042 0201 	orr.w	r2, r2, #1
 8001e26:	6562      	str	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8001e28:	2201      	movs	r2, #1
 8001e2a:	409a      	lsls	r2, r3
 8001e2c:	4216      	tst	r6, r2
 8001e2e:	d008      	beq.n	8001e42 <HAL_DMA_IRQHandler+0x4e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8001e30:	6821      	ldr	r1, [r4, #0]
 8001e32:	6949      	ldr	r1, [r1, #20]
 8001e34:	0609      	lsls	r1, r1, #24
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8001e36:	bf41      	itttt	mi
 8001e38:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8001e3a:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8001e3c:	f042 0202 	orrmi.w	r2, r2, #2
 8001e40:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8001e42:	2204      	movs	r2, #4
 8001e44:	409a      	lsls	r2, r3
 8001e46:	4216      	tst	r6, r2
 8001e48:	d008      	beq.n	8001e5c <HAL_DMA_IRQHandler+0x68>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8001e4a:	6821      	ldr	r1, [r4, #0]
 8001e4c:	6809      	ldr	r1, [r1, #0]
 8001e4e:	0788      	lsls	r0, r1, #30
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8001e50:	bf41      	itttt	mi
 8001e52:	60aa      	strmi	r2, [r5, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8001e54:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8001e56:	f042 0204 	orrmi.w	r2, r2, #4
 8001e5a:	6562      	strmi	r2, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8001e5c:	2210      	movs	r2, #16
 8001e5e:	409a      	lsls	r2, r3
 8001e60:	4216      	tst	r6, r2
 8001e62:	d010      	beq.n	8001e86 <HAL_DMA_IRQHandler+0x92>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8001e64:	6823      	ldr	r3, [r4, #0]
 8001e66:	6819      	ldr	r1, [r3, #0]
 8001e68:	0709      	lsls	r1, r1, #28
 8001e6a:	d50c      	bpl.n	8001e86 <HAL_DMA_IRQHandler+0x92>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8001e6c:	60aa      	str	r2, [r5, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8001e6e:	681a      	ldr	r2, [r3, #0]
 8001e70:	0350      	lsls	r0, r2, #13
 8001e72:	d535      	bpl.n	8001ee0 <HAL_DMA_IRQHandler+0xec>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001e74:	681b      	ldr	r3, [r3, #0]
 8001e76:	0319      	lsls	r1, r3, #12
 8001e78:	d401      	bmi.n	8001e7e <HAL_DMA_IRQHandler+0x8a>
        if(hdma->XferHalfCpltCallback != NULL)
 8001e7a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001e7c:	e000      	b.n	8001e80 <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8001e7e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
        if(hdma->XferHalfCpltCallback != NULL)
 8001e80:	b10b      	cbz	r3, 8001e86 <HAL_DMA_IRQHandler+0x92>
          hdma->XferHalfCpltCallback(hdma);
 8001e82:	4620      	mov	r0, r4
 8001e84:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8001e86:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8001e88:	2220      	movs	r2, #32
 8001e8a:	408a      	lsls	r2, r1
 8001e8c:	4216      	tst	r6, r2
 8001e8e:	d038      	beq.n	8001f02 <HAL_DMA_IRQHandler+0x10e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8001e90:	6823      	ldr	r3, [r4, #0]
 8001e92:	6818      	ldr	r0, [r3, #0]
 8001e94:	06c6      	lsls	r6, r0, #27
 8001e96:	d534      	bpl.n	8001f02 <HAL_DMA_IRQHandler+0x10e>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8001e98:	60aa      	str	r2, [r5, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8001e9a:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8001e9e:	2a05      	cmp	r2, #5
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8001ea0:	681a      	ldr	r2, [r3, #0]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8001ea2:	d125      	bne.n	8001ef0 <HAL_DMA_IRQHandler+0xfc>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8001ea4:	f022 0216 	bic.w	r2, r2, #22
 8001ea8:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8001eaa:	695a      	ldr	r2, [r3, #20]
 8001eac:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001eb0:	615a      	str	r2, [r3, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8001eb2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001eb4:	b90a      	cbnz	r2, 8001eba <HAL_DMA_IRQHandler+0xc6>
 8001eb6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001eb8:	b11a      	cbz	r2, 8001ec2 <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8001eba:	681a      	ldr	r2, [r3, #0]
 8001ebc:	f022 0208 	bic.w	r2, r2, #8
 8001ec0:	601a      	str	r2, [r3, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001ec2:	233f      	movs	r3, #63	; 0x3f
 8001ec4:	408b      	lsls	r3, r1
 8001ec6:	60ab      	str	r3, [r5, #8]
        __HAL_UNLOCK(hdma);
 8001ec8:	2300      	movs	r3, #0
 8001eca:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8001ece:	2301      	movs	r3, #1
 8001ed0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 8001ed4:	6d23      	ldr	r3, [r4, #80]	; 0x50
    if(hdma->XferErrorCallback != NULL)
 8001ed6:	b10b      	cbz	r3, 8001edc <HAL_DMA_IRQHandler+0xe8>
      hdma->XferErrorCallback(hdma);
 8001ed8:	4620      	mov	r0, r4
 8001eda:	4798      	blx	r3
}
 8001edc:	b003      	add	sp, #12
 8001ede:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001ee0:	681a      	ldr	r2, [r3, #0]
 8001ee2:	05d2      	lsls	r2, r2, #23
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8001ee4:	bf5e      	ittt	pl
 8001ee6:	681a      	ldrpl	r2, [r3, #0]
 8001ee8:	f022 0208 	bicpl.w	r2, r2, #8
 8001eec:	601a      	strpl	r2, [r3, #0]
 8001eee:	e7c4      	b.n	8001e7a <HAL_DMA_IRQHandler+0x86>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8001ef0:	0350      	lsls	r0, r2, #13
 8001ef2:	d528      	bpl.n	8001f46 <HAL_DMA_IRQHandler+0x152>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8001ef4:	681b      	ldr	r3, [r3, #0]
 8001ef6:	0319      	lsls	r1, r3, #12
 8001ef8:	d432      	bmi.n	8001f60 <HAL_DMA_IRQHandler+0x16c>
          if(hdma->XferM1CpltCallback != NULL)
 8001efa:	6c63      	ldr	r3, [r4, #68]	; 0x44
        if(hdma->XferCpltCallback != NULL)
 8001efc:	b10b      	cbz	r3, 8001f02 <HAL_DMA_IRQHandler+0x10e>
          hdma->XferCpltCallback(hdma);
 8001efe:	4620      	mov	r0, r4
 8001f00:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8001f02:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001f04:	2b00      	cmp	r3, #0
 8001f06:	d0e9      	beq.n	8001edc <HAL_DMA_IRQHandler+0xe8>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8001f08:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001f0a:	07da      	lsls	r2, r3, #31
 8001f0c:	d519      	bpl.n	8001f42 <HAL_DMA_IRQHandler+0x14e>
      hdma->State = HAL_DMA_STATE_ABORT;
 8001f0e:	2305      	movs	r3, #5
      __HAL_DMA_DISABLE(hdma);
 8001f10:	6822      	ldr	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_ABORT;
 8001f12:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8001f16:	6813      	ldr	r3, [r2, #0]
 8001f18:	f023 0301 	bic.w	r3, r3, #1
 8001f1c:	6013      	str	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 8001f1e:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8001f22:	fbb7 f7f3 	udiv	r7, r7, r3
        if (++count > timeout)
 8001f26:	9b01      	ldr	r3, [sp, #4]
 8001f28:	3301      	adds	r3, #1
 8001f2a:	429f      	cmp	r7, r3
 8001f2c:	9301      	str	r3, [sp, #4]
 8001f2e:	d302      	bcc.n	8001f36 <HAL_DMA_IRQHandler+0x142>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8001f30:	6813      	ldr	r3, [r2, #0]
 8001f32:	07db      	lsls	r3, r3, #31
 8001f34:	d4f7      	bmi.n	8001f26 <HAL_DMA_IRQHandler+0x132>
      __HAL_UNLOCK(hdma);
 8001f36:	2300      	movs	r3, #0
 8001f38:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8001f3c:	2301      	movs	r3, #1
 8001f3e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 8001f42:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001f44:	e7c7      	b.n	8001ed6 <HAL_DMA_IRQHandler+0xe2>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001f46:	681a      	ldr	r2, [r3, #0]
 8001f48:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 8001f4c:	d108      	bne.n	8001f60 <HAL_DMA_IRQHandler+0x16c>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8001f4e:	6819      	ldr	r1, [r3, #0]
 8001f50:	f021 0110 	bic.w	r1, r1, #16
 8001f54:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8001f56:	2301      	movs	r3, #1
          __HAL_UNLOCK(hdma);
 8001f58:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8001f5c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
 8001f60:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001f62:	e7cb      	b.n	8001efc <HAL_DMA_IRQHandler+0x108>
 8001f64:	20000000 	.word	0x20000000

08001f68 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001f6c:	b085      	sub	sp, #20
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001f6e:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f70:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 8002120 <HAL_GPIO_Init+0x1b8>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001f74:	4a68      	ldr	r2, [pc, #416]	; (8002118 <HAL_GPIO_Init+0x1b0>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001f76:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 8002124 <HAL_GPIO_Init+0x1bc>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001f7a:	9301      	str	r3, [sp, #4]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001f7c:	2300      	movs	r3, #0
    ioposition = 0x01U << position;
 8001f7e:	f04f 0e01 	mov.w	lr, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001f82:	9c01      	ldr	r4, [sp, #4]
    ioposition = 0x01U << position;
 8001f84:	fa0e fe03 	lsl.w	lr, lr, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001f88:	ea0e 0604 	and.w	r6, lr, r4
    if(iocurrent == ioposition)
 8001f8c:	45b6      	cmp	lr, r6
 8001f8e:	f040 80ae 	bne.w	80020ee <HAL_GPIO_Init+0x186>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001f92:	684c      	ldr	r4, [r1, #4]
 8001f94:	f024 0710 	bic.w	r7, r4, #16
 8001f98:	2f02      	cmp	r7, #2
 8001f9a:	d116      	bne.n	8001fca <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3U];
 8001f9c:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8001fa0:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001fa4:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8001fa8:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001fac:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001fb0:	f04f 0c0f 	mov.w	ip, #15
 8001fb4:	fa0c fc0b 	lsl.w	ip, ip, fp
 8001fb8:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8001fbc:	690d      	ldr	r5, [r1, #16]
 8001fbe:	fa05 f50b 	lsl.w	r5, r5, fp
 8001fc2:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3U] = temp;
 8001fc6:	f8ca 5020 	str.w	r5, [sl, #32]
 8001fca:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001fce:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8001fd0:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001fd4:	fa05 f50a 	lsl.w	r5, r5, sl
 8001fd8:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001fda:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001fde:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001fe2:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001fe6:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001fe8:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001fec:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 8001fee:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001ff2:	d811      	bhi.n	8002018 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR; 
 8001ff4:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001ff6:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001ffa:	68cf      	ldr	r7, [r1, #12]
 8001ffc:	fa07 fc0a 	lsl.w	ip, r7, sl
 8002000:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 8002004:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8002006:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002008:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800200c:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8002010:	409f      	lsls	r7, r3
 8002012:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8002016:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8002018:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800201a:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800201c:	688f      	ldr	r7, [r1, #8]
 800201e:	fa07 f70a 	lsl.w	r7, r7, sl
 8002022:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8002024:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8002026:	00e5      	lsls	r5, r4, #3
 8002028:	d561      	bpl.n	80020ee <HAL_GPIO_Init+0x186>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800202a:	f04f 0b00 	mov.w	fp, #0
 800202e:	f8cd b00c 	str.w	fp, [sp, #12]
 8002032:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002036:	4d39      	ldr	r5, [pc, #228]	; (800211c <HAL_GPIO_Init+0x1b4>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002038:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
 800203c:	f8c8 7044 	str.w	r7, [r8, #68]	; 0x44
 8002040:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
 8002044:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 8002048:	9703      	str	r7, [sp, #12]
 800204a:	9f03      	ldr	r7, [sp, #12]
 800204c:	f023 0703 	bic.w	r7, r3, #3
 8002050:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8002054:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8002058:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 800205c:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8002060:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8002064:	f04f 0e0f 	mov.w	lr, #15
 8002068:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800206c:	42a8      	cmp	r0, r5
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800206e:	ea2a 0e0e 	bic.w	lr, sl, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002072:	d043      	beq.n	80020fc <HAL_GPIO_Init+0x194>
 8002074:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002078:	42a8      	cmp	r0, r5
 800207a:	d041      	beq.n	8002100 <HAL_GPIO_Init+0x198>
 800207c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002080:	42a8      	cmp	r0, r5
 8002082:	d03f      	beq.n	8002104 <HAL_GPIO_Init+0x19c>
 8002084:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002088:	42a8      	cmp	r0, r5
 800208a:	d03d      	beq.n	8002108 <HAL_GPIO_Init+0x1a0>
 800208c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002090:	42a8      	cmp	r0, r5
 8002092:	d03b      	beq.n	800210c <HAL_GPIO_Init+0x1a4>
 8002094:	4548      	cmp	r0, r9
 8002096:	d03b      	beq.n	8002110 <HAL_GPIO_Init+0x1a8>
 8002098:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800209c:	42a8      	cmp	r0, r5
 800209e:	d039      	beq.n	8002114 <HAL_GPIO_Init+0x1ac>
 80020a0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80020a4:	42a8      	cmp	r0, r5
 80020a6:	bf14      	ite	ne
 80020a8:	2508      	movne	r5, #8
 80020aa:	2507      	moveq	r5, #7
 80020ac:	fa05 f50c 	lsl.w	r5, r5, ip
 80020b0:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 80020b4:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR;
 80020b6:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 80020b8:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80020ba:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 80020be:	bf0c      	ite	eq
 80020c0:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 80020c2:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;
 80020c4:	6015      	str	r5, [r2, #0]

        temp = EXTI->EMR;
 80020c6:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80020c8:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 80020cc:	bf0c      	ite	eq
 80020ce:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 80020d0:	4335      	orrne	r5, r6
        }
        EXTI->EMR = temp;
 80020d2:	6055      	str	r5, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80020d4:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80020d6:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 80020da:	bf0c      	ite	eq
 80020dc:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 80020de:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;
 80020e0:	6095      	str	r5, [r2, #8]

        temp = EXTI->FTSR;
 80020e2:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80020e4:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 80020e6:	bf54      	ite	pl
 80020e8:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
 80020ea:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 80020ec:	60d5      	str	r5, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 80020ee:	3301      	adds	r3, #1
 80020f0:	2b10      	cmp	r3, #16
 80020f2:	f47f af44 	bne.w	8001f7e <HAL_GPIO_Init+0x16>
      }
    }
  }
}
 80020f6:	b005      	add	sp, #20
 80020f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80020fc:	465d      	mov	r5, fp
 80020fe:	e7d5      	b.n	80020ac <HAL_GPIO_Init+0x144>
 8002100:	2501      	movs	r5, #1
 8002102:	e7d3      	b.n	80020ac <HAL_GPIO_Init+0x144>
 8002104:	2502      	movs	r5, #2
 8002106:	e7d1      	b.n	80020ac <HAL_GPIO_Init+0x144>
 8002108:	2503      	movs	r5, #3
 800210a:	e7cf      	b.n	80020ac <HAL_GPIO_Init+0x144>
 800210c:	2504      	movs	r5, #4
 800210e:	e7cd      	b.n	80020ac <HAL_GPIO_Init+0x144>
 8002110:	2505      	movs	r5, #5
 8002112:	e7cb      	b.n	80020ac <HAL_GPIO_Init+0x144>
 8002114:	2506      	movs	r5, #6
 8002116:	e7c9      	b.n	80020ac <HAL_GPIO_Init+0x144>
 8002118:	40013c00 	.word	0x40013c00
 800211c:	40020000 	.word	0x40020000
 8002120:	40023800 	.word	0x40023800
 8002124:	40021400 	.word	0x40021400

08002128 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002128:	b10a      	cbz	r2, 800212e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 800212a:	6181      	str	r1, [r0, #24]
 800212c:	4770      	bx	lr
 800212e:	0409      	lsls	r1, r1, #16
 8002130:	e7fb      	b.n	800212a <HAL_GPIO_WritePin+0x2>

08002132 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8002132:	6943      	ldr	r3, [r0, #20]
 8002134:	4059      	eors	r1, r3
 8002136:	6141      	str	r1, [r0, #20]
 8002138:	4770      	bx	lr
	...

0800213c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800213c:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 800213e:	4b04      	ldr	r3, [pc, #16]	; (8002150 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8002140:	6959      	ldr	r1, [r3, #20]
 8002142:	4201      	tst	r1, r0
 8002144:	d002      	beq.n	800214c <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8002146:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8002148:	f003 fe40 	bl	8005dcc <HAL_GPIO_EXTI_Callback>
 800214c:	bd08      	pop	{r3, pc}
 800214e:	bf00      	nop
 8002150:	40013c00 	.word	0x40013c00

08002154 <HAL_I2C_Init>:
  * @param  hi2c pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8002154:	b570      	push	{r4, r5, r6, lr}
  uint32_t freqrange = 0U;
  uint32_t pclk1 = 0U;

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 8002156:	4604      	mov	r4, r0
 8002158:	2800      	cmp	r0, #0
 800215a:	d062      	beq.n	8002222 <HAL_I2C_Init+0xce>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
 800215c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002160:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002164:	b91b      	cbnz	r3, 800216e <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8002166:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 800216a:	f7fe fbf7 	bl	800095c <HAL_I2C_MspInit>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800216e:	6822      	ldr	r2, [r4, #0]
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8002170:	4e2d      	ldr	r6, [pc, #180]	; (8002228 <HAL_I2C_Init+0xd4>)
  freqrange = I2C_FREQRANGE(pclk1);
 8002172:	4d2e      	ldr	r5, [pc, #184]	; (800222c <HAL_I2C_Init+0xd8>)
  hi2c->State = HAL_I2C_STATE_BUSY;
 8002174:	2324      	movs	r3, #36	; 0x24
 8002176:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 800217a:	6813      	ldr	r3, [r2, #0]
 800217c:	f023 0301 	bic.w	r3, r3, #1
 8002180:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8002182:	f000 ffd3 	bl	800312c <HAL_RCC_GetPCLK1Freq>
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8002186:	6863      	ldr	r3, [r4, #4]
  hi2c->Instance->CR2 = freqrange;
 8002188:	6822      	ldr	r2, [r4, #0]
  freqrange = I2C_FREQRANGE(pclk1);
 800218a:	fbb0 f5f5 	udiv	r5, r0, r5
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 800218e:	42b3      	cmp	r3, r6
 8002190:	bf84      	itt	hi
 8002192:	f44f 7196 	movhi.w	r1, #300	; 0x12c
 8002196:	4369      	mulhi	r1, r5
  hi2c->Instance->CR2 = freqrange;
 8002198:	6055      	str	r5, [r2, #4]
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 800219a:	bf91      	iteee	ls
 800219c:	1c69      	addls	r1, r5, #1
 800219e:	f44f 757a 	movhi.w	r5, #1000	; 0x3e8
 80021a2:	fbb1 f1f5 	udivhi	r1, r1, r5
 80021a6:	3101      	addhi	r1, #1

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 80021a8:	42b3      	cmp	r3, r6
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80021aa:	6211      	str	r1, [r2, #32]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 80021ac:	d821      	bhi.n	80021f2 <HAL_I2C_Init+0x9e>
 80021ae:	005b      	lsls	r3, r3, #1
 80021b0:	fbb0 f0f3 	udiv	r0, r0, r3
 80021b4:	f3c0 030b 	ubfx	r3, r0, #0, #12
 80021b8:	2b03      	cmp	r3, #3
 80021ba:	bf98      	it	ls
 80021bc:	2004      	movls	r0, #4

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80021be:	6a21      	ldr	r1, [r4, #32]
 80021c0:	69e3      	ldr	r3, [r4, #28]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 80021c2:	61d0      	str	r0, [r2, #28]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80021c4:	430b      	orrs	r3, r1
 80021c6:	6013      	str	r3, [r2, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 80021c8:	68e1      	ldr	r1, [r4, #12]
 80021ca:	6923      	ldr	r3, [r4, #16]
 80021cc:	430b      	orrs	r3, r1
 80021ce:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 80021d0:	69a1      	ldr	r1, [r4, #24]
 80021d2:	6963      	ldr	r3, [r4, #20]
 80021d4:	430b      	orrs	r3, r1
 80021d6:	60d3      	str	r3, [r2, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 80021d8:	6813      	ldr	r3, [r2, #0]
 80021da:	f043 0301 	orr.w	r3, r3, #1
 80021de:	6013      	str	r3, [r2, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80021e0:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 80021e2:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80021e4:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 80021e6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 80021ea:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80021ec:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e

  return HAL_OK;
 80021f0:	bd70      	pop	{r4, r5, r6, pc}
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 80021f2:	68a1      	ldr	r1, [r4, #8]
 80021f4:	b949      	cbnz	r1, 800220a <HAL_I2C_Init+0xb6>
 80021f6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80021fa:	fbb0 f0f3 	udiv	r0, r0, r3
 80021fe:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8002202:	b163      	cbz	r3, 800221e <HAL_I2C_Init+0xca>
 8002204:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 8002208:	e7d9      	b.n	80021be <HAL_I2C_Init+0x6a>
 800220a:	2119      	movs	r1, #25
 800220c:	434b      	muls	r3, r1
 800220e:	fbb0 f0f3 	udiv	r0, r0, r3
 8002212:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8002216:	b113      	cbz	r3, 800221e <HAL_I2C_Init+0xca>
 8002218:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
 800221c:	e7cf      	b.n	80021be <HAL_I2C_Init+0x6a>
 800221e:	2001      	movs	r0, #1
 8002220:	e7cd      	b.n	80021be <HAL_I2C_Init+0x6a>
    return HAL_ERROR;
 8002222:	2001      	movs	r0, #1
}
 8002224:	bd70      	pop	{r4, r5, r6, pc}
 8002226:	bf00      	nop
 8002228:	000186a0 	.word	0x000186a0
 800222c:	000f4240 	.word	0x000f4240

08002230 <HAL_I2C_MasterTxCpltCallback>:
 8002230:	4770      	bx	lr

08002232 <HAL_I2C_MasterRxCpltCallback>:
 8002232:	4770      	bx	lr

08002234 <HAL_I2C_SlaveTxCpltCallback>:
 8002234:	4770      	bx	lr

08002236 <HAL_I2C_SlaveRxCpltCallback>:
 8002236:	4770      	bx	lr

08002238 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferOptions_definition
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
 8002238:	4770      	bx	lr

0800223a <HAL_I2C_ListenCpltCallback>:
 800223a:	4770      	bx	lr

0800223c <HAL_I2C_MemTxCpltCallback>:
 800223c:	4770      	bx	lr

0800223e <HAL_I2C_MemRxCpltCallback>:
 800223e:	4770      	bx	lr

08002240 <HAL_I2C_ErrorCallback>:
 8002240:	4770      	bx	lr

08002242 <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8002242:	4770      	bx	lr

08002244 <I2C_ITError>:
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c)
{
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  uint32_t CurrentState = hi2c->State;
 8002244:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d

  if((CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8002248:	3b29      	subs	r3, #41	; 0x29
 800224a:	2b01      	cmp	r3, #1
{
 800224c:	b510      	push	{r4, lr}
 800224e:	6803      	ldr	r3, [r0, #0]
 8002250:	4604      	mov	r4, r0
  if((CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8002252:	d839      	bhi.n	80022c8 <I2C_ITError+0x84>
  {
    /* keep HAL_I2C_STATE_LISTEN */
    hi2c->PreviousState = I2C_STATE_NONE;
 8002254:	2200      	movs	r2, #0
 8002256:	6302      	str	r2, [r0, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8002258:	2228      	movs	r2, #40	; 0x28
 800225a:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    hi2c->PreviousState = I2C_STATE_NONE;
    hi2c->Mode = HAL_I2C_MODE_NONE;
  }

  /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
  hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 800225e:	681a      	ldr	r2, [r3, #0]
 8002260:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8002264:	601a      	str	r2, [r3, #0]

  /* Abort DMA transfer */
  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8002266:	685a      	ldr	r2, [r3, #4]
 8002268:	f412 6200 	ands.w	r2, r2, #2048	; 0x800
 800226c:	d054      	beq.n	8002318 <I2C_ITError+0xd4>
  {
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 800226e:	685a      	ldr	r2, [r3, #4]

    if(hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 8002270:	6b60      	ldr	r0, [r4, #52]	; 0x34
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 8002272:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8002276:	605a      	str	r2, [r3, #4]
    if(hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 8002278:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800227c:	2b01      	cmp	r3, #1
 800227e:	4b39      	ldr	r3, [pc, #228]	; (8002364 <I2C_ITError+0x120>)
 8002280:	d031      	beq.n	80022e6 <I2C_ITError+0xa2>
    {
      /* Set the DMA Abort callback : 
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8002282:	6503      	str	r3, [r0, #80]	; 0x50

      if(HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8002284:	f7ff fda4 	bl	8001dd0 <HAL_DMA_Abort_IT>
 8002288:	b150      	cbz	r0, 80022a0 <I2C_ITError+0x5c>
      {
        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 800228a:	6822      	ldr	r2, [r4, #0]

        hi2c->State = HAL_I2C_STATE_READY;

        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 800228c:	6b60      	ldr	r0, [r4, #52]	; 0x34
        __HAL_I2C_DISABLE(hi2c);
 800228e:	6813      	ldr	r3, [r2, #0]
 8002290:	f023 0301 	bic.w	r3, r3, #1
 8002294:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 8002296:	2320      	movs	r3, #32
 8002298:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        __HAL_I2C_DISABLE(hi2c);

        hi2c->State = HAL_I2C_STATE_READY;

        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800229c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800229e:	4798      	blx	r3
    HAL_I2C_ErrorCallback(hi2c);
  }
  /* STOP Flag is not set after a NACK reception */
  /* So may inform upper layer that listen phase is stopped */
  /* during NACK error treatment */
  if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
 80022a0:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80022a4:	2b28      	cmp	r3, #40	; 0x28
 80022a6:	d10e      	bne.n	80022c6 <I2C_ITError+0x82>
 80022a8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80022aa:	075b      	lsls	r3, r3, #29
 80022ac:	d50b      	bpl.n	80022c6 <I2C_ITError+0x82>
  {
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80022ae:	4b2e      	ldr	r3, [pc, #184]	; (8002368 <I2C_ITError+0x124>)
 80022b0:	62e3      	str	r3, [r4, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
    hi2c->State = HAL_I2C_STATE_READY;
 80022b2:	2220      	movs	r2, #32
    hi2c->PreviousState = I2C_STATE_NONE;
 80022b4:	2300      	movs	r3, #0
 80022b6:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->Mode = HAL_I2C_MODE_NONE;
    
    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    HAL_I2C_ListenCpltCallback(hi2c);
 80022b8:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 80022ba:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80022be:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 80022c2:	f7ff ffba 	bl	800223a <HAL_I2C_ListenCpltCallback>
 80022c6:	bd10      	pop	{r4, pc}
    if((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) != I2C_CR2_DMAEN))
 80022c8:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 80022cc:	2a60      	cmp	r2, #96	; 0x60
 80022ce:	d005      	beq.n	80022dc <I2C_ITError+0x98>
 80022d0:	685a      	ldr	r2, [r3, #4]
 80022d2:	0512      	lsls	r2, r2, #20
      hi2c->State = HAL_I2C_STATE_READY;
 80022d4:	bf5c      	itt	pl
 80022d6:	2220      	movpl	r2, #32
 80022d8:	f880 203d 	strbpl.w	r2, [r0, #61]	; 0x3d
    hi2c->PreviousState = I2C_STATE_NONE;
 80022dc:	2200      	movs	r2, #0
 80022de:	6322      	str	r2, [r4, #48]	; 0x30
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80022e0:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
 80022e4:	e7bb      	b.n	800225e <I2C_ITError+0x1a>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80022e6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80022e8:	6503      	str	r3, [r0, #80]	; 0x50
      if(HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 80022ea:	f7ff fd71 	bl	8001dd0 <HAL_DMA_Abort_IT>
 80022ee:	2800      	cmp	r0, #0
 80022f0:	d0d6      	beq.n	80022a0 <I2C_ITError+0x5c>
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80022f2:	6822      	ldr	r2, [r4, #0]
 80022f4:	6953      	ldr	r3, [r2, #20]
 80022f6:	0658      	lsls	r0, r3, #25
 80022f8:	d504      	bpl.n	8002304 <I2C_ITError+0xc0>
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80022fa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80022fc:	6912      	ldr	r2, [r2, #16]
 80022fe:	1c59      	adds	r1, r3, #1
 8002300:	6261      	str	r1, [r4, #36]	; 0x24
 8002302:	701a      	strb	r2, [r3, #0]
        __HAL_I2C_DISABLE(hi2c);
 8002304:	6822      	ldr	r2, [r4, #0]
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8002306:	6ba0      	ldr	r0, [r4, #56]	; 0x38
        __HAL_I2C_DISABLE(hi2c);
 8002308:	6813      	ldr	r3, [r2, #0]
 800230a:	f023 0301 	bic.w	r3, r3, #1
 800230e:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 8002310:	2320      	movs	r3, #32
 8002312:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 8002316:	e7c1      	b.n	800229c <I2C_ITError+0x58>
  else if(hi2c->State == HAL_I2C_STATE_ABORT)
 8002318:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
 800231c:	2960      	cmp	r1, #96	; 0x60
 800231e:	d114      	bne.n	800234a <I2C_ITError+0x106>
    hi2c->State = HAL_I2C_STATE_READY;
 8002320:	2120      	movs	r1, #32
 8002322:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002326:	6422      	str	r2, [r4, #64]	; 0x40
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8002328:	695a      	ldr	r2, [r3, #20]
 800232a:	0651      	lsls	r1, r2, #25
 800232c:	d504      	bpl.n	8002338 <I2C_ITError+0xf4>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 800232e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002330:	691b      	ldr	r3, [r3, #16]
 8002332:	1c51      	adds	r1, r2, #1
 8002334:	6261      	str	r1, [r4, #36]	; 0x24
 8002336:	7013      	strb	r3, [r2, #0]
    __HAL_I2C_DISABLE(hi2c);
 8002338:	6822      	ldr	r2, [r4, #0]
 800233a:	6813      	ldr	r3, [r2, #0]
 800233c:	f023 0301 	bic.w	r3, r3, #1
 8002340:	6013      	str	r3, [r2, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 8002342:	4620      	mov	r0, r4
 8002344:	f7ff ff7d 	bl	8002242 <HAL_I2C_AbortCpltCallback>
 8002348:	e7aa      	b.n	80022a0 <I2C_ITError+0x5c>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800234a:	695a      	ldr	r2, [r3, #20]
 800234c:	0652      	lsls	r2, r2, #25
 800234e:	d504      	bpl.n	800235a <I2C_ITError+0x116>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8002350:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002352:	691b      	ldr	r3, [r3, #16]
 8002354:	1c51      	adds	r1, r2, #1
 8002356:	6261      	str	r1, [r4, #36]	; 0x24
 8002358:	7013      	strb	r3, [r2, #0]
    HAL_I2C_ErrorCallback(hi2c);
 800235a:	4620      	mov	r0, r4
 800235c:	f7ff ff70 	bl	8002240 <HAL_I2C_ErrorCallback>
 8002360:	e79e      	b.n	80022a0 <I2C_ITError+0x5c>
 8002362:	bf00      	nop
 8002364:	08002b75 	.word	0x08002b75
 8002368:	ffff0000 	.word	0xffff0000

0800236c <HAL_I2C_EV_IRQHandler>:
  uint32_t sr2itflags   = READ_REG(hi2c->Instance->SR2);
 800236c:	6803      	ldr	r3, [r0, #0]
{
 800236e:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8002370:	699d      	ldr	r5, [r3, #24]
  uint32_t sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8002372:	6959      	ldr	r1, [r3, #20]
  uint32_t itsources    = READ_REG(hi2c->Instance->CR2);
 8002374:	685a      	ldr	r2, [r3, #4]
  uint32_t CurrentMode  = hi2c->Mode;
 8002376:	f890 403e 	ldrb.w	r4, [r0, #62]	; 0x3e
 800237a:	b2e4      	uxtb	r4, r4
  if((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 800237c:	2c10      	cmp	r4, #16
{
 800237e:	b08d      	sub	sp, #52	; 0x34
  if((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 8002380:	d002      	beq.n	8002388 <HAL_I2C_EV_IRQHandler+0x1c>
 8002382:	2c40      	cmp	r4, #64	; 0x40
 8002384:	f040 8255 	bne.w	8002832 <HAL_I2C_EV_IRQHandler+0x4c6>
    if(((sr1itflags & I2C_FLAG_SB) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8002388:	f011 1f01 	tst.w	r1, #65537	; 0x10001
 800238c:	d066      	beq.n	800245c <HAL_I2C_EV_IRQHandler+0xf0>
 800238e:	0597      	lsls	r7, r2, #22
 8002390:	d564      	bpl.n	800245c <HAL_I2C_EV_IRQHandler+0xf0>
  if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8002392:	f890 403e 	ldrb.w	r4, [r0, #62]	; 0x3e
 8002396:	2c40      	cmp	r4, #64	; 0x40
 8002398:	d143      	bne.n	8002422 <HAL_I2C_EV_IRQHandler+0xb6>
    if(hi2c->EventCount == 0U)
 800239a:	6d04      	ldr	r4, [r0, #80]	; 0x50
 800239c:	2c00      	cmp	r4, #0
 800239e:	d13b      	bne.n	8002418 <HAL_I2C_EV_IRQHandler+0xac>
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 80023a0:	6c44      	ldr	r4, [r0, #68]	; 0x44
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 80023a2:	f004 04fe 	and.w	r4, r4, #254	; 0xfe
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 80023a6:	611c      	str	r4, [r3, #16]
    if((sr2itflags & I2C_FLAG_TRA) != RESET)
 80023a8:	4e98      	ldr	r6, [pc, #608]	; (800260c <HAL_I2C_EV_IRQHandler+0x2a0>)
 80023aa:	4c99      	ldr	r4, [pc, #612]	; (8002610 <HAL_I2C_EV_IRQHandler+0x2a4>)
 80023ac:	402e      	ands	r6, r5
 80023ae:	400c      	ands	r4, r1
 80023b0:	2e00      	cmp	r6, #0
 80023b2:	f000 819f 	beq.w	80026f4 <HAL_I2C_EV_IRQHandler+0x388>
      if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 80023b6:	4d97      	ldr	r5, [pc, #604]	; (8002614 <HAL_I2C_EV_IRQHandler+0x2a8>)
 80023b8:	400d      	ands	r5, r1
 80023ba:	2d00      	cmp	r5, #0
 80023bc:	f000 8166 	beq.w	800268c <HAL_I2C_EV_IRQHandler+0x320>
 80023c0:	0555      	lsls	r5, r2, #21
 80023c2:	f140 8163 	bpl.w	800268c <HAL_I2C_EV_IRQHandler+0x320>
 80023c6:	2c00      	cmp	r4, #0
 80023c8:	f040 8160 	bne.w	800268c <HAL_I2C_EV_IRQHandler+0x320>
  uint32_t CurrentState       = hi2c->State;
 80023cc:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  if((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 80023d0:	8d05      	ldrh	r5, [r0, #40]	; 0x28
  uint32_t CurrentMode        = hi2c->Mode;
 80023d2:	f890 103e 	ldrb.w	r1, [r0, #62]	; 0x3e
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 80023d6:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  uint32_t CurrentState       = hi2c->State;
 80023d8:	b2d2      	uxtb	r2, r2
  uint32_t CurrentMode        = hi2c->Mode;
 80023da:	b2c9      	uxtb	r1, r1
  if((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 80023dc:	2d00      	cmp	r5, #0
 80023de:	f040 8105 	bne.w	80025ec <HAL_I2C_EV_IRQHandler+0x280>
 80023e2:	2a21      	cmp	r2, #33	; 0x21
 80023e4:	f040 8104 	bne.w	80025f0 <HAL_I2C_EV_IRQHandler+0x284>
    if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80023e8:	2c04      	cmp	r4, #4
 80023ea:	f000 816c 	beq.w	80026c6 <HAL_I2C_EV_IRQHandler+0x35a>
 80023ee:	2c08      	cmp	r4, #8
 80023f0:	f000 8169 	beq.w	80026c6 <HAL_I2C_EV_IRQHandler+0x35a>
 80023f4:	f514 3f80 	cmn.w	r4, #65536	; 0x10000
 80023f8:	f000 8165 	beq.w	80026c6 <HAL_I2C_EV_IRQHandler+0x35a>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80023fc:	685a      	ldr	r2, [r3, #4]
 80023fe:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8002402:	605a      	str	r2, [r3, #4]
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8002404:	2311      	movs	r3, #17
 8002406:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002408:	f880 503e 	strb.w	r5, [r0, #62]	; 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 800240c:	2320      	movs	r3, #32
 800240e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8002412:	f7ff ff0d 	bl	8002230 <HAL_I2C_MasterTxCpltCallback>
 8002416:	e0f6      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8002418:	6c44      	ldr	r4, [r0, #68]	; 0x44
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 800241a:	f044 0401 	orr.w	r4, r4, #1
 800241e:	b2e4      	uxtb	r4, r4
 8002420:	e7c1      	b.n	80023a6 <HAL_I2C_EV_IRQHandler+0x3a>
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8002422:	6904      	ldr	r4, [r0, #16]
 8002424:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
 8002428:	d105      	bne.n	8002436 <HAL_I2C_EV_IRQHandler+0xca>
      if(hi2c->State == HAL_I2C_STATE_BUSY_TX) 
 800242a:	f890 403d 	ldrb.w	r4, [r0, #61]	; 0x3d
 800242e:	2c21      	cmp	r4, #33	; 0x21
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8002430:	6c44      	ldr	r4, [r0, #68]	; 0x44
      if(hi2c->State == HAL_I2C_STATE_BUSY_TX) 
 8002432:	d1f2      	bne.n	800241a <HAL_I2C_EV_IRQHandler+0xae>
 8002434:	e7b5      	b.n	80023a2 <HAL_I2C_EV_IRQHandler+0x36>
      if(hi2c->EventCount == 0U)
 8002436:	6d04      	ldr	r4, [r0, #80]	; 0x50
 8002438:	b934      	cbnz	r4, 8002448 <HAL_I2C_EV_IRQHandler+0xdc>
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 800243a:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800243c:	11e4      	asrs	r4, r4, #7
 800243e:	f004 0406 	and.w	r4, r4, #6
 8002442:	f044 04f0 	orr.w	r4, r4, #240	; 0xf0
 8002446:	e7ae      	b.n	80023a6 <HAL_I2C_EV_IRQHandler+0x3a>
      else if(hi2c->EventCount == 1U)
 8002448:	6d04      	ldr	r4, [r0, #80]	; 0x50
 800244a:	2c01      	cmp	r4, #1
 800244c:	d1ac      	bne.n	80023a8 <HAL_I2C_EV_IRQHandler+0x3c>
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 800244e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8002450:	11e4      	asrs	r4, r4, #7
 8002452:	f004 0406 	and.w	r4, r4, #6
 8002456:	f044 04f1 	orr.w	r4, r4, #241	; 0xf1
 800245a:	e7a4      	b.n	80023a6 <HAL_I2C_EV_IRQHandler+0x3a>
    else if(((sr1itflags & I2C_FLAG_ADD10) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 800245c:	4c6e      	ldr	r4, [pc, #440]	; (8002618 <HAL_I2C_EV_IRQHandler+0x2ac>)
 800245e:	400c      	ands	r4, r1
 8002460:	b11c      	cbz	r4, 800246a <HAL_I2C_EV_IRQHandler+0xfe>
 8002462:	0596      	lsls	r6, r2, #22
 8002464:	d501      	bpl.n	800246a <HAL_I2C_EV_IRQHandler+0xfe>
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 8002466:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8002468:	e7d9      	b.n	800241e <HAL_I2C_EV_IRQHandler+0xb2>
    else if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 800246a:	4c6c      	ldr	r4, [pc, #432]	; (800261c <HAL_I2C_EV_IRQHandler+0x2b0>)
 800246c:	400c      	ands	r4, r1
 800246e:	2c00      	cmp	r4, #0
 8002470:	d09a      	beq.n	80023a8 <HAL_I2C_EV_IRQHandler+0x3c>
 8002472:	0594      	lsls	r4, r2, #22
 8002474:	d598      	bpl.n	80023a8 <HAL_I2C_EV_IRQHandler+0x3c>
  uint32_t CurrentMode        = hi2c->Mode;
 8002476:	f890 403e 	ldrb.w	r4, [r0, #62]	; 0x3e
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 800247a:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  uint32_t Prev_State         = hi2c->PreviousState;
 800247c:	f8d0 e030 	ldr.w	lr, [r0, #48]	; 0x30
  if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8002480:	f890 703d 	ldrb.w	r7, [r0, #61]	; 0x3d
 8002484:	2f22      	cmp	r7, #34	; 0x22
  uint32_t CurrentMode        = hi2c->Mode;
 8002486:	b2e4      	uxtb	r4, r4
  if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8002488:	f040 80a8 	bne.w	80025dc <HAL_I2C_EV_IRQHandler+0x270>
    if((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 800248c:	6d07      	ldr	r7, [r0, #80]	; 0x50
 800248e:	b947      	cbnz	r7, 80024a2 <HAL_I2C_EV_IRQHandler+0x136>
 8002490:	2c40      	cmp	r4, #64	; 0x40
 8002492:	d106      	bne.n	80024a2 <HAL_I2C_EV_IRQHandler+0x136>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002494:	9701      	str	r7, [sp, #4]
 8002496:	695c      	ldr	r4, [r3, #20]
 8002498:	9401      	str	r4, [sp, #4]
 800249a:	699c      	ldr	r4, [r3, #24]
 800249c:	9401      	str	r4, [sp, #4]
 800249e:	9c01      	ldr	r4, [sp, #4]
 80024a0:	e782      	b.n	80023a8 <HAL_I2C_EV_IRQHandler+0x3c>
    else if((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 80024a2:	6d04      	ldr	r4, [r0, #80]	; 0x50
 80024a4:	b98c      	cbnz	r4, 80024ca <HAL_I2C_EV_IRQHandler+0x15e>
 80024a6:	6907      	ldr	r7, [r0, #16]
 80024a8:	f5b7 4f40 	cmp.w	r7, #49152	; 0xc000
 80024ac:	d10d      	bne.n	80024ca <HAL_I2C_EV_IRQHandler+0x15e>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80024ae:	9402      	str	r4, [sp, #8]
 80024b0:	695c      	ldr	r4, [r3, #20]
 80024b2:	9402      	str	r4, [sp, #8]
 80024b4:	699c      	ldr	r4, [r3, #24]
 80024b6:	9402      	str	r4, [sp, #8]
 80024b8:	9c02      	ldr	r4, [sp, #8]
      hi2c->Instance->CR1 |= I2C_CR1_START;
 80024ba:	681c      	ldr	r4, [r3, #0]
 80024bc:	f444 7480 	orr.w	r4, r4, #256	; 0x100
 80024c0:	601c      	str	r4, [r3, #0]
      hi2c->EventCount++;
 80024c2:	6d04      	ldr	r4, [r0, #80]	; 0x50
 80024c4:	3401      	adds	r4, #1
      hi2c->EventCount = 0U;
 80024c6:	6504      	str	r4, [r0, #80]	; 0x50
 80024c8:	e76e      	b.n	80023a8 <HAL_I2C_EV_IRQHandler+0x3c>
      if(hi2c->XferCount == 0U)
 80024ca:	8d44      	ldrh	r4, [r0, #42]	; 0x2a
 80024cc:	b2a4      	uxth	r4, r4
 80024ce:	b954      	cbnz	r4, 80024e6 <HAL_I2C_EV_IRQHandler+0x17a>
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80024d0:	9403      	str	r4, [sp, #12]
 80024d2:	695c      	ldr	r4, [r3, #20]
 80024d4:	9403      	str	r4, [sp, #12]
 80024d6:	699c      	ldr	r4, [r3, #24]
 80024d8:	9403      	str	r4, [sp, #12]
 80024da:	9c03      	ldr	r4, [sp, #12]
            hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80024dc:	681c      	ldr	r4, [r3, #0]
 80024de:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 80024e2:	601c      	str	r4, [r3, #0]
 80024e4:	e019      	b.n	800251a <HAL_I2C_EV_IRQHandler+0x1ae>
      else if(hi2c->XferCount == 1U)   
 80024e6:	8d44      	ldrh	r4, [r0, #42]	; 0x2a
 80024e8:	b2a4      	uxth	r4, r4
 80024ea:	2c01      	cmp	r4, #1
 80024ec:	d142      	bne.n	8002574 <HAL_I2C_EV_IRQHandler+0x208>
        if(CurrentXferOptions == I2C_NO_OPTION_FRAME)
 80024ee:	f516 3f80 	cmn.w	r6, #65536	; 0x10000
 80024f2:	d11b      	bne.n	800252c <HAL_I2C_EV_IRQHandler+0x1c0>
            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80024f4:	681c      	ldr	r4, [r3, #0]
 80024f6:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 80024fa:	601c      	str	r4, [r3, #0]
          if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80024fc:	685c      	ldr	r4, [r3, #4]
 80024fe:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
 8002502:	d00c      	beq.n	800251e <HAL_I2C_EV_IRQHandler+0x1b2>
            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002504:	681c      	ldr	r4, [r3, #0]
 8002506:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 800250a:	601c      	str	r4, [r3, #0]
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800250c:	2400      	movs	r4, #0
 800250e:	9404      	str	r4, [sp, #16]
 8002510:	695c      	ldr	r4, [r3, #20]
 8002512:	9404      	str	r4, [sp, #16]
 8002514:	699c      	ldr	r4, [r3, #24]
 8002516:	9404      	str	r4, [sp, #16]
 8002518:	9c04      	ldr	r4, [sp, #16]
      hi2c->EventCount = 0U;
 800251a:	2400      	movs	r4, #0
 800251c:	e7d3      	b.n	80024c6 <HAL_I2C_EV_IRQHandler+0x15a>
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800251e:	9405      	str	r4, [sp, #20]
 8002520:	695c      	ldr	r4, [r3, #20]
 8002522:	9405      	str	r4, [sp, #20]
 8002524:	699c      	ldr	r4, [r3, #24]
 8002526:	9405      	str	r4, [sp, #20]
 8002528:	9c05      	ldr	r4, [sp, #20]
 800252a:	e7d7      	b.n	80024dc <HAL_I2C_EV_IRQHandler+0x170>
        else if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 800252c:	2e04      	cmp	r6, #4
 800252e:	d015      	beq.n	800255c <HAL_I2C_EV_IRQHandler+0x1f0>
 8002530:	2e08      	cmp	r6, #8
 8002532:	d013      	beq.n	800255c <HAL_I2C_EV_IRQHandler+0x1f0>
          && (Prev_State != I2C_STATE_MASTER_BUSY_RX))
 8002534:	f1be 0f12 	cmp.w	lr, #18
 8002538:	d010      	beq.n	800255c <HAL_I2C_EV_IRQHandler+0x1f0>
          if(hi2c->XferOptions != I2C_NEXT_FRAME)
 800253a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800253c:	2c02      	cmp	r4, #2
            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 800253e:	681c      	ldr	r4, [r3, #0]
 8002540:	bf14      	ite	ne
 8002542:	f424 6480 	bicne.w	r4, r4, #1024	; 0x400
            hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8002546:	f444 6480 	orreq.w	r4, r4, #1024	; 0x400
 800254a:	601c      	str	r4, [r3, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800254c:	2400      	movs	r4, #0
 800254e:	9406      	str	r4, [sp, #24]
 8002550:	695c      	ldr	r4, [r3, #20]
 8002552:	9406      	str	r4, [sp, #24]
 8002554:	699c      	ldr	r4, [r3, #24]
 8002556:	9406      	str	r4, [sp, #24]
 8002558:	9c06      	ldr	r4, [sp, #24]
 800255a:	e7de      	b.n	800251a <HAL_I2C_EV_IRQHandler+0x1ae>
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 800255c:	681c      	ldr	r4, [r3, #0]
 800255e:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 8002562:	601c      	str	r4, [r3, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002564:	2400      	movs	r4, #0
 8002566:	9407      	str	r4, [sp, #28]
 8002568:	695c      	ldr	r4, [r3, #20]
 800256a:	9407      	str	r4, [sp, #28]
 800256c:	699c      	ldr	r4, [r3, #24]
 800256e:	9407      	str	r4, [sp, #28]
 8002570:	9c07      	ldr	r4, [sp, #28]
 8002572:	e7b3      	b.n	80024dc <HAL_I2C_EV_IRQHandler+0x170>
      else if(hi2c->XferCount == 2U)
 8002574:	8d44      	ldrh	r4, [r0, #42]	; 0x2a
 8002576:	b2a4      	uxth	r4, r4
 8002578:	2c02      	cmp	r4, #2
 800257a:	d11c      	bne.n	80025b6 <HAL_I2C_EV_IRQHandler+0x24a>
        if(hi2c->XferOptions != I2C_NEXT_FRAME)
 800257c:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800257e:	2c02      	cmp	r4, #2
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002580:	681c      	ldr	r4, [r3, #0]
 8002582:	bf1d      	ittte	ne
 8002584:	f424 6480 	bicne.w	r4, r4, #1024	; 0x400
 8002588:	601c      	strne	r4, [r3, #0]
          hi2c->Instance->CR1 |= I2C_CR1_POS;
 800258a:	681c      	ldrne	r4, [r3, #0]
          hi2c->Instance->CR1 |= I2C_CR1_ACK;
 800258c:	f444 6480 	orreq.w	r4, r4, #1024	; 0x400
          hi2c->Instance->CR1 |= I2C_CR1_POS;
 8002590:	bf18      	it	ne
 8002592:	f444 6400 	orrne.w	r4, r4, #2048	; 0x800
          hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8002596:	601c      	str	r4, [r3, #0]
        if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8002598:	685c      	ldr	r4, [r3, #4]
 800259a:	0527      	lsls	r7, r4, #20
          hi2c->Instance->CR2 |= I2C_CR2_LAST;
 800259c:	bf42      	ittt	mi
 800259e:	685c      	ldrmi	r4, [r3, #4]
 80025a0:	f444 5480 	orrmi.w	r4, r4, #4096	; 0x1000
 80025a4:	605c      	strmi	r4, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80025a6:	2400      	movs	r4, #0
 80025a8:	9408      	str	r4, [sp, #32]
 80025aa:	695c      	ldr	r4, [r3, #20]
 80025ac:	9408      	str	r4, [sp, #32]
 80025ae:	699c      	ldr	r4, [r3, #24]
 80025b0:	9408      	str	r4, [sp, #32]
 80025b2:	9c08      	ldr	r4, [sp, #32]
 80025b4:	e7b1      	b.n	800251a <HAL_I2C_EV_IRQHandler+0x1ae>
        hi2c->Instance->CR1 |= I2C_CR1_ACK;
 80025b6:	681c      	ldr	r4, [r3, #0]
 80025b8:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
 80025bc:	601c      	str	r4, [r3, #0]
        if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80025be:	685c      	ldr	r4, [r3, #4]
 80025c0:	0526      	lsls	r6, r4, #20
          hi2c->Instance->CR2 |= I2C_CR2_LAST;
 80025c2:	bf42      	ittt	mi
 80025c4:	685c      	ldrmi	r4, [r3, #4]
 80025c6:	f444 5480 	orrmi.w	r4, r4, #4096	; 0x1000
 80025ca:	605c      	strmi	r4, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80025cc:	2400      	movs	r4, #0
 80025ce:	9409      	str	r4, [sp, #36]	; 0x24
 80025d0:	695c      	ldr	r4, [r3, #20]
 80025d2:	9409      	str	r4, [sp, #36]	; 0x24
 80025d4:	699c      	ldr	r4, [r3, #24]
 80025d6:	9409      	str	r4, [sp, #36]	; 0x24
 80025d8:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80025da:	e79e      	b.n	800251a <HAL_I2C_EV_IRQHandler+0x1ae>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80025dc:	2400      	movs	r4, #0
 80025de:	940a      	str	r4, [sp, #40]	; 0x28
 80025e0:	695c      	ldr	r4, [r3, #20]
 80025e2:	940a      	str	r4, [sp, #40]	; 0x28
 80025e4:	699c      	ldr	r4, [r3, #24]
 80025e6:	940a      	str	r4, [sp, #40]	; 0x28
 80025e8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80025ea:	e6dd      	b.n	80023a8 <HAL_I2C_EV_IRQHandler+0x3c>
  else if((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 80025ec:	2a21      	cmp	r2, #33	; 0x21
 80025ee:	d003      	beq.n	80025f8 <HAL_I2C_EV_IRQHandler+0x28c>
 80025f0:	2940      	cmp	r1, #64	; 0x40
 80025f2:	d108      	bne.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 80025f4:	2a22      	cmp	r2, #34	; 0x22
 80025f6:	d106      	bne.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    if(hi2c->XferCount == 0U)
 80025f8:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80025fa:	b292      	uxth	r2, r2
 80025fc:	b982      	cbnz	r2, 8002620 <HAL_I2C_EV_IRQHandler+0x2b4>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 80025fe:	685a      	ldr	r2, [r3, #4]
 8002600:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002604:	605a      	str	r2, [r3, #4]
}
 8002606:	b00d      	add	sp, #52	; 0x34
 8002608:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800260a:	bf00      	nop
 800260c:	00100004 	.word	0x00100004
 8002610:	00010004 	.word	0x00010004
 8002614:	00010080 	.word	0x00010080
 8002618:	00010008 	.word	0x00010008
 800261c:	00010002 	.word	0x00010002
      if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8002620:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8002624:	2a40      	cmp	r2, #64	; 0x40
 8002626:	d127      	bne.n	8002678 <HAL_I2C_EV_IRQHandler+0x30c>
        if(hi2c->EventCount == 0)
 8002628:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800262a:	b97a      	cbnz	r2, 800264c <HAL_I2C_EV_IRQHandler+0x2e0>
          if(hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 800262c:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 800262e:	2a01      	cmp	r2, #1
            hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8002630:	6c82      	ldr	r2, [r0, #72]	; 0x48
          if(hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 8002632:	d105      	bne.n	8002640 <HAL_I2C_EV_IRQHandler+0x2d4>
 8002634:	b2d2      	uxtb	r2, r2
            hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8002636:	611a      	str	r2, [r3, #16]
            hi2c->EventCount += 2;
 8002638:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800263a:	3302      	adds	r3, #2
            hi2c->EventCount++;
 800263c:	6503      	str	r3, [r0, #80]	; 0x50
 800263e:	e7e2      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
            hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8002640:	f3c2 2207 	ubfx	r2, r2, #8, #8
 8002644:	611a      	str	r2, [r3, #16]
            hi2c->EventCount++;
 8002646:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8002648:	3301      	adds	r3, #1
 800264a:	e7f7      	b.n	800263c <HAL_I2C_EV_IRQHandler+0x2d0>
        else if(hi2c->EventCount == 1)
 800264c:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800264e:	2a01      	cmp	r2, #1
 8002650:	d102      	bne.n	8002658 <HAL_I2C_EV_IRQHandler+0x2ec>
          hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8002652:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8002654:	b2d2      	uxtb	r2, r2
 8002656:	e7f5      	b.n	8002644 <HAL_I2C_EV_IRQHandler+0x2d8>
        else if(hi2c->EventCount == 2)
 8002658:	6d02      	ldr	r2, [r0, #80]	; 0x50
 800265a:	2a02      	cmp	r2, #2
 800265c:	d1d3      	bne.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
          if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800265e:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 8002662:	2a22      	cmp	r2, #34	; 0x22
 8002664:	d104      	bne.n	8002670 <HAL_I2C_EV_IRQHandler+0x304>
            hi2c->Instance->CR1 |= I2C_CR1_START;
 8002666:	681a      	ldr	r2, [r3, #0]
 8002668:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800266c:	601a      	str	r2, [r3, #0]
 800266e:	e7ca      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
          else if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8002670:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 8002674:	2a21      	cmp	r2, #33	; 0x21
 8002676:	d1c6      	bne.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 8002678:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800267a:	1c51      	adds	r1, r2, #1
 800267c:	6241      	str	r1, [r0, #36]	; 0x24
 800267e:	7812      	ldrb	r2, [r2, #0]
 8002680:	611a      	str	r2, [r3, #16]
    hi2c->XferCount--;
 8002682:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8002684:	3b01      	subs	r3, #1
 8002686:	b29b      	uxth	r3, r3
 8002688:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 800268a:	e7bc      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 800268c:	2c00      	cmp	r4, #0
 800268e:	d0ba      	beq.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 8002690:	0594      	lsls	r4, r2, #22
 8002692:	d5b8      	bpl.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8002694:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8002696:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 800269a:	2a21      	cmp	r2, #33	; 0x21
 800269c:	d1b3      	bne.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    if(hi2c->XferCount != 0U)
 800269e:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80026a0:	b292      	uxth	r2, r2
 80026a2:	2a00      	cmp	r2, #0
 80026a4:	d1e8      	bne.n	8002678 <HAL_I2C_EV_IRQHandler+0x30c>
      if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80026a6:	2904      	cmp	r1, #4
 80026a8:	d00d      	beq.n	80026c6 <HAL_I2C_EV_IRQHandler+0x35a>
 80026aa:	2908      	cmp	r1, #8
 80026ac:	d00b      	beq.n	80026c6 <HAL_I2C_EV_IRQHandler+0x35a>
 80026ae:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 80026b2:	d008      	beq.n	80026c6 <HAL_I2C_EV_IRQHandler+0x35a>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80026b4:	6859      	ldr	r1, [r3, #4]
 80026b6:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 80026ba:	6059      	str	r1, [r3, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80026bc:	2311      	movs	r3, #17
 80026be:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80026c0:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
 80026c4:	e6a2      	b.n	800240c <HAL_I2C_EV_IRQHandler+0xa0>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80026c6:	685a      	ldr	r2, [r3, #4]
 80026c8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80026cc:	605a      	str	r2, [r3, #4]
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80026ce:	681a      	ldr	r2, [r3, #0]
 80026d0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80026d4:	601a      	str	r2, [r3, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 80026d6:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 80026d8:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 80026da:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 80026dc:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
        if(hi2c->Mode == HAL_I2C_MODE_MEM)
 80026e0:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
          hi2c->Mode = HAL_I2C_MODE_NONE;
 80026e4:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        if(hi2c->Mode == HAL_I2C_MODE_MEM)
 80026e8:	2a40      	cmp	r2, #64	; 0x40
 80026ea:	f47f ae92 	bne.w	8002412 <HAL_I2C_EV_IRQHandler+0xa6>
          HAL_I2C_MemTxCpltCallback(hi2c);
 80026ee:	f7ff fda5 	bl	800223c <HAL_I2C_MemTxCpltCallback>
 80026f2:	e788      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 80026f4:	4d90      	ldr	r5, [pc, #576]	; (8002938 <HAL_I2C_EV_IRQHandler+0x5cc>)
 80026f6:	400d      	ands	r5, r1
 80026f8:	2d00      	cmp	r5, #0
 80026fa:	d041      	beq.n	8002780 <HAL_I2C_EV_IRQHandler+0x414>
 80026fc:	0551      	lsls	r1, r2, #21
 80026fe:	d53f      	bpl.n	8002780 <HAL_I2C_EV_IRQHandler+0x414>
 8002700:	2c00      	cmp	r4, #0
 8002702:	d13d      	bne.n	8002780 <HAL_I2C_EV_IRQHandler+0x414>
  if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8002704:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 8002708:	2a22      	cmp	r2, #34	; 0x22
 800270a:	f47f af7c 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    tmp = hi2c->XferCount;
 800270e:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8002710:	b292      	uxth	r2, r2
    if(tmp > 3U)
 8002712:	2a03      	cmp	r2, #3
 8002714:	d913      	bls.n	800273e <HAL_I2C_EV_IRQHandler+0x3d2>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8002716:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8002718:	691b      	ldr	r3, [r3, #16]
 800271a:	1c51      	adds	r1, r2, #1
 800271c:	6241      	str	r1, [r0, #36]	; 0x24
 800271e:	7013      	strb	r3, [r2, #0]
      hi2c->XferCount--;
 8002720:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8002722:	3b01      	subs	r3, #1
 8002724:	b29b      	uxth	r3, r3
 8002726:	8543      	strh	r3, [r0, #42]	; 0x2a
      if(hi2c->XferCount == 3)
 8002728:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 800272a:	b29b      	uxth	r3, r3
 800272c:	2b03      	cmp	r3, #3
 800272e:	f47f af6a 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8002732:	6802      	ldr	r2, [r0, #0]
 8002734:	6853      	ldr	r3, [r2, #4]
 8002736:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800273a:	6053      	str	r3, [r2, #4]
 800273c:	e763      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    else if((tmp == 1U) || (tmp == 0U))
 800273e:	2a01      	cmp	r2, #1
 8002740:	f63f af61 	bhi.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002744:	681a      	ldr	r2, [r3, #0]
 8002746:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800274a:	601a      	str	r2, [r3, #0]
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800274c:	685a      	ldr	r2, [r3, #4]
 800274e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8002752:	605a      	str	r2, [r3, #4]
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8002754:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8002756:	691b      	ldr	r3, [r3, #16]
 8002758:	1c51      	adds	r1, r2, #1
 800275a:	6241      	str	r1, [r0, #36]	; 0x24
 800275c:	7013      	strb	r3, [r2, #0]
      hi2c->XferCount--;
 800275e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8002760:	3b01      	subs	r3, #1
 8002762:	b29b      	uxth	r3, r3
 8002764:	8543      	strh	r3, [r0, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
 8002766:	2320      	movs	r3, #32
 8002768:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      hi2c->PreviousState = I2C_STATE_NONE;
 800276c:	6304      	str	r4, [r0, #48]	; 0x30
      if(hi2c->Mode == HAL_I2C_MODE_MEM)
 800276e:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8002772:	f880 403e 	strb.w	r4, [r0, #62]	; 0x3e
      if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8002776:	2b40      	cmp	r3, #64	; 0x40
    if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8002778:	d158      	bne.n	800282c <HAL_I2C_EV_IRQHandler+0x4c0>
      HAL_I2C_MemRxCpltCallback(hi2c);
 800277a:	f7ff fd60 	bl	800223e <HAL_I2C_MemRxCpltCallback>
 800277e:	e742      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8002780:	2c00      	cmp	r4, #0
 8002782:	f43f af40 	beq.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 8002786:	0597      	lsls	r7, r2, #22
 8002788:	f57f af3d 	bpl.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 800278c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  if(hi2c->XferCount == 4U)
 800278e:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8002790:	b292      	uxth	r2, r2
 8002792:	2a04      	cmp	r2, #4
 8002794:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8002796:	d108      	bne.n	80027aa <HAL_I2C_EV_IRQHandler+0x43e>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8002798:	6859      	ldr	r1, [r3, #4]
 800279a:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 800279e:	6059      	str	r1, [r3, #4]
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80027a0:	1c51      	adds	r1, r2, #1
 80027a2:	691b      	ldr	r3, [r3, #16]
 80027a4:	6241      	str	r1, [r0, #36]	; 0x24
 80027a6:	7013      	strb	r3, [r2, #0]
 80027a8:	e76b      	b.n	8002682 <HAL_I2C_EV_IRQHandler+0x316>
  else if(hi2c->XferCount == 3U)
 80027aa:	8d44      	ldrh	r4, [r0, #42]	; 0x2a
 80027ac:	b2a4      	uxth	r4, r4
 80027ae:	2c03      	cmp	r4, #3
 80027b0:	d108      	bne.n	80027c4 <HAL_I2C_EV_IRQHandler+0x458>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 80027b2:	6859      	ldr	r1, [r3, #4]
 80027b4:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80027b8:	6059      	str	r1, [r3, #4]
    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80027ba:	6819      	ldr	r1, [r3, #0]
 80027bc:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80027c0:	6019      	str	r1, [r3, #0]
 80027c2:	e7ed      	b.n	80027a0 <HAL_I2C_EV_IRQHandler+0x434>
  else if(hi2c->XferCount == 2U)
 80027c4:	8d44      	ldrh	r4, [r0, #42]	; 0x2a
 80027c6:	b2a4      	uxth	r4, r4
 80027c8:	2c02      	cmp	r4, #2
 80027ca:	d1e9      	bne.n	80027a0 <HAL_I2C_EV_IRQHandler+0x434>
    if((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME))
 80027cc:	3901      	subs	r1, #1
 80027ce:	2901      	cmp	r1, #1
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80027d0:	6819      	ldr	r1, [r3, #0]
 80027d2:	bf9d      	ittte	ls
 80027d4:	f421 6180 	bicls.w	r1, r1, #1024	; 0x400
 80027d8:	6019      	strls	r1, [r3, #0]
      hi2c->Instance->CR1 |= I2C_CR1_START;
 80027da:	6819      	ldrls	r1, [r3, #0]
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80027dc:	f441 7100 	orrhi.w	r1, r1, #512	; 0x200
      hi2c->Instance->CR1 |= I2C_CR1_START;
 80027e0:	bf98      	it	ls
 80027e2:	f441 7180 	orrls.w	r1, r1, #256	; 0x100
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80027e6:	6019      	str	r1, [r3, #0]
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80027e8:	691b      	ldr	r3, [r3, #16]
 80027ea:	1c51      	adds	r1, r2, #1
 80027ec:	6241      	str	r1, [r0, #36]	; 0x24
 80027ee:	7013      	strb	r3, [r2, #0]
    hi2c->XferCount--;
 80027f0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80027f2:	3b01      	subs	r3, #1
 80027f4:	b29b      	uxth	r3, r3
 80027f6:	8543      	strh	r3, [r0, #42]	; 0x2a
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80027f8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80027fa:	1c5a      	adds	r2, r3, #1
 80027fc:	6242      	str	r2, [r0, #36]	; 0x24
 80027fe:	6802      	ldr	r2, [r0, #0]
 8002800:	6912      	ldr	r2, [r2, #16]
 8002802:	701a      	strb	r2, [r3, #0]
    hi2c->XferCount--;
 8002804:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 8002806:	6802      	ldr	r2, [r0, #0]
    hi2c->XferCount--;
 8002808:	3b01      	subs	r3, #1
 800280a:	b29b      	uxth	r3, r3
 800280c:	8543      	strh	r3, [r0, #42]	; 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 800280e:	6853      	ldr	r3, [r2, #4]
 8002810:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002814:	6053      	str	r3, [r2, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8002816:	2320      	movs	r3, #32
 8002818:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->PreviousState = I2C_STATE_NONE;
 800281c:	2300      	movs	r3, #0
 800281e:	6303      	str	r3, [r0, #48]	; 0x30
    if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8002820:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002824:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8002828:	2a40      	cmp	r2, #64	; 0x40
 800282a:	e7a5      	b.n	8002778 <HAL_I2C_EV_IRQHandler+0x40c>
      HAL_I2C_MasterRxCpltCallback(hi2c);
 800282c:	f7ff fd01 	bl	8002232 <HAL_I2C_MasterRxCpltCallback>
 8002830:	e6e9      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8002832:	4c42      	ldr	r4, [pc, #264]	; (800293c <HAL_I2C_EV_IRQHandler+0x5d0>)
 8002834:	400c      	ands	r4, r1
 8002836:	b174      	cbz	r4, 8002856 <HAL_I2C_EV_IRQHandler+0x4ea>
 8002838:	0596      	lsls	r6, r2, #22
 800283a:	d50c      	bpl.n	8002856 <HAL_I2C_EV_IRQHandler+0x4ea>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == RESET)
 800283c:	6999      	ldr	r1, [r3, #24]
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_DUALF) == RESET)
 800283e:	699b      	ldr	r3, [r3, #24]
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == RESET)
 8002840:	f081 0104 	eor.w	r1, r1, #4
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_DUALF) == RESET)
 8002844:	061d      	lsls	r5, r3, #24
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 8002846:	f3c1 0180 	ubfx	r1, r1, #2, #1
    SlaveAddrCode = hi2c->Init.OwnAddress1;
 800284a:	bf54      	ite	pl
 800284c:	8982      	ldrhpl	r2, [r0, #12]
    SlaveAddrCode = hi2c->Init.OwnAddress2;
 800284e:	8b02      	ldrhmi	r2, [r0, #24]
  HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 8002850:	f7ff fcf2 	bl	8002238 <HAL_I2C_AddrCallback>
 8002854:	e6d7      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    else if(((sr1itflags & I2C_FLAG_STOPF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8002856:	4c3a      	ldr	r4, [pc, #232]	; (8002940 <HAL_I2C_EV_IRQHandler+0x5d4>)
 8002858:	400c      	ands	r4, r1
 800285a:	2c00      	cmp	r4, #0
 800285c:	d074      	beq.n	8002948 <HAL_I2C_EV_IRQHandler+0x5dc>
 800285e:	0594      	lsls	r4, r2, #22
 8002860:	d572      	bpl.n	8002948 <HAL_I2C_EV_IRQHandler+0x5dc>
  uint32_t CurrentState = hi2c->State;
 8002862:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8002866:	6859      	ldr	r1, [r3, #4]
 8002868:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 800286c:	6059      	str	r1, [r3, #4]
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 800286e:	2100      	movs	r1, #0
 8002870:	910b      	str	r1, [sp, #44]	; 0x2c
 8002872:	6959      	ldr	r1, [r3, #20]
 8002874:	910b      	str	r1, [sp, #44]	; 0x2c
 8002876:	6819      	ldr	r1, [r3, #0]
 8002878:	f041 0101 	orr.w	r1, r1, #1
 800287c:	6019      	str	r1, [r3, #0]
 800287e:	990b      	ldr	r1, [sp, #44]	; 0x2c
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002880:	6819      	ldr	r1, [r3, #0]
 8002882:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8002886:	6019      	str	r1, [r3, #0]
  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8002888:	6859      	ldr	r1, [r3, #4]
 800288a:	0509      	lsls	r1, r1, #20
  uint32_t CurrentState = hi2c->State;
 800288c:	b2d2      	uxtb	r2, r2
  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 800288e:	d50c      	bpl.n	80028aa <HAL_I2C_EV_IRQHandler+0x53e>
    if((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8002890:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 8002894:	2922      	cmp	r1, #34	; 0x22
 8002896:	d003      	beq.n	80028a0 <HAL_I2C_EV_IRQHandler+0x534>
 8002898:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 800289c:	292a      	cmp	r1, #42	; 0x2a
 800289e:	d129      	bne.n	80028f4 <HAL_I2C_EV_IRQHandler+0x588>
      hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmarx);
 80028a0:	6b81      	ldr	r1, [r0, #56]	; 0x38
      hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmatx);
 80028a2:	6809      	ldr	r1, [r1, #0]
 80028a4:	6849      	ldr	r1, [r1, #4]
 80028a6:	b289      	uxth	r1, r1
 80028a8:	8541      	strh	r1, [r0, #42]	; 0x2a
  if(hi2c->XferCount != 0U)
 80028aa:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
 80028ac:	b289      	uxth	r1, r1
 80028ae:	b1e1      	cbz	r1, 80028ea <HAL_I2C_EV_IRQHandler+0x57e>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 80028b0:	6959      	ldr	r1, [r3, #20]
 80028b2:	074f      	lsls	r7, r1, #29
 80028b4:	d508      	bpl.n	80028c8 <HAL_I2C_EV_IRQHandler+0x55c>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80028b6:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80028b8:	691b      	ldr	r3, [r3, #16]
 80028ba:	1c4c      	adds	r4, r1, #1
 80028bc:	6244      	str	r4, [r0, #36]	; 0x24
 80028be:	700b      	strb	r3, [r1, #0]
      hi2c->XferCount--;
 80028c0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80028c2:	3b01      	subs	r3, #1
 80028c4:	b29b      	uxth	r3, r3
 80028c6:	8543      	strh	r3, [r0, #42]	; 0x2a
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80028c8:	6801      	ldr	r1, [r0, #0]
 80028ca:	694b      	ldr	r3, [r1, #20]
 80028cc:	065e      	lsls	r6, r3, #25
 80028ce:	d508      	bpl.n	80028e2 <HAL_I2C_EV_IRQHandler+0x576>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80028d0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80028d2:	6909      	ldr	r1, [r1, #16]
 80028d4:	1c5c      	adds	r4, r3, #1
 80028d6:	6244      	str	r4, [r0, #36]	; 0x24
 80028d8:	7019      	strb	r1, [r3, #0]
      hi2c->XferCount--;
 80028da:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80028dc:	3b01      	subs	r3, #1
 80028de:	b29b      	uxth	r3, r3
 80028e0:	8543      	strh	r3, [r0, #42]	; 0x2a
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80028e2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80028e4:	f043 0304 	orr.w	r3, r3, #4
 80028e8:	6403      	str	r3, [r0, #64]	; 0x40
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80028ea:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80028ec:	b123      	cbz	r3, 80028f8 <HAL_I2C_EV_IRQHandler+0x58c>
    I2C_ITError(hi2c);
 80028ee:	f7ff fca9 	bl	8002244 <I2C_ITError>
 80028f2:	e688      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmatx);
 80028f4:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80028f6:	e7d4      	b.n	80028a2 <HAL_I2C_EV_IRQHandler+0x536>
    if((CurrentState == HAL_I2C_STATE_LISTEN ) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN) || \
 80028f8:	f1a2 0128 	sub.w	r1, r2, #40	; 0x28
 80028fc:	2902      	cmp	r1, #2
 80028fe:	d80a      	bhi.n	8002916 <HAL_I2C_EV_IRQHandler+0x5aa>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8002900:	4a10      	ldr	r2, [pc, #64]	; (8002944 <HAL_I2C_EV_IRQHandler+0x5d8>)
 8002902:	62c2      	str	r2, [r0, #44]	; 0x2c
      hi2c->State = HAL_I2C_STATE_READY;
 8002904:	2220      	movs	r2, #32
      hi2c->PreviousState = I2C_STATE_NONE;
 8002906:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8002908:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800290c:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 8002910:	f7ff fc93 	bl	800223a <HAL_I2C_ListenCpltCallback>
 8002914:	e677      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      if((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 8002916:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002918:	2b22      	cmp	r3, #34	; 0x22
 800291a:	d002      	beq.n	8002922 <HAL_I2C_EV_IRQHandler+0x5b6>
 800291c:	2a22      	cmp	r2, #34	; 0x22
 800291e:	f47f ae72 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
        hi2c->PreviousState = I2C_STATE_NONE;
 8002922:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 8002924:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8002926:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8002928:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800292c:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 8002930:	f7ff fc81 	bl	8002236 <HAL_I2C_SlaveRxCpltCallback>
 8002934:	e667      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 8002936:	bf00      	nop
 8002938:	00010040 	.word	0x00010040
 800293c:	00010002 	.word	0x00010002
 8002940:	00010010 	.word	0x00010010
 8002944:	ffff0000 	.word	0xffff0000
    else if((sr2itflags & I2C_FLAG_TRA) != RESET)
 8002948:	4e39      	ldr	r6, [pc, #228]	; (8002a30 <HAL_I2C_EV_IRQHandler+0x6c4>)
 800294a:	4c3a      	ldr	r4, [pc, #232]	; (8002a34 <HAL_I2C_EV_IRQHandler+0x6c8>)
 800294c:	402e      	ands	r6, r5
 800294e:	400c      	ands	r4, r1
 8002950:	2e00      	cmp	r6, #0
 8002952:	d036      	beq.n	80029c2 <HAL_I2C_EV_IRQHandler+0x656>
      if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 8002954:	4d38      	ldr	r5, [pc, #224]	; (8002a38 <HAL_I2C_EV_IRQHandler+0x6cc>)
 8002956:	400d      	ands	r5, r1
 8002958:	b33d      	cbz	r5, 80029aa <HAL_I2C_EV_IRQHandler+0x63e>
 800295a:	0555      	lsls	r5, r2, #21
 800295c:	d525      	bpl.n	80029aa <HAL_I2C_EV_IRQHandler+0x63e>
 800295e:	bb24      	cbnz	r4, 80029aa <HAL_I2C_EV_IRQHandler+0x63e>
  uint32_t CurrentState = hi2c->State;
 8002960:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
  if(hi2c->XferCount != 0U)
 8002964:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8002966:	b292      	uxth	r2, r2
  uint32_t CurrentState = hi2c->State;
 8002968:	b2c9      	uxtb	r1, r1
  if(hi2c->XferCount != 0U)
 800296a:	2a00      	cmp	r2, #0
 800296c:	f43f ae4b 	beq.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 8002970:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8002972:	1c54      	adds	r4, r2, #1
 8002974:	6244      	str	r4, [r0, #36]	; 0x24
 8002976:	7812      	ldrb	r2, [r2, #0]
 8002978:	611a      	str	r2, [r3, #16]
    hi2c->XferCount--;
 800297a:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 800297c:	3a01      	subs	r2, #1
 800297e:	b292      	uxth	r2, r2
 8002980:	8542      	strh	r2, [r0, #42]	; 0x2a
    if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8002982:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8002984:	b292      	uxth	r2, r2
 8002986:	2a00      	cmp	r2, #0
 8002988:	f47f ae3d 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 800298c:	2929      	cmp	r1, #41	; 0x29
 800298e:	f47f ae3a 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8002992:	685a      	ldr	r2, [r3, #4]
 8002994:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002998:	605a      	str	r2, [r3, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800299a:	2321      	movs	r3, #33	; 0x21
 800299c:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 800299e:	2328      	movs	r3, #40	; 0x28
 80029a0:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 80029a4:	f7ff fc46 	bl	8002234 <HAL_I2C_SlaveTxCpltCallback>
 80029a8:	e62d      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 80029aa:	2c00      	cmp	r4, #0
 80029ac:	f43f ae2b 	beq.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 80029b0:	0594      	lsls	r4, r2, #22
 80029b2:	f57f ae28 	bpl.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
  if(hi2c->XferCount != 0U)
 80029b6:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80029b8:	b292      	uxth	r2, r2
 80029ba:	2a00      	cmp	r2, #0
 80029bc:	f47f ae5c 	bne.w	8002678 <HAL_I2C_EV_IRQHandler+0x30c>
 80029c0:	e621      	b.n	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 80029c2:	4d1e      	ldr	r5, [pc, #120]	; (8002a3c <HAL_I2C_EV_IRQHandler+0x6d0>)
 80029c4:	400d      	ands	r5, r1
 80029c6:	b335      	cbz	r5, 8002a16 <HAL_I2C_EV_IRQHandler+0x6aa>
 80029c8:	0551      	lsls	r1, r2, #21
 80029ca:	d524      	bpl.n	8002a16 <HAL_I2C_EV_IRQHandler+0x6aa>
 80029cc:	bb1c      	cbnz	r4, 8002a16 <HAL_I2C_EV_IRQHandler+0x6aa>
  uint32_t CurrentState = hi2c->State;
 80029ce:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  if(hi2c->XferCount != 0U)
 80029d2:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
 80029d4:	b289      	uxth	r1, r1
  uint32_t CurrentState = hi2c->State;
 80029d6:	b2d2      	uxtb	r2, r2
  if(hi2c->XferCount != 0U)
 80029d8:	2900      	cmp	r1, #0
 80029da:	f43f ae14 	beq.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80029de:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80029e0:	691b      	ldr	r3, [r3, #16]
 80029e2:	1c4c      	adds	r4, r1, #1
 80029e4:	6244      	str	r4, [r0, #36]	; 0x24
 80029e6:	700b      	strb	r3, [r1, #0]
    hi2c->XferCount--;
 80029e8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80029ea:	3b01      	subs	r3, #1
 80029ec:	b29b      	uxth	r3, r3
 80029ee:	8543      	strh	r3, [r0, #42]	; 0x2a
    if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 80029f0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80029f2:	b29b      	uxth	r3, r3
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	f47f ae06 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 80029fa:	2a2a      	cmp	r2, #42	; 0x2a
 80029fc:	f47f ae03 	bne.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8002a00:	6802      	ldr	r2, [r0, #0]
 8002a02:	6853      	ldr	r3, [r2, #4]
 8002a04:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002a08:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8002a0a:	2322      	movs	r3, #34	; 0x22
 8002a0c:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8002a0e:	2328      	movs	r3, #40	; 0x28
 8002a10:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
 8002a14:	e78c      	b.n	8002930 <HAL_I2C_EV_IRQHandler+0x5c4>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8002a16:	2c00      	cmp	r4, #0
 8002a18:	f43f adf5 	beq.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
 8002a1c:	0592      	lsls	r2, r2, #22
 8002a1e:	f57f adf2 	bpl.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
  if(hi2c->XferCount != 0U)
 8002a22:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8002a24:	b292      	uxth	r2, r2
 8002a26:	2a00      	cmp	r2, #0
 8002a28:	f43f aded 	beq.w	8002606 <HAL_I2C_EV_IRQHandler+0x29a>
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8002a2c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8002a2e:	e6b7      	b.n	80027a0 <HAL_I2C_EV_IRQHandler+0x434>
 8002a30:	00100004 	.word	0x00100004
 8002a34:	00010004 	.word	0x00010004
 8002a38:	00010080 	.word	0x00010080
 8002a3c:	00010040 	.word	0x00010040

08002a40 <HAL_I2C_ER_IRQHandler>:
{
 8002a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8002a42:	6803      	ldr	r3, [r0, #0]
  if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8002a44:	4a49      	ldr	r2, [pc, #292]	; (8002b6c <HAL_I2C_ER_IRQHandler+0x12c>)
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8002a46:	695e      	ldr	r6, [r3, #20]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 8002a48:	685d      	ldr	r5, [r3, #4]
  if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8002a4a:	4216      	tst	r6, r2
{
 8002a4c:	4604      	mov	r4, r0
  if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8002a4e:	d008      	beq.n	8002a62 <HAL_I2C_ER_IRQHandler+0x22>
 8002a50:	05e8      	lsls	r0, r5, #23
 8002a52:	d506      	bpl.n	8002a62 <HAL_I2C_ER_IRQHandler+0x22>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8002a54:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002a56:	f042 0201 	orr.w	r2, r2, #1
 8002a5a:	6422      	str	r2, [r4, #64]	; 0x40
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8002a5c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8002a60:	615a      	str	r2, [r3, #20]
  if(((sr1itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8002a62:	f416 3f81 	tst.w	r6, #66048	; 0x10200
 8002a66:	d008      	beq.n	8002a7a <HAL_I2C_ER_IRQHandler+0x3a>
 8002a68:	05e9      	lsls	r1, r5, #23
 8002a6a:	d506      	bpl.n	8002a7a <HAL_I2C_ER_IRQHandler+0x3a>
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8002a6c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002a6e:	f042 0202 	orr.w	r2, r2, #2
 8002a72:	6422      	str	r2, [r4, #64]	; 0x40
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8002a74:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8002a78:	615a      	str	r2, [r3, #20]
  if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8002a7a:	f416 3f82 	tst.w	r6, #66560	; 0x10400
 8002a7e:	d036      	beq.n	8002aee <HAL_I2C_ER_IRQHandler+0xae>
 8002a80:	05ea      	lsls	r2, r5, #23
 8002a82:	d534      	bpl.n	8002aee <HAL_I2C_ER_IRQHandler+0xae>
    tmp1 = hi2c->Mode;
 8002a84:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
    tmp2 = hi2c->XferCount;
 8002a88:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    tmp3 = hi2c->State;
 8002a8a:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
    tmp4 = hi2c->PreviousState;
 8002a8e:	6b20      	ldr	r0, [r4, #48]	; 0x30
    if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8002a90:	2f20      	cmp	r7, #32
    tmp2 = hi2c->XferCount;
 8002a92:	b289      	uxth	r1, r1
    tmp3 = hi2c->State;
 8002a94:	b2d2      	uxtb	r2, r2
    if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8002a96:	d158      	bne.n	8002b4a <HAL_I2C_ER_IRQHandler+0x10a>
 8002a98:	2900      	cmp	r1, #0
 8002a9a:	d156      	bne.n	8002b4a <HAL_I2C_ER_IRQHandler+0x10a>
 8002a9c:	f002 01f7 	and.w	r1, r2, #247	; 0xf7
 8002aa0:	2921      	cmp	r1, #33	; 0x21
 8002aa2:	d003      	beq.n	8002aac <HAL_I2C_ER_IRQHandler+0x6c>
      ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 8002aa4:	2a28      	cmp	r2, #40	; 0x28
 8002aa6:	d150      	bne.n	8002b4a <HAL_I2C_ER_IRQHandler+0x10a>
      ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 8002aa8:	2821      	cmp	r0, #33	; 0x21
 8002aaa:	d14e      	bne.n	8002b4a <HAL_I2C_ER_IRQHandler+0x10a>
  uint32_t CurrentState       = hi2c->State;
 8002aac:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8002ab0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  if(((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 8002ab2:	2904      	cmp	r1, #4
  uint32_t CurrentState       = hi2c->State;
 8002ab4:	b2d2      	uxtb	r2, r2
  if(((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 8002ab6:	d001      	beq.n	8002abc <HAL_I2C_ER_IRQHandler+0x7c>
 8002ab8:	2908      	cmp	r1, #8
 8002aba:	d12c      	bne.n	8002b16 <HAL_I2C_ER_IRQHandler+0xd6>
 8002abc:	2a28      	cmp	r2, #40	; 0x28
 8002abe:	d12a      	bne.n	8002b16 <HAL_I2C_ER_IRQHandler+0xd6>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8002ac0:	4a2b      	ldr	r2, [pc, #172]	; (8002b70 <HAL_I2C_ER_IRQHandler+0x130>)
 8002ac2:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8002ac4:	685a      	ldr	r2, [r3, #4]
 8002ac6:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8002aca:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002acc:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8002ad0:	615a      	str	r2, [r3, #20]
    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002ad2:	681a      	ldr	r2, [r3, #0]
 8002ad4:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002ad8:	601a      	str	r2, [r3, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 8002ada:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8002adc:	2220      	movs	r2, #32
    hi2c->PreviousState = I2C_STATE_NONE;
 8002ade:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
 8002ae0:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8002ae2:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002ae6:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 8002aea:	f7ff fba6 	bl	800223a <HAL_I2C_ListenCpltCallback>
  if(((sr1itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8002aee:	f416 3f84 	tst.w	r6, #67584	; 0x10800
 8002af2:	d009      	beq.n	8002b08 <HAL_I2C_ER_IRQHandler+0xc8>
 8002af4:	05eb      	lsls	r3, r5, #23
 8002af6:	d507      	bpl.n	8002b08 <HAL_I2C_ER_IRQHandler+0xc8>
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8002af8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002afa:	f043 0308 	orr.w	r3, r3, #8
 8002afe:	6423      	str	r3, [r4, #64]	; 0x40
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8002b00:	6823      	ldr	r3, [r4, #0]
 8002b02:	f46f 6200 	mvn.w	r2, #2048	; 0x800
 8002b06:	615a      	str	r2, [r3, #20]
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8002b08:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002b0a:	b373      	cbz	r3, 8002b6a <HAL_I2C_ER_IRQHandler+0x12a>
    I2C_ITError(hi2c);
 8002b0c:	4620      	mov	r0, r4
}
 8002b0e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    I2C_ITError(hi2c);
 8002b12:	f7ff bb97 	b.w	8002244 <I2C_ITError>
  else if(CurrentState == HAL_I2C_STATE_BUSY_TX)
 8002b16:	2a21      	cmp	r2, #33	; 0x21
 8002b18:	d123      	bne.n	8002b62 <HAL_I2C_ER_IRQHandler+0x122>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8002b1a:	4915      	ldr	r1, [pc, #84]	; (8002b70 <HAL_I2C_ER_IRQHandler+0x130>)
 8002b1c:	62e1      	str	r1, [r4, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8002b1e:	6322      	str	r2, [r4, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
 8002b20:	2220      	movs	r2, #32
 8002b22:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002b26:	2200      	movs	r2, #0
 8002b28:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8002b2c:	685a      	ldr	r2, [r3, #4]
 8002b2e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8002b32:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002b34:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8002b38:	615a      	str	r2, [r3, #20]
    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002b3a:	681a      	ldr	r2, [r3, #0]
 8002b3c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002b40:	601a      	str	r2, [r3, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8002b42:	4620      	mov	r0, r4
 8002b44:	f7ff fb76 	bl	8002234 <HAL_I2C_SlaveTxCpltCallback>
 8002b48:	e7d1      	b.n	8002aee <HAL_I2C_ER_IRQHandler+0xae>
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002b4a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002b4c:	f042 0204 	orr.w	r2, r2, #4
 8002b50:	6422      	str	r2, [r4, #64]	; 0x40
      if(hi2c->Mode == HAL_I2C_MODE_MASTER)
 8002b52:	f894 203e 	ldrb.w	r2, [r4, #62]	; 0x3e
 8002b56:	2a10      	cmp	r2, #16
        SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
 8002b58:	bf02      	ittt	eq
 8002b5a:	681a      	ldreq	r2, [r3, #0]
 8002b5c:	f442 7200 	orreq.w	r2, r2, #512	; 0x200
 8002b60:	601a      	streq	r2, [r3, #0]
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002b62:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8002b66:	615a      	str	r2, [r3, #20]
 8002b68:	e7c1      	b.n	8002aee <HAL_I2C_ER_IRQHandler+0xae>
 8002b6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002b6c:	00010100 	.word	0x00010100
 8002b70:	ffff0000 	.word	0xffff0000

08002b74 <I2C_DMAAbort>:
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8002b74:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 8002b76:	b508      	push	{r3, lr}
  
  /* Disable Acknowledge */
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002b78:	6803      	ldr	r3, [r0, #0]

  hi2c->XferCount = 0U;

  /* Reset XferAbortCallback */
  hi2c->hdmatx->XferAbortCallback = NULL;
 8002b7a:	6b41      	ldr	r1, [r0, #52]	; 0x34
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002b7c:	681a      	ldr	r2, [r3, #0]
 8002b7e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002b82:	601a      	str	r2, [r3, #0]
  hi2c->XferCount = 0U;
 8002b84:	2200      	movs	r2, #0
 8002b86:	8542      	strh	r2, [r0, #42]	; 0x2a
  hi2c->hdmatx->XferAbortCallback = NULL;
 8002b88:	650a      	str	r2, [r1, #80]	; 0x50
  hi2c->hdmarx->XferAbortCallback = NULL;
 8002b8a:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8002b8c:	650a      	str	r2, [r1, #80]	; 0x50

  /* Check if come from abort from user */
  if(hi2c->State == HAL_I2C_STATE_ABORT)
 8002b8e:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 8002b92:	2960      	cmp	r1, #96	; 0x60
 8002b94:	f04f 0120 	mov.w	r1, #32
  {
    hi2c->State = HAL_I2C_STATE_READY;
 8002b98:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002b9c:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
  if(hi2c->State == HAL_I2C_STATE_ABORT)
 8002ba0:	d107      	bne.n	8002bb2 <I2C_DMAAbort+0x3e>
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002ba2:	6402      	str	r2, [r0, #64]	; 0x40

    /* Disable I2C peripheral to prevent dummy data in buffer */
    __HAL_I2C_DISABLE(hi2c);
 8002ba4:	681a      	ldr	r2, [r3, #0]
 8002ba6:	f022 0201 	bic.w	r2, r2, #1
 8002baa:	601a      	str	r2, [r3, #0]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    HAL_I2C_AbortCpltCallback(hi2c);
 8002bac:	f7ff fb49 	bl	8002242 <HAL_I2C_AbortCpltCallback>
 8002bb0:	bd08      	pop	{r3, pc}
  {
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;

    /* Disable I2C peripheral to prevent dummy data in buffer */
    __HAL_I2C_DISABLE(hi2c);
 8002bb2:	681a      	ldr	r2, [r3, #0]
 8002bb4:	f022 0201 	bic.w	r2, r2, #1
 8002bb8:	601a      	str	r2, [r3, #0]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    HAL_I2C_ErrorCallback(hi2c);
 8002bba:	f7ff fb41 	bl	8002240 <HAL_I2C_ErrorCallback>
 8002bbe:	bd08      	pop	{r3, pc}

08002bc0 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8002bc0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8002bc2:	4606      	mov	r6, r0
{ 
 8002bc4:	b08b      	sub	sp, #44	; 0x2c
  if(hpcd == NULL)
 8002bc6:	2800      	cmp	r0, #0
 8002bc8:	d064      	beq.n	8002c94 <HAL_PCD_Init+0xd4>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8002bca:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8002bcc:	4634      	mov	r4, r6
  hpcd->State = HAL_PCD_STATE_BUSY;
 8002bce:	f880 33b9 	strb.w	r3, [r0, #953]	; 0x3b9
  HAL_PCD_MspInit(hpcd);
 8002bd2:	f7fe fe25 	bl	8001820 <HAL_PCD_MspInit>
 __HAL_PCD_DISABLE(hpcd);
 8002bd6:	f854 0b10 	ldr.w	r0, [r4], #16
 8002bda:	f001 fb35 	bl	8004248 <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8002bde:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002be0:	466d      	mov	r5, sp
 8002be2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002be4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002be6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002be8:	e894 0003 	ldmia.w	r4, {r0, r1}
 8002bec:	e885 0003 	stmia.w	r5, {r0, r1}
 8002bf0:	1d37      	adds	r7, r6, #4
 8002bf2:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8002bf6:	6830      	ldr	r0, [r6, #0]
 8002bf8:	f001 faec 	bl	80041d4 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8002bfc:	2100      	movs	r1, #0
 8002bfe:	6830      	ldr	r0, [r6, #0]
 8002c00:	f001 fb28 	bl	8004254 <USB_SetCurrentMode>
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8002c04:	2100      	movs	r1, #0
 8002c06:	4633      	mov	r3, r6
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8002c08:	4632      	mov	r2, r6
 8002c0a:	f106 0410 	add.w	r4, r6, #16
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8002c0e:	2501      	movs	r5, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8002c10:	4608      	mov	r0, r1
   hpcd->IN_ep[i].num = i;
 8002c12:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 8002c16:	87d1      	strh	r1, [r2, #62]	; 0x3e
 for (i = 0U; i < 15U; i++)
 8002c18:	3101      	adds	r1, #1
 8002c1a:	290f      	cmp	r1, #15
   hpcd->IN_ep[i].is_in = 1U;
 8002c1c:	f882 5039 	strb.w	r5, [r2, #57]	; 0x39
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8002c20:	f882 003b 	strb.w	r0, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 8002c24:	6410      	str	r0, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 8002c26:	6450      	str	r0, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 8002c28:	64d0      	str	r0, [r2, #76]	; 0x4c
 8002c2a:	f102 021c 	add.w	r2, r2, #28
 for (i = 0U; i < 15U; i++)
 8002c2e:	d1f0      	bne.n	8002c12 <HAL_PCD_Init+0x52>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8002c30:	2200      	movs	r2, #0
 8002c32:	f8d6 e000 	ldr.w	lr, [r6]
   hpcd->OUT_ep[i].is_in = 0U;
 8002c36:	4611      	mov	r1, r2
   hpcd->Instance->DIEPTXF[i] = 0U;
 8002c38:	f102 0040 	add.w	r0, r2, #64	; 0x40
   hpcd->OUT_ep[i].num = i;
 8002c3c:	f883 21f8 	strb.w	r2, [r3, #504]	; 0x1f8
   hpcd->IN_ep[i].tx_fifo_num = i;
 8002c40:	87da      	strh	r2, [r3, #62]	; 0x3e
   hpcd->Instance->DIEPTXF[i] = 0U;
 8002c42:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
 for (i = 0U; i < 15U; i++)
 8002c46:	3201      	adds	r2, #1
 8002c48:	2a0f      	cmp	r2, #15
   hpcd->OUT_ep[i].is_in = 0U;
 8002c4a:	f883 11f9 	strb.w	r1, [r3, #505]	; 0x1f9
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8002c4e:	f883 11fb 	strb.w	r1, [r3, #507]	; 0x1fb
   hpcd->OUT_ep[i].maxpacket = 0U;
 8002c52:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8002c56:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
   hpcd->OUT_ep[i].xfer_len = 0U;
 8002c5a:	f8c3 120c 	str.w	r1, [r3, #524]	; 0x20c
   hpcd->Instance->DIEPTXF[i] = 0U;
 8002c5e:	6041      	str	r1, [r0, #4]
 8002c60:	f103 031c 	add.w	r3, r3, #28
 for (i = 0U; i < 15U; i++)
 8002c64:	d1e8      	bne.n	8002c38 <HAL_PCD_Init+0x78>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 8002c66:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002c68:	466d      	mov	r5, sp
 8002c6a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002c6c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002c6e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002c70:	e894 0003 	ldmia.w	r4, {r0, r1}
 8002c74:	e885 0003 	stmia.w	r5, {r0, r1}
 8002c78:	4670      	mov	r0, lr
 8002c7a:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8002c7e:	f001 fb01 	bl	8004284 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 8002c82:	2301      	movs	r3, #1
 8002c84:	f886 33b9 	strb.w	r3, [r6, #953]	; 0x3b9
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 8002c88:	6830      	ldr	r0, [r6, #0]
 8002c8a:	f001 fbc0 	bl	800440e <USB_DevDisconnect>
 return HAL_OK;
 8002c8e:	2000      	movs	r0, #0
}
 8002c90:	b00b      	add	sp, #44	; 0x2c
 8002c92:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8002c94:	2001      	movs	r0, #1
 8002c96:	e7fb      	b.n	8002c90 <HAL_PCD_Init+0xd0>

08002c98 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002c98:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8002c9c:	4604      	mov	r4, r0
 8002c9e:	b918      	cbnz	r0, 8002ca8 <HAL_RCC_OscConfig+0x10>
  {
    return HAL_ERROR;
 8002ca0:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8002ca2:	b002      	add	sp, #8
 8002ca4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002ca8:	6803      	ldr	r3, [r0, #0]
 8002caa:	07dd      	lsls	r5, r3, #31
 8002cac:	d410      	bmi.n	8002cd0 <HAL_RCC_OscConfig+0x38>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002cae:	6823      	ldr	r3, [r4, #0]
 8002cb0:	0798      	lsls	r0, r3, #30
 8002cb2:	d458      	bmi.n	8002d66 <HAL_RCC_OscConfig+0xce>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002cb4:	6823      	ldr	r3, [r4, #0]
 8002cb6:	071a      	lsls	r2, r3, #28
 8002cb8:	f100 809a 	bmi.w	8002df0 <HAL_RCC_OscConfig+0x158>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002cbc:	6823      	ldr	r3, [r4, #0]
 8002cbe:	075b      	lsls	r3, r3, #29
 8002cc0:	f100 80b8 	bmi.w	8002e34 <HAL_RCC_OscConfig+0x19c>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002cc4:	69a2      	ldr	r2, [r4, #24]
 8002cc6:	2a00      	cmp	r2, #0
 8002cc8:	f040 8119 	bne.w	8002efe <HAL_RCC_OscConfig+0x266>
  return HAL_OK;
 8002ccc:	2000      	movs	r0, #0
 8002cce:	e7e8      	b.n	8002ca2 <HAL_RCC_OscConfig+0xa>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8002cd0:	4ba6      	ldr	r3, [pc, #664]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002cd2:	689a      	ldr	r2, [r3, #8]
 8002cd4:	f002 020c 	and.w	r2, r2, #12
 8002cd8:	2a04      	cmp	r2, #4
 8002cda:	d007      	beq.n	8002cec <HAL_RCC_OscConfig+0x54>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002cdc:	689a      	ldr	r2, [r3, #8]
 8002cde:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8002ce2:	2a08      	cmp	r2, #8
 8002ce4:	d10a      	bne.n	8002cfc <HAL_RCC_OscConfig+0x64>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002ce6:	685b      	ldr	r3, [r3, #4]
 8002ce8:	0259      	lsls	r1, r3, #9
 8002cea:	d507      	bpl.n	8002cfc <HAL_RCC_OscConfig+0x64>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002cec:	4b9f      	ldr	r3, [pc, #636]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002cee:	681b      	ldr	r3, [r3, #0]
 8002cf0:	039a      	lsls	r2, r3, #14
 8002cf2:	d5dc      	bpl.n	8002cae <HAL_RCC_OscConfig+0x16>
 8002cf4:	6863      	ldr	r3, [r4, #4]
 8002cf6:	2b00      	cmp	r3, #0
 8002cf8:	d1d9      	bne.n	8002cae <HAL_RCC_OscConfig+0x16>
 8002cfa:	e7d1      	b.n	8002ca0 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002cfc:	6863      	ldr	r3, [r4, #4]
 8002cfe:	4d9b      	ldr	r5, [pc, #620]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002d00:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002d04:	d111      	bne.n	8002d2a <HAL_RCC_OscConfig+0x92>
 8002d06:	682b      	ldr	r3, [r5, #0]
 8002d08:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002d0c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8002d0e:	f7fe fde7 	bl	80018e0 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002d12:	4d96      	ldr	r5, [pc, #600]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
        tickstart = HAL_GetTick();
 8002d14:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002d16:	682b      	ldr	r3, [r5, #0]
 8002d18:	039b      	lsls	r3, r3, #14
 8002d1a:	d4c8      	bmi.n	8002cae <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002d1c:	f7fe fde0 	bl	80018e0 <HAL_GetTick>
 8002d20:	1b80      	subs	r0, r0, r6
 8002d22:	2864      	cmp	r0, #100	; 0x64
 8002d24:	d9f7      	bls.n	8002d16 <HAL_RCC_OscConfig+0x7e>
            return HAL_TIMEOUT;
 8002d26:	2003      	movs	r0, #3
 8002d28:	e7bb      	b.n	8002ca2 <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002d2a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002d2e:	d104      	bne.n	8002d3a <HAL_RCC_OscConfig+0xa2>
 8002d30:	682b      	ldr	r3, [r5, #0]
 8002d32:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8002d36:	602b      	str	r3, [r5, #0]
 8002d38:	e7e5      	b.n	8002d06 <HAL_RCC_OscConfig+0x6e>
 8002d3a:	682a      	ldr	r2, [r5, #0]
 8002d3c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002d40:	602a      	str	r2, [r5, #0]
 8002d42:	682a      	ldr	r2, [r5, #0]
 8002d44:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002d48:	602a      	str	r2, [r5, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8002d4a:	2b00      	cmp	r3, #0
 8002d4c:	d1df      	bne.n	8002d0e <HAL_RCC_OscConfig+0x76>
        tickstart = HAL_GetTick();
 8002d4e:	f7fe fdc7 	bl	80018e0 <HAL_GetTick>
 8002d52:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002d54:	682b      	ldr	r3, [r5, #0]
 8002d56:	039f      	lsls	r7, r3, #14
 8002d58:	d5a9      	bpl.n	8002cae <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002d5a:	f7fe fdc1 	bl	80018e0 <HAL_GetTick>
 8002d5e:	1b80      	subs	r0, r0, r6
 8002d60:	2864      	cmp	r0, #100	; 0x64
 8002d62:	d9f7      	bls.n	8002d54 <HAL_RCC_OscConfig+0xbc>
 8002d64:	e7df      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8002d66:	4b81      	ldr	r3, [pc, #516]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002d68:	689a      	ldr	r2, [r3, #8]
 8002d6a:	f012 0f0c 	tst.w	r2, #12
 8002d6e:	d007      	beq.n	8002d80 <HAL_RCC_OscConfig+0xe8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002d70:	689a      	ldr	r2, [r3, #8]
 8002d72:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8002d76:	2a08      	cmp	r2, #8
 8002d78:	d111      	bne.n	8002d9e <HAL_RCC_OscConfig+0x106>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002d7a:	685b      	ldr	r3, [r3, #4]
 8002d7c:	025e      	lsls	r6, r3, #9
 8002d7e:	d40e      	bmi.n	8002d9e <HAL_RCC_OscConfig+0x106>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002d80:	4b7a      	ldr	r3, [pc, #488]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002d82:	681a      	ldr	r2, [r3, #0]
 8002d84:	0795      	lsls	r5, r2, #30
 8002d86:	d502      	bpl.n	8002d8e <HAL_RCC_OscConfig+0xf6>
 8002d88:	68e2      	ldr	r2, [r4, #12]
 8002d8a:	2a01      	cmp	r2, #1
 8002d8c:	d188      	bne.n	8002ca0 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002d8e:	681a      	ldr	r2, [r3, #0]
 8002d90:	6921      	ldr	r1, [r4, #16]
 8002d92:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8002d96:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 8002d9a:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002d9c:	e78a      	b.n	8002cb4 <HAL_RCC_OscConfig+0x1c>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8002d9e:	68e2      	ldr	r2, [r4, #12]
 8002da0:	4b73      	ldr	r3, [pc, #460]	; (8002f70 <HAL_RCC_OscConfig+0x2d8>)
 8002da2:	b1b2      	cbz	r2, 8002dd2 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_ENABLE();
 8002da4:	2201      	movs	r2, #1
 8002da6:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002da8:	f7fe fd9a 	bl	80018e0 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002dac:	4d6f      	ldr	r5, [pc, #444]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
        tickstart = HAL_GetTick();
 8002dae:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002db0:	682b      	ldr	r3, [r5, #0]
 8002db2:	0798      	lsls	r0, r3, #30
 8002db4:	d507      	bpl.n	8002dc6 <HAL_RCC_OscConfig+0x12e>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002db6:	682b      	ldr	r3, [r5, #0]
 8002db8:	6922      	ldr	r2, [r4, #16]
 8002dba:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002dbe:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8002dc2:	602b      	str	r3, [r5, #0]
 8002dc4:	e776      	b.n	8002cb4 <HAL_RCC_OscConfig+0x1c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002dc6:	f7fe fd8b 	bl	80018e0 <HAL_GetTick>
 8002dca:	1b80      	subs	r0, r0, r6
 8002dcc:	2802      	cmp	r0, #2
 8002dce:	d9ef      	bls.n	8002db0 <HAL_RCC_OscConfig+0x118>
 8002dd0:	e7a9      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
        __HAL_RCC_HSI_DISABLE();
 8002dd2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002dd4:	f7fe fd84 	bl	80018e0 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002dd8:	4d64      	ldr	r5, [pc, #400]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
        tickstart = HAL_GetTick();
 8002dda:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002ddc:	682b      	ldr	r3, [r5, #0]
 8002dde:	0799      	lsls	r1, r3, #30
 8002de0:	f57f af68 	bpl.w	8002cb4 <HAL_RCC_OscConfig+0x1c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002de4:	f7fe fd7c 	bl	80018e0 <HAL_GetTick>
 8002de8:	1b80      	subs	r0, r0, r6
 8002dea:	2802      	cmp	r0, #2
 8002dec:	d9f6      	bls.n	8002ddc <HAL_RCC_OscConfig+0x144>
 8002dee:	e79a      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8002df0:	6962      	ldr	r2, [r4, #20]
 8002df2:	4b60      	ldr	r3, [pc, #384]	; (8002f74 <HAL_RCC_OscConfig+0x2dc>)
 8002df4:	b17a      	cbz	r2, 8002e16 <HAL_RCC_OscConfig+0x17e>
      __HAL_RCC_LSI_ENABLE();
 8002df6:	2201      	movs	r2, #1
 8002df8:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002dfa:	f7fe fd71 	bl	80018e0 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002dfe:	4d5b      	ldr	r5, [pc, #364]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
      tickstart = HAL_GetTick();
 8002e00:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002e02:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002e04:	079f      	lsls	r7, r3, #30
 8002e06:	f53f af59 	bmi.w	8002cbc <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002e0a:	f7fe fd69 	bl	80018e0 <HAL_GetTick>
 8002e0e:	1b80      	subs	r0, r0, r6
 8002e10:	2802      	cmp	r0, #2
 8002e12:	d9f6      	bls.n	8002e02 <HAL_RCC_OscConfig+0x16a>
 8002e14:	e787      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
      __HAL_RCC_LSI_DISABLE();
 8002e16:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002e18:	f7fe fd62 	bl	80018e0 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002e1c:	4d53      	ldr	r5, [pc, #332]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
      tickstart = HAL_GetTick();
 8002e1e:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002e20:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002e22:	0798      	lsls	r0, r3, #30
 8002e24:	f57f af4a 	bpl.w	8002cbc <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002e28:	f7fe fd5a 	bl	80018e0 <HAL_GetTick>
 8002e2c:	1b80      	subs	r0, r0, r6
 8002e2e:	2802      	cmp	r0, #2
 8002e30:	d9f6      	bls.n	8002e20 <HAL_RCC_OscConfig+0x188>
 8002e32:	e778      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002e34:	4b4d      	ldr	r3, [pc, #308]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002e36:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002e38:	f012 5280 	ands.w	r2, r2, #268435456	; 0x10000000
 8002e3c:	d128      	bne.n	8002e90 <HAL_RCC_OscConfig+0x1f8>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002e3e:	9201      	str	r2, [sp, #4]
 8002e40:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002e42:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002e46:	641a      	str	r2, [r3, #64]	; 0x40
 8002e48:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002e4a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002e4e:	9301      	str	r3, [sp, #4]
 8002e50:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002e52:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002e54:	4d48      	ldr	r5, [pc, #288]	; (8002f78 <HAL_RCC_OscConfig+0x2e0>)
 8002e56:	682b      	ldr	r3, [r5, #0]
 8002e58:	05d9      	lsls	r1, r3, #23
 8002e5a:	d51b      	bpl.n	8002e94 <HAL_RCC_OscConfig+0x1fc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002e5c:	68a3      	ldr	r3, [r4, #8]
 8002e5e:	4d43      	ldr	r5, [pc, #268]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002e60:	2b01      	cmp	r3, #1
 8002e62:	d127      	bne.n	8002eb4 <HAL_RCC_OscConfig+0x21c>
 8002e64:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002e66:	f043 0301 	orr.w	r3, r3, #1
 8002e6a:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 8002e6c:	f7fe fd38 	bl	80018e0 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002e70:	4d3e      	ldr	r5, [pc, #248]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
      tickstart = HAL_GetTick();
 8002e72:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002e74:	f241 3888 	movw	r8, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002e78:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002e7a:	079b      	lsls	r3, r3, #30
 8002e7c:	d539      	bpl.n	8002ef2 <HAL_RCC_OscConfig+0x25a>
    if(pwrclkchanged == SET)
 8002e7e:	2e00      	cmp	r6, #0
 8002e80:	f43f af20 	beq.w	8002cc4 <HAL_RCC_OscConfig+0x2c>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002e84:	4a39      	ldr	r2, [pc, #228]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002e86:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8002e88:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002e8c:	6413      	str	r3, [r2, #64]	; 0x40
 8002e8e:	e719      	b.n	8002cc4 <HAL_RCC_OscConfig+0x2c>
    FlagStatus       pwrclkchanged = RESET;
 8002e90:	2600      	movs	r6, #0
 8002e92:	e7df      	b.n	8002e54 <HAL_RCC_OscConfig+0x1bc>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002e94:	682b      	ldr	r3, [r5, #0]
 8002e96:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002e9a:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8002e9c:	f7fe fd20 	bl	80018e0 <HAL_GetTick>
 8002ea0:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002ea2:	682b      	ldr	r3, [r5, #0]
 8002ea4:	05da      	lsls	r2, r3, #23
 8002ea6:	d4d9      	bmi.n	8002e5c <HAL_RCC_OscConfig+0x1c4>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002ea8:	f7fe fd1a 	bl	80018e0 <HAL_GetTick>
 8002eac:	1bc0      	subs	r0, r0, r7
 8002eae:	2802      	cmp	r0, #2
 8002eb0:	d9f7      	bls.n	8002ea2 <HAL_RCC_OscConfig+0x20a>
 8002eb2:	e738      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002eb4:	2b05      	cmp	r3, #5
 8002eb6:	d104      	bne.n	8002ec2 <HAL_RCC_OscConfig+0x22a>
 8002eb8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002eba:	f043 0304 	orr.w	r3, r3, #4
 8002ebe:	672b      	str	r3, [r5, #112]	; 0x70
 8002ec0:	e7d0      	b.n	8002e64 <HAL_RCC_OscConfig+0x1cc>
 8002ec2:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8002ec4:	f022 0201 	bic.w	r2, r2, #1
 8002ec8:	672a      	str	r2, [r5, #112]	; 0x70
 8002eca:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8002ecc:	f022 0204 	bic.w	r2, r2, #4
 8002ed0:	672a      	str	r2, [r5, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8002ed2:	2b00      	cmp	r3, #0
 8002ed4:	d1ca      	bne.n	8002e6c <HAL_RCC_OscConfig+0x1d4>
      tickstart = HAL_GetTick();
 8002ed6:	f7fe fd03 	bl	80018e0 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002eda:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8002ede:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002ee0:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002ee2:	0798      	lsls	r0, r3, #30
 8002ee4:	d5cb      	bpl.n	8002e7e <HAL_RCC_OscConfig+0x1e6>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002ee6:	f7fe fcfb 	bl	80018e0 <HAL_GetTick>
 8002eea:	1bc0      	subs	r0, r0, r7
 8002eec:	4540      	cmp	r0, r8
 8002eee:	d9f7      	bls.n	8002ee0 <HAL_RCC_OscConfig+0x248>
 8002ef0:	e719      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002ef2:	f7fe fcf5 	bl	80018e0 <HAL_GetTick>
 8002ef6:	1bc0      	subs	r0, r0, r7
 8002ef8:	4540      	cmp	r0, r8
 8002efa:	d9bd      	bls.n	8002e78 <HAL_RCC_OscConfig+0x1e0>
 8002efc:	e713      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002efe:	4d1b      	ldr	r5, [pc, #108]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
 8002f00:	68ab      	ldr	r3, [r5, #8]
 8002f02:	f003 030c 	and.w	r3, r3, #12
 8002f06:	2b08      	cmp	r3, #8
 8002f08:	f43f aeca 	beq.w	8002ca0 <HAL_RCC_OscConfig+0x8>
 8002f0c:	4e1b      	ldr	r6, [pc, #108]	; (8002f7c <HAL_RCC_OscConfig+0x2e4>)
 8002f0e:	2300      	movs	r3, #0
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002f10:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8002f12:	6033      	str	r3, [r6, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002f14:	d134      	bne.n	8002f80 <HAL_RCC_OscConfig+0x2e8>
        tickstart = HAL_GetTick();
 8002f16:	f7fe fce3 	bl	80018e0 <HAL_GetTick>
 8002f1a:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002f1c:	682b      	ldr	r3, [r5, #0]
 8002f1e:	0199      	lsls	r1, r3, #6
 8002f20:	d41e      	bmi.n	8002f60 <HAL_RCC_OscConfig+0x2c8>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8002f22:	6a22      	ldr	r2, [r4, #32]
 8002f24:	69e3      	ldr	r3, [r4, #28]
 8002f26:	4313      	orrs	r3, r2
 8002f28:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002f2a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8002f2e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002f30:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8002f34:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002f36:	4c0d      	ldr	r4, [pc, #52]	; (8002f6c <HAL_RCC_OscConfig+0x2d4>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8002f38:	0852      	lsrs	r2, r2, #1
 8002f3a:	3a01      	subs	r2, #1
 8002f3c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8002f40:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8002f42:	2301      	movs	r3, #1
 8002f44:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8002f46:	f7fe fccb 	bl	80018e0 <HAL_GetTick>
 8002f4a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002f4c:	6823      	ldr	r3, [r4, #0]
 8002f4e:	019a      	lsls	r2, r3, #6
 8002f50:	f53f aebc 	bmi.w	8002ccc <HAL_RCC_OscConfig+0x34>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002f54:	f7fe fcc4 	bl	80018e0 <HAL_GetTick>
 8002f58:	1b40      	subs	r0, r0, r5
 8002f5a:	2802      	cmp	r0, #2
 8002f5c:	d9f6      	bls.n	8002f4c <HAL_RCC_OscConfig+0x2b4>
 8002f5e:	e6e2      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002f60:	f7fe fcbe 	bl	80018e0 <HAL_GetTick>
 8002f64:	1bc0      	subs	r0, r0, r7
 8002f66:	2802      	cmp	r0, #2
 8002f68:	d9d8      	bls.n	8002f1c <HAL_RCC_OscConfig+0x284>
 8002f6a:	e6dc      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
 8002f6c:	40023800 	.word	0x40023800
 8002f70:	42470000 	.word	0x42470000
 8002f74:	42470e80 	.word	0x42470e80
 8002f78:	40007000 	.word	0x40007000
 8002f7c:	42470060 	.word	0x42470060
        tickstart = HAL_GetTick();
 8002f80:	f7fe fcae 	bl	80018e0 <HAL_GetTick>
 8002f84:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002f86:	682b      	ldr	r3, [r5, #0]
 8002f88:	019b      	lsls	r3, r3, #6
 8002f8a:	f57f ae9f 	bpl.w	8002ccc <HAL_RCC_OscConfig+0x34>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002f8e:	f7fe fca7 	bl	80018e0 <HAL_GetTick>
 8002f92:	1b00      	subs	r0, r0, r4
 8002f94:	2802      	cmp	r0, #2
 8002f96:	d9f6      	bls.n	8002f86 <HAL_RCC_OscConfig+0x2ee>
 8002f98:	e6c5      	b.n	8002d26 <HAL_RCC_OscConfig+0x8e>
 8002f9a:	bf00      	nop

08002f9c <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002f9c:	4913      	ldr	r1, [pc, #76]	; (8002fec <HAL_RCC_GetSysClockFreq+0x50>)
{
 8002f9e:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002fa0:	688b      	ldr	r3, [r1, #8]
 8002fa2:	f003 030c 	and.w	r3, r3, #12
 8002fa6:	2b04      	cmp	r3, #4
 8002fa8:	d003      	beq.n	8002fb2 <HAL_RCC_GetSysClockFreq+0x16>
 8002faa:	2b08      	cmp	r3, #8
 8002fac:	d003      	beq.n	8002fb6 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8002fae:	4810      	ldr	r0, [pc, #64]	; (8002ff0 <HAL_RCC_GetSysClockFreq+0x54>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002fb0:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 8002fb2:	4810      	ldr	r0, [pc, #64]	; (8002ff4 <HAL_RCC_GetSysClockFreq+0x58>)
 8002fb4:	bd08      	pop	{r3, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002fb6:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002fb8:	684b      	ldr	r3, [r1, #4]
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002fba:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002fbc:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002fc0:	bf14      	ite	ne
 8002fc2:	480c      	ldrne	r0, [pc, #48]	; (8002ff4 <HAL_RCC_GetSysClockFreq+0x58>)
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002fc4:	480a      	ldreq	r0, [pc, #40]	; (8002ff0 <HAL_RCC_GetSysClockFreq+0x54>)
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002fc6:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8002fca:	bf18      	it	ne
 8002fcc:	2300      	movne	r3, #0
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002fce:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002fd2:	fba1 0100 	umull	r0, r1, r1, r0
 8002fd6:	f7fd f903 	bl	80001e0 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8002fda:	4b04      	ldr	r3, [pc, #16]	; (8002fec <HAL_RCC_GetSysClockFreq+0x50>)
 8002fdc:	685b      	ldr	r3, [r3, #4]
 8002fde:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8002fe2:	3301      	adds	r3, #1
 8002fe4:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8002fe6:	fbb0 f0f3 	udiv	r0, r0, r3
 8002fea:	bd08      	pop	{r3, pc}
 8002fec:	40023800 	.word	0x40023800
 8002ff0:	00f42400 	.word	0x00f42400
 8002ff4:	007a1200 	.word	0x007a1200

08002ff8 <HAL_RCC_ClockConfig>:
{
 8002ff8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002ffc:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 8002ffe:	4604      	mov	r4, r0
 8003000:	b910      	cbnz	r0, 8003008 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8003002:	2001      	movs	r0, #1
 8003004:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003008:	4b44      	ldr	r3, [pc, #272]	; (800311c <HAL_RCC_ClockConfig+0x124>)
 800300a:	681a      	ldr	r2, [r3, #0]
 800300c:	f002 020f 	and.w	r2, r2, #15
 8003010:	428a      	cmp	r2, r1
 8003012:	d328      	bcc.n	8003066 <HAL_RCC_ClockConfig+0x6e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003014:	6821      	ldr	r1, [r4, #0]
 8003016:	078f      	lsls	r7, r1, #30
 8003018:	d42d      	bmi.n	8003076 <HAL_RCC_ClockConfig+0x7e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800301a:	07c8      	lsls	r0, r1, #31
 800301c:	d440      	bmi.n	80030a0 <HAL_RCC_ClockConfig+0xa8>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800301e:	4b3f      	ldr	r3, [pc, #252]	; (800311c <HAL_RCC_ClockConfig+0x124>)
 8003020:	681a      	ldr	r2, [r3, #0]
 8003022:	f002 020f 	and.w	r2, r2, #15
 8003026:	4295      	cmp	r5, r2
 8003028:	d366      	bcc.n	80030f8 <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800302a:	6822      	ldr	r2, [r4, #0]
 800302c:	0751      	lsls	r1, r2, #29
 800302e:	d46c      	bmi.n	800310a <HAL_RCC_ClockConfig+0x112>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003030:	0713      	lsls	r3, r2, #28
 8003032:	d507      	bpl.n	8003044 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8003034:	4a3a      	ldr	r2, [pc, #232]	; (8003120 <HAL_RCC_ClockConfig+0x128>)
 8003036:	6921      	ldr	r1, [r4, #16]
 8003038:	6893      	ldr	r3, [r2, #8]
 800303a:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800303e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8003042:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003044:	f7ff ffaa 	bl	8002f9c <HAL_RCC_GetSysClockFreq>
 8003048:	4b35      	ldr	r3, [pc, #212]	; (8003120 <HAL_RCC_ClockConfig+0x128>)
 800304a:	4a36      	ldr	r2, [pc, #216]	; (8003124 <HAL_RCC_ClockConfig+0x12c>)
 800304c:	689b      	ldr	r3, [r3, #8]
 800304e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8003052:	5cd3      	ldrb	r3, [r2, r3]
 8003054:	40d8      	lsrs	r0, r3
 8003056:	4b34      	ldr	r3, [pc, #208]	; (8003128 <HAL_RCC_ClockConfig+0x130>)
 8003058:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800305a:	2000      	movs	r0, #0
 800305c:	f7fd feb4 	bl	8000dc8 <HAL_InitTick>
  return HAL_OK;
 8003060:	2000      	movs	r0, #0
 8003062:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003066:	b2ca      	uxtb	r2, r1
 8003068:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800306a:	681b      	ldr	r3, [r3, #0]
 800306c:	f003 030f 	and.w	r3, r3, #15
 8003070:	4299      	cmp	r1, r3
 8003072:	d1c6      	bne.n	8003002 <HAL_RCC_ClockConfig+0xa>
 8003074:	e7ce      	b.n	8003014 <HAL_RCC_ClockConfig+0x1c>
 8003076:	4b2a      	ldr	r3, [pc, #168]	; (8003120 <HAL_RCC_ClockConfig+0x128>)
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003078:	f011 0f04 	tst.w	r1, #4
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800307c:	bf1e      	ittt	ne
 800307e:	689a      	ldrne	r2, [r3, #8]
 8003080:	f442 52e0 	orrne.w	r2, r2, #7168	; 0x1c00
 8003084:	609a      	strne	r2, [r3, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003086:	070e      	lsls	r6, r1, #28
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8003088:	bf42      	ittt	mi
 800308a:	689a      	ldrmi	r2, [r3, #8]
 800308c:	f442 4260 	orrmi.w	r2, r2, #57344	; 0xe000
 8003090:	609a      	strmi	r2, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003092:	689a      	ldr	r2, [r3, #8]
 8003094:	68a0      	ldr	r0, [r4, #8]
 8003096:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800309a:	4302      	orrs	r2, r0
 800309c:	609a      	str	r2, [r3, #8]
 800309e:	e7bc      	b.n	800301a <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80030a0:	6862      	ldr	r2, [r4, #4]
 80030a2:	4b1f      	ldr	r3, [pc, #124]	; (8003120 <HAL_RCC_ClockConfig+0x128>)
 80030a4:	2a01      	cmp	r2, #1
 80030a6:	d11d      	bne.n	80030e4 <HAL_RCC_ClockConfig+0xec>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80030a8:	681b      	ldr	r3, [r3, #0]
 80030aa:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80030ae:	d0a8      	beq.n	8003002 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80030b0:	4e1b      	ldr	r6, [pc, #108]	; (8003120 <HAL_RCC_ClockConfig+0x128>)
 80030b2:	68b3      	ldr	r3, [r6, #8]
 80030b4:	f023 0303 	bic.w	r3, r3, #3
 80030b8:	4313      	orrs	r3, r2
 80030ba:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80030bc:	f7fe fc10 	bl	80018e0 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80030c0:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80030c4:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80030c6:	68b3      	ldr	r3, [r6, #8]
 80030c8:	6862      	ldr	r2, [r4, #4]
 80030ca:	f003 030c 	and.w	r3, r3, #12
 80030ce:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80030d2:	d0a4      	beq.n	800301e <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80030d4:	f7fe fc04 	bl	80018e0 <HAL_GetTick>
 80030d8:	1bc0      	subs	r0, r0, r7
 80030da:	4540      	cmp	r0, r8
 80030dc:	d9f3      	bls.n	80030c6 <HAL_RCC_ClockConfig+0xce>
        return HAL_TIMEOUT;
 80030de:	2003      	movs	r0, #3
}
 80030e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80030e4:	1e91      	subs	r1, r2, #2
 80030e6:	2901      	cmp	r1, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80030e8:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80030ea:	d802      	bhi.n	80030f2 <HAL_RCC_ClockConfig+0xfa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80030ec:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80030f0:	e7dd      	b.n	80030ae <HAL_RCC_ClockConfig+0xb6>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80030f2:	f013 0f02 	tst.w	r3, #2
 80030f6:	e7da      	b.n	80030ae <HAL_RCC_ClockConfig+0xb6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80030f8:	b2ea      	uxtb	r2, r5
 80030fa:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80030fc:	681b      	ldr	r3, [r3, #0]
 80030fe:	f003 030f 	and.w	r3, r3, #15
 8003102:	429d      	cmp	r5, r3
 8003104:	f47f af7d 	bne.w	8003002 <HAL_RCC_ClockConfig+0xa>
 8003108:	e78f      	b.n	800302a <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800310a:	4905      	ldr	r1, [pc, #20]	; (8003120 <HAL_RCC_ClockConfig+0x128>)
 800310c:	68e0      	ldr	r0, [r4, #12]
 800310e:	688b      	ldr	r3, [r1, #8]
 8003110:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8003114:	4303      	orrs	r3, r0
 8003116:	608b      	str	r3, [r1, #8]
 8003118:	e78a      	b.n	8003030 <HAL_RCC_ClockConfig+0x38>
 800311a:	bf00      	nop
 800311c:	40023c00 	.word	0x40023c00
 8003120:	40023800 	.word	0x40023800
 8003124:	080066ce 	.word	0x080066ce
 8003128:	20000000 	.word	0x20000000

0800312c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800312c:	4b04      	ldr	r3, [pc, #16]	; (8003140 <HAL_RCC_GetPCLK1Freq+0x14>)
 800312e:	4a05      	ldr	r2, [pc, #20]	; (8003144 <HAL_RCC_GetPCLK1Freq+0x18>)
 8003130:	689b      	ldr	r3, [r3, #8]
 8003132:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8003136:	5cd3      	ldrb	r3, [r2, r3]
 8003138:	4a03      	ldr	r2, [pc, #12]	; (8003148 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800313a:	6810      	ldr	r0, [r2, #0]
}
 800313c:	40d8      	lsrs	r0, r3
 800313e:	4770      	bx	lr
 8003140:	40023800 	.word	0x40023800
 8003144:	080066de 	.word	0x080066de
 8003148:	20000000 	.word	0x20000000

0800314c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 800314c:	4b04      	ldr	r3, [pc, #16]	; (8003160 <HAL_RCC_GetPCLK2Freq+0x14>)
 800314e:	4a05      	ldr	r2, [pc, #20]	; (8003164 <HAL_RCC_GetPCLK2Freq+0x18>)
 8003150:	689b      	ldr	r3, [r3, #8]
 8003152:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8003156:	5cd3      	ldrb	r3, [r2, r3]
 8003158:	4a03      	ldr	r2, [pc, #12]	; (8003168 <HAL_RCC_GetPCLK2Freq+0x1c>)
 800315a:	6810      	ldr	r0, [r2, #0]
}
 800315c:	40d8      	lsrs	r0, r3
 800315e:	4770      	bx	lr
 8003160:	40023800 	.word	0x40023800
 8003164:	080066de 	.word	0x080066de
 8003168:	20000000 	.word	0x20000000

0800316c <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800316c:	230f      	movs	r3, #15
 800316e:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8003170:	4b0b      	ldr	r3, [pc, #44]	; (80031a0 <HAL_RCC_GetClockConfig+0x34>)
 8003172:	689a      	ldr	r2, [r3, #8]
 8003174:	f002 0203 	and.w	r2, r2, #3
 8003178:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 800317a:	689a      	ldr	r2, [r3, #8]
 800317c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8003180:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8003182:	689a      	ldr	r2, [r3, #8]
 8003184:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 8003188:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 800318a:	689b      	ldr	r3, [r3, #8]
 800318c:	08db      	lsrs	r3, r3, #3
 800318e:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8003192:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8003194:	4b03      	ldr	r3, [pc, #12]	; (80031a4 <HAL_RCC_GetClockConfig+0x38>)
 8003196:	681b      	ldr	r3, [r3, #0]
 8003198:	f003 030f 	and.w	r3, r3, #15
 800319c:	600b      	str	r3, [r1, #0]
 800319e:	4770      	bx	lr
 80031a0:	40023800 	.word	0x40023800
 80031a4:	40023c00 	.word	0x40023c00

080031a8 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80031a8:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80031aa:	4604      	mov	r4, r0
 80031ac:	2800      	cmp	r0, #0
 80031ae:	d036      	beq.n	800321e <HAL_SPI_Init+0x76>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80031b0:	2300      	movs	r3, #0
 80031b2:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 80031b4:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 80031b8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80031bc:	b91b      	cbnz	r3, 80031c6 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80031be:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80031c2:	f7fd fce5 	bl	8000b90 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80031c6:	6821      	ldr	r1, [r4, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80031c8:	68a0      	ldr	r0, [r4, #8]
 80031ca:	69a2      	ldr	r2, [r4, #24]
  hspi->State = HAL_SPI_STATE_BUSY;
 80031cc:	2302      	movs	r3, #2
 80031ce:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_SPI_DISABLE(hspi);
 80031d2:	680b      	ldr	r3, [r1, #0]
 80031d4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80031d8:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80031da:	6863      	ldr	r3, [r4, #4]
 80031dc:	4303      	orrs	r3, r0
 80031de:	68e0      	ldr	r0, [r4, #12]
 80031e0:	4303      	orrs	r3, r0
 80031e2:	6920      	ldr	r0, [r4, #16]
 80031e4:	4303      	orrs	r3, r0
 80031e6:	6960      	ldr	r0, [r4, #20]
 80031e8:	4303      	orrs	r3, r0
 80031ea:	69e0      	ldr	r0, [r4, #28]
 80031ec:	4303      	orrs	r3, r0
 80031ee:	6a20      	ldr	r0, [r4, #32]
 80031f0:	4303      	orrs	r3, r0
 80031f2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80031f4:	4303      	orrs	r3, r0
 80031f6:	f402 7000 	and.w	r0, r2, #512	; 0x200
 80031fa:	4303      	orrs	r3, r0
 80031fc:	600b      	str	r3, [r1, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80031fe:	0c12      	lsrs	r2, r2, #16
 8003200:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003202:	f002 0204 	and.w	r2, r2, #4
 8003206:	431a      	orrs	r2, r3
 8003208:	604a      	str	r2, [r1, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800320a:	69cb      	ldr	r3, [r1, #28]
 800320c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003210:	61cb      	str	r3, [r1, #28]
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8003212:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 8003214:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8003216:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8003218:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  return HAL_OK;
 800321c:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800321e:	2001      	movs	r0, #1
}
 8003220:	bd10      	pop	{r4, pc}

08003222 <HAL_SPI_ErrorCallback>:
 8003222:	4770      	bx	lr

08003224 <HAL_SPI_IRQHandler>:
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
  uint32_t itsource = hspi->Instance->CR2;
 8003224:	6803      	ldr	r3, [r0, #0]
{
 8003226:	b530      	push	{r4, r5, lr}
  uint32_t itsource = hspi->Instance->CR2;
 8003228:	6859      	ldr	r1, [r3, #4]
  uint32_t itflag   = hspi->Instance->SR;
 800322a:	689a      	ldr	r2, [r3, #8]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
 800322c:	f002 0541 	and.w	r5, r2, #65	; 0x41
 8003230:	2d01      	cmp	r5, #1
{
 8003232:	b085      	sub	sp, #20
 8003234:	4604      	mov	r4, r0
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
 8003236:	d105      	bne.n	8003244 <HAL_SPI_IRQHandler+0x20>
     ((itflag & SPI_FLAG_RXNE) != RESET) && ((itsource & SPI_IT_RXNE) != RESET))
 8003238:	064d      	lsls	r5, r1, #25
 800323a:	d503      	bpl.n	8003244 <HAL_SPI_IRQHandler+0x20>
  {
    hspi->RxISR(hspi);
 800323c:	6c03      	ldr	r3, [r0, #64]	; 0x40
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
  {
    hspi->TxISR(hspi);
 800323e:	4798      	blx	r3
        HAL_SPI_ErrorCallback(hspi);
      }
    }
    return;
  }
}
 8003240:	b005      	add	sp, #20
 8003242:	bd30      	pop	{r4, r5, pc}
  if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
 8003244:	0795      	lsls	r5, r2, #30
 8003246:	d504      	bpl.n	8003252 <HAL_SPI_IRQHandler+0x2e>
 8003248:	0608      	lsls	r0, r1, #24
 800324a:	d502      	bpl.n	8003252 <HAL_SPI_IRQHandler+0x2e>
    hspi->TxISR(hspi);
 800324c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800324e:	4620      	mov	r0, r4
 8003250:	e7f5      	b.n	800323e <HAL_SPI_IRQHandler+0x1a>
  if(((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET) && ((itsource & SPI_IT_ERR) != RESET))
 8003252:	f412 7fb0 	tst.w	r2, #352	; 0x160
 8003256:	d0f3      	beq.n	8003240 <HAL_SPI_IRQHandler+0x1c>
 8003258:	068d      	lsls	r5, r1, #26
 800325a:	d5f1      	bpl.n	8003240 <HAL_SPI_IRQHandler+0x1c>
    if((itflag & SPI_FLAG_OVR) != RESET)
 800325c:	0650      	lsls	r0, r2, #25
 800325e:	d50f      	bpl.n	8003280 <HAL_SPI_IRQHandler+0x5c>
      if(hspi->State != HAL_SPI_STATE_BUSY_TX)
 8003260:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 8003264:	2803      	cmp	r0, #3
 8003266:	f04f 0500 	mov.w	r5, #0
 800326a:	d041      	beq.n	80032f0 <HAL_SPI_IRQHandler+0xcc>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 800326c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800326e:	f040 0004 	orr.w	r0, r0, #4
 8003272:	6560      	str	r0, [r4, #84]	; 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8003274:	9500      	str	r5, [sp, #0]
 8003276:	68d8      	ldr	r0, [r3, #12]
 8003278:	9000      	str	r0, [sp, #0]
 800327a:	6898      	ldr	r0, [r3, #8]
 800327c:	9000      	str	r0, [sp, #0]
 800327e:	9800      	ldr	r0, [sp, #0]
    if((itflag & SPI_FLAG_MODF) != RESET)
 8003280:	0695      	lsls	r5, r2, #26
 8003282:	d50c      	bpl.n	800329e <HAL_SPI_IRQHandler+0x7a>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8003284:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8003286:	f040 0001 	orr.w	r0, r0, #1
 800328a:	6560      	str	r0, [r4, #84]	; 0x54
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800328c:	2000      	movs	r0, #0
 800328e:	9002      	str	r0, [sp, #8]
 8003290:	6898      	ldr	r0, [r3, #8]
 8003292:	9002      	str	r0, [sp, #8]
 8003294:	6818      	ldr	r0, [r3, #0]
 8003296:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800329a:	6018      	str	r0, [r3, #0]
 800329c:	9802      	ldr	r0, [sp, #8]
    if((itflag & SPI_FLAG_FRE) != RESET)
 800329e:	05d0      	lsls	r0, r2, #23
 80032a0:	d508      	bpl.n	80032b4 <HAL_SPI_IRQHandler+0x90>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 80032a2:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80032a4:	f042 0208 	orr.w	r2, r2, #8
 80032a8:	6562      	str	r2, [r4, #84]	; 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 80032aa:	2200      	movs	r2, #0
 80032ac:	9203      	str	r2, [sp, #12]
 80032ae:	689a      	ldr	r2, [r3, #8]
 80032b0:	9203      	str	r2, [sp, #12]
 80032b2:	9a03      	ldr	r2, [sp, #12]
    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80032b4:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80032b6:	2a00      	cmp	r2, #0
 80032b8:	d0c2      	beq.n	8003240 <HAL_SPI_IRQHandler+0x1c>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 80032ba:	685a      	ldr	r2, [r3, #4]
 80032bc:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80032c0:	605a      	str	r2, [r3, #4]
      hspi->State = HAL_SPI_STATE_READY;
 80032c2:	2201      	movs	r2, #1
 80032c4:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN))||(HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 80032c8:	078a      	lsls	r2, r1, #30
 80032ca:	d018      	beq.n	80032fe <HAL_SPI_IRQHandler+0xda>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 80032cc:	685a      	ldr	r2, [r3, #4]
        if(hspi->hdmarx != NULL)
 80032ce:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 80032d0:	f022 0203 	bic.w	r2, r2, #3
 80032d4:	605a      	str	r2, [r3, #4]
        if(hspi->hdmarx != NULL)
 80032d6:	b118      	cbz	r0, 80032e0 <HAL_SPI_IRQHandler+0xbc>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 80032d8:	4b0b      	ldr	r3, [pc, #44]	; (8003308 <HAL_SPI_IRQHandler+0xe4>)
 80032da:	6503      	str	r3, [r0, #80]	; 0x50
          HAL_DMA_Abort_IT(hspi->hdmarx);
 80032dc:	f7fe fd78 	bl	8001dd0 <HAL_DMA_Abort_IT>
        if(hspi->hdmatx != NULL)
 80032e0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80032e2:	2800      	cmp	r0, #0
 80032e4:	d0ac      	beq.n	8003240 <HAL_SPI_IRQHandler+0x1c>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 80032e6:	4b08      	ldr	r3, [pc, #32]	; (8003308 <HAL_SPI_IRQHandler+0xe4>)
 80032e8:	6503      	str	r3, [r0, #80]	; 0x50
          HAL_DMA_Abort_IT(hspi->hdmatx);
 80032ea:	f7fe fd71 	bl	8001dd0 <HAL_DMA_Abort_IT>
 80032ee:	e7a7      	b.n	8003240 <HAL_SPI_IRQHandler+0x1c>
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80032f0:	9501      	str	r5, [sp, #4]
 80032f2:	68da      	ldr	r2, [r3, #12]
 80032f4:	9201      	str	r2, [sp, #4]
 80032f6:	689b      	ldr	r3, [r3, #8]
 80032f8:	9301      	str	r3, [sp, #4]
 80032fa:	9b01      	ldr	r3, [sp, #4]
        return;
 80032fc:	e7a0      	b.n	8003240 <HAL_SPI_IRQHandler+0x1c>
        HAL_SPI_ErrorCallback(hspi);
 80032fe:	4620      	mov	r0, r4
 8003300:	f7ff ff8f 	bl	8003222 <HAL_SPI_ErrorCallback>
 8003304:	e79c      	b.n	8003240 <HAL_SPI_IRQHandler+0x1c>
 8003306:	bf00      	nop
 8003308:	0800330d 	.word	0x0800330d

0800330c <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 800330c:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800330e:	6b80      	ldr	r0, [r0, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8003310:	2300      	movs	r3, #0
 8003312:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hspi->TxXferCount = 0U;
 8003314:	86c3      	strh	r3, [r0, #54]	; 0x36

  HAL_SPI_ErrorCallback(hspi);
 8003316:	f7ff ff84 	bl	8003222 <HAL_SPI_ErrorCallback>
 800331a:	bd08      	pop	{r3, pc}

0800331c <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;  

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800331c:	6a03      	ldr	r3, [r0, #32]
 800331e:	f023 0301 	bic.w	r3, r3, #1
 8003322:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8003324:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8003326:	6842      	ldr	r2, [r0, #4]
{
 8003328:	b570      	push	{r4, r5, r6, lr}
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800332a:	6984      	ldr	r4, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800332c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800332e:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 8003332:	4325      	orrs	r5, r4
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8003334:	688c      	ldr	r4, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 8003336:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 800333a:	4323      	orrs	r3, r4

    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 800333c:	4c0c      	ldr	r4, [pc, #48]	; (8003370 <TIM_OC1_SetConfig+0x54>)
 800333e:	42a0      	cmp	r0, r4
 8003340:	d009      	beq.n	8003356 <TIM_OC1_SetConfig+0x3a>
 8003342:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8003346:	42a0      	cmp	r0, r4
 8003348:	d005      	beq.n	8003356 <TIM_OC1_SetConfig+0x3a>
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800334a:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800334c:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 800334e:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8003350:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 8003352:	6203      	str	r3, [r0, #32]
} 
 8003354:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= OC_Config->OCNPolarity;
 8003356:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= OC_Config->OCNIdleState;
 8003358:	698e      	ldr	r6, [r1, #24]
    tmpccer &= ~TIM_CCER_CC1NP;
 800335a:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 800335e:	4323      	orrs	r3, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 8003360:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8003362:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 8003366:	4334      	orrs	r4, r6
    tmpccer &= ~TIM_CCER_CC1NE;
 8003368:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 800336c:	4322      	orrs	r2, r4
 800336e:	e7ec      	b.n	800334a <TIM_OC1_SetConfig+0x2e>
 8003370:	40010000 	.word	0x40010000

08003374 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8003374:	6a03      	ldr	r3, [r0, #32]
 8003376:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800337a:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800337c:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 800337e:	6842      	ldr	r2, [r0, #4]
{
 8003380:	b570      	push	{r4, r5, r6, lr}
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8003382:	69c4      	ldr	r4, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8003384:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
 8003386:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 800338a:	4325      	orrs	r5, r4
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800338c:	688c      	ldr	r4, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 800338e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8003392:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8003396:	4c0e      	ldr	r4, [pc, #56]	; (80033d0 <TIM_OC3_SetConfig+0x5c>)
 8003398:	42a0      	cmp	r0, r4
 800339a:	d009      	beq.n	80033b0 <TIM_OC3_SetConfig+0x3c>
 800339c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80033a0:	42a0      	cmp	r0, r4
 80033a2:	d005      	beq.n	80033b0 <TIM_OC3_SetConfig+0x3c>
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80033a4:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 80033a6:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 80033a8:	61c5      	str	r5, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 80033aa:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80033ac:	6203      	str	r3, [r0, #32]
}
 80033ae:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80033b0:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80033b2:	698e      	ldr	r6, [r1, #24]
    tmpccer &= ~TIM_CCER_CC3NP;
 80033b4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80033b8:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 80033bc:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80033be:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80033c2:	4334      	orrs	r4, r6
    tmpccer &= ~TIM_CCER_CC3NE;
 80033c4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80033c8:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
 80033cc:	e7ea      	b.n	80033a4 <TIM_OC3_SetConfig+0x30>
 80033ce:	bf00      	nop
 80033d0:	40010000 	.word	0x40010000

080033d4 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80033d4:	6a03      	ldr	r3, [r0, #32]
 80033d6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80033da:	6203      	str	r3, [r0, #32]
{
 80033dc:	b530      	push	{r4, r5, lr}
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80033de:	6a04      	ldr	r4, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 80033e0:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80033e2:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80033e4:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80033e6:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80033ea:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80033ee:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 80033f0:	f424 5400 	bic.w	r4, r4, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80033f4:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
   
  /*if((TIMx == TIM1) || (TIMx == TIM8))*/
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 80033f8:	4d09      	ldr	r5, [pc, #36]	; (8003420 <TIM_OC4_SetConfig+0x4c>)
 80033fa:	42a8      	cmp	r0, r5
 80033fc:	d009      	beq.n	8003412 <TIM_OC4_SetConfig+0x3e>
 80033fe:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003402:	42a8      	cmp	r0, r5
 8003404:	d005      	beq.n	8003412 <TIM_OC4_SetConfig+0x3e>
    tmpcr2 &= ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8003406:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8003408:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 800340a:	61c2      	str	r2, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 800340c:	6403      	str	r3, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800340e:	6204      	str	r4, [r0, #32]
}
 8003410:	bd30      	pop	{r4, r5, pc}
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8003412:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 8003414:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8003418:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 800341c:	e7f3      	b.n	8003406 <TIM_OC4_SetConfig+0x32>
 800341e:	bf00      	nop
 8003420:	40010000 	.word	0x40010000

08003424 <HAL_TIM_Base_MspInit>:
 8003424:	4770      	bx	lr

08003426 <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8003426:	6803      	ldr	r3, [r0, #0]
 8003428:	68da      	ldr	r2, [r3, #12]
 800342a:	f042 0201 	orr.w	r2, r2, #1
 800342e:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE(htim);
 8003430:	681a      	ldr	r2, [r3, #0]
 8003432:	f042 0201 	orr.w	r2, r2, #1
 8003436:	601a      	str	r2, [r3, #0]
}
 8003438:	2000      	movs	r0, #0
 800343a:	4770      	bx	lr

0800343c <HAL_TIM_Encoder_Start>:
{
 800343c:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
 800343e:	b189      	cbz	r1, 8003464 <HAL_TIM_Encoder_Start+0x28>
 8003440:	2904      	cmp	r1, #4
 8003442:	d007      	beq.n	8003454 <HAL_TIM_Encoder_Start+0x18>
  TIMx->CCER &= ~tmp;
 8003444:	6a1a      	ldr	r2, [r3, #32]
 8003446:	f022 0201 	bic.w	r2, r2, #1
 800344a:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 800344c:	6a1a      	ldr	r2, [r3, #32]
 800344e:	f042 0201 	orr.w	r2, r2, #1
 8003452:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
 8003454:	6a1a      	ldr	r2, [r3, #32]
 8003456:	f022 0210 	bic.w	r2, r2, #16
 800345a:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 800345c:	6a1a      	ldr	r2, [r3, #32]
 800345e:	f042 0210 	orr.w	r2, r2, #16
 8003462:	e006      	b.n	8003472 <HAL_TIM_Encoder_Start+0x36>
  TIMx->CCER &= ~tmp;
 8003464:	6a1a      	ldr	r2, [r3, #32]
 8003466:	f022 0201 	bic.w	r2, r2, #1
 800346a:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 800346c:	6a1a      	ldr	r2, [r3, #32]
 800346e:	f042 0201 	orr.w	r2, r2, #1
 8003472:	621a      	str	r2, [r3, #32]
  __HAL_TIM_ENABLE(htim);
 8003474:	681a      	ldr	r2, [r3, #0]
 8003476:	f042 0201 	orr.w	r2, r2, #1
 800347a:	601a      	str	r2, [r3, #0]
}
 800347c:	2000      	movs	r0, #0
 800347e:	4770      	bx	lr

08003480 <HAL_TIM_ReadCapturedValue>:
  __HAL_LOCK(htim);
 8003480:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003484:	2b01      	cmp	r3, #1
 8003486:	d01c      	beq.n	80034c2 <HAL_TIM_ReadCapturedValue+0x42>
  switch (Channel)
 8003488:	290c      	cmp	r1, #12
 800348a:	d818      	bhi.n	80034be <HAL_TIM_ReadCapturedValue+0x3e>
 800348c:	e8df f001 	tbb	[pc, r1]
 8003490:	17171707 	.word	0x17171707
 8003494:	1717170e 	.word	0x1717170e
 8003498:	17171711 	.word	0x17171711
 800349c:	14          	.byte	0x14
 800349d:	00          	.byte	0x00
      tmpreg = htim->Instance->CCR1;
 800349e:	6803      	ldr	r3, [r0, #0]
 80034a0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  __HAL_UNLOCK(htim);  
 80034a2:	2200      	movs	r2, #0
 80034a4:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
}
 80034a8:	4618      	mov	r0, r3
 80034aa:	4770      	bx	lr
      tmpreg = htim->Instance->CCR2;
 80034ac:	6803      	ldr	r3, [r0, #0]
 80034ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
      break;
 80034b0:	e7f7      	b.n	80034a2 <HAL_TIM_ReadCapturedValue+0x22>
      tmpreg = htim->Instance->CCR3;
 80034b2:	6803      	ldr	r3, [r0, #0]
 80034b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
      break;
 80034b6:	e7f4      	b.n	80034a2 <HAL_TIM_ReadCapturedValue+0x22>
      tmpreg = htim->Instance->CCR4;
 80034b8:	6803      	ldr	r3, [r0, #0]
 80034ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
      break;
 80034bc:	e7f1      	b.n	80034a2 <HAL_TIM_ReadCapturedValue+0x22>
  uint32_t tmpreg = 0U;
 80034be:	2300      	movs	r3, #0
 80034c0:	e7ef      	b.n	80034a2 <HAL_TIM_ReadCapturedValue+0x22>
  __HAL_LOCK(htim);
 80034c2:	2302      	movs	r3, #2
 80034c4:	e7f0      	b.n	80034a8 <HAL_TIM_ReadCapturedValue+0x28>

080034c6 <HAL_TIM_OC_DelayElapsedCallback>:
 80034c6:	4770      	bx	lr

080034c8 <HAL_TIM_PWM_PulseFinishedCallback>:
 80034c8:	4770      	bx	lr

080034ca <HAL_TIM_TriggerCallback>:
 80034ca:	4770      	bx	lr

080034cc <HAL_TIM_IRQHandler>:
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80034cc:	6803      	ldr	r3, [r0, #0]
 80034ce:	691a      	ldr	r2, [r3, #16]
 80034d0:	0791      	lsls	r1, r2, #30
{
 80034d2:	b510      	push	{r4, lr}
 80034d4:	4604      	mov	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80034d6:	d50e      	bpl.n	80034f6 <HAL_TIM_IRQHandler+0x2a>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 80034d8:	68da      	ldr	r2, [r3, #12]
 80034da:	0792      	lsls	r2, r2, #30
 80034dc:	d50b      	bpl.n	80034f6 <HAL_TIM_IRQHandler+0x2a>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80034de:	f06f 0202 	mvn.w	r2, #2
 80034e2:	611a      	str	r2, [r3, #16]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80034e4:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80034e6:	2201      	movs	r2, #1
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80034e8:	079b      	lsls	r3, r3, #30
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80034ea:	7602      	strb	r2, [r0, #24]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80034ec:	d077      	beq.n	80035de <HAL_TIM_IRQHandler+0x112>
          HAL_TIM_IC_CaptureCallback(htim);
 80034ee:	f002 fc6f 	bl	8005dd0 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80034f2:	2300      	movs	r3, #0
 80034f4:	7623      	strb	r3, [r4, #24]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80034f6:	6823      	ldr	r3, [r4, #0]
 80034f8:	691a      	ldr	r2, [r3, #16]
 80034fa:	0750      	lsls	r0, r2, #29
 80034fc:	d510      	bpl.n	8003520 <HAL_TIM_IRQHandler+0x54>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 80034fe:	68da      	ldr	r2, [r3, #12]
 8003500:	0751      	lsls	r1, r2, #29
 8003502:	d50d      	bpl.n	8003520 <HAL_TIM_IRQHandler+0x54>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8003504:	f06f 0204 	mvn.w	r2, #4
 8003508:	611a      	str	r2, [r3, #16]
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800350a:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800350c:	2202      	movs	r2, #2
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800350e:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8003512:	7622      	strb	r2, [r4, #24]
        HAL_TIM_IC_CaptureCallback(htim);
 8003514:	4620      	mov	r0, r4
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003516:	d068      	beq.n	80035ea <HAL_TIM_IRQHandler+0x11e>
        HAL_TIM_IC_CaptureCallback(htim);
 8003518:	f002 fc5a 	bl	8005dd0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800351c:	2300      	movs	r3, #0
 800351e:	7623      	strb	r3, [r4, #24]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8003520:	6823      	ldr	r3, [r4, #0]
 8003522:	691a      	ldr	r2, [r3, #16]
 8003524:	0712      	lsls	r2, r2, #28
 8003526:	d50f      	bpl.n	8003548 <HAL_TIM_IRQHandler+0x7c>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8003528:	68da      	ldr	r2, [r3, #12]
 800352a:	0710      	lsls	r0, r2, #28
 800352c:	d50c      	bpl.n	8003548 <HAL_TIM_IRQHandler+0x7c>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800352e:	f06f 0208 	mvn.w	r2, #8
 8003532:	611a      	str	r2, [r3, #16]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003534:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8003536:	2204      	movs	r2, #4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003538:	0799      	lsls	r1, r3, #30
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800353a:	7622      	strb	r2, [r4, #24]
        HAL_TIM_IC_CaptureCallback(htim);
 800353c:	4620      	mov	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800353e:	d05a      	beq.n	80035f6 <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8003540:	f002 fc46 	bl	8005dd0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003544:	2300      	movs	r3, #0
 8003546:	7623      	strb	r3, [r4, #24]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8003548:	6823      	ldr	r3, [r4, #0]
 800354a:	691a      	ldr	r2, [r3, #16]
 800354c:	06d2      	lsls	r2, r2, #27
 800354e:	d510      	bpl.n	8003572 <HAL_TIM_IRQHandler+0xa6>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 8003550:	68da      	ldr	r2, [r3, #12]
 8003552:	06d0      	lsls	r0, r2, #27
 8003554:	d50d      	bpl.n	8003572 <HAL_TIM_IRQHandler+0xa6>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8003556:	f06f 0210 	mvn.w	r2, #16
 800355a:	611a      	str	r2, [r3, #16]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800355c:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800355e:	2208      	movs	r2, #8
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003560:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8003564:	7622      	strb	r2, [r4, #24]
        HAL_TIM_IC_CaptureCallback(htim);
 8003566:	4620      	mov	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8003568:	d04b      	beq.n	8003602 <HAL_TIM_IRQHandler+0x136>
        HAL_TIM_IC_CaptureCallback(htim);
 800356a:	f002 fc31 	bl	8005dd0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800356e:	2300      	movs	r3, #0
 8003570:	7623      	strb	r3, [r4, #24]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8003572:	6823      	ldr	r3, [r4, #0]
 8003574:	691a      	ldr	r2, [r3, #16]
 8003576:	07d1      	lsls	r1, r2, #31
 8003578:	d508      	bpl.n	800358c <HAL_TIM_IRQHandler+0xc0>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 800357a:	68da      	ldr	r2, [r3, #12]
 800357c:	07d2      	lsls	r2, r2, #31
 800357e:	d505      	bpl.n	800358c <HAL_TIM_IRQHandler+0xc0>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8003580:	f06f 0201 	mvn.w	r2, #1
 8003584:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8003586:	4620      	mov	r0, r4
 8003588:	f7fd fab2 	bl	8000af0 <HAL_TIM_PeriodElapsedCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800358c:	6823      	ldr	r3, [r4, #0]
 800358e:	691a      	ldr	r2, [r3, #16]
 8003590:	0610      	lsls	r0, r2, #24
 8003592:	d508      	bpl.n	80035a6 <HAL_TIM_IRQHandler+0xda>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8003594:	68da      	ldr	r2, [r3, #12]
 8003596:	0611      	lsls	r1, r2, #24
 8003598:	d505      	bpl.n	80035a6 <HAL_TIM_IRQHandler+0xda>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800359a:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800359e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80035a0:	4620      	mov	r0, r4
 80035a2:	f000 faf4 	bl	8003b8e <HAL_TIMEx_BreakCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80035a6:	6823      	ldr	r3, [r4, #0]
 80035a8:	691a      	ldr	r2, [r3, #16]
 80035aa:	0652      	lsls	r2, r2, #25
 80035ac:	d508      	bpl.n	80035c0 <HAL_TIM_IRQHandler+0xf4>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 80035ae:	68da      	ldr	r2, [r3, #12]
 80035b0:	0650      	lsls	r0, r2, #25
 80035b2:	d505      	bpl.n	80035c0 <HAL_TIM_IRQHandler+0xf4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80035b4:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80035b8:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80035ba:	4620      	mov	r0, r4
 80035bc:	f7ff ff85 	bl	80034ca <HAL_TIM_TriggerCallback>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80035c0:	6823      	ldr	r3, [r4, #0]
 80035c2:	691a      	ldr	r2, [r3, #16]
 80035c4:	0691      	lsls	r1, r2, #26
 80035c6:	d522      	bpl.n	800360e <HAL_TIM_IRQHandler+0x142>
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 80035c8:	68da      	ldr	r2, [r3, #12]
 80035ca:	0692      	lsls	r2, r2, #26
 80035cc:	d51f      	bpl.n	800360e <HAL_TIM_IRQHandler+0x142>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80035ce:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
 80035d2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80035d4:	611a      	str	r2, [r3, #16]
}
 80035d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutationCallback(htim);
 80035da:	f000 bad7 	b.w	8003b8c <HAL_TIMEx_CommutationCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80035de:	f7ff ff72 	bl	80034c6 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80035e2:	4620      	mov	r0, r4
 80035e4:	f7ff ff70 	bl	80034c8 <HAL_TIM_PWM_PulseFinishedCallback>
 80035e8:	e783      	b.n	80034f2 <HAL_TIM_IRQHandler+0x26>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80035ea:	f7ff ff6c 	bl	80034c6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80035ee:	4620      	mov	r0, r4
 80035f0:	f7ff ff6a 	bl	80034c8 <HAL_TIM_PWM_PulseFinishedCallback>
 80035f4:	e792      	b.n	800351c <HAL_TIM_IRQHandler+0x50>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80035f6:	f7ff ff66 	bl	80034c6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 80035fa:	4620      	mov	r0, r4
 80035fc:	f7ff ff64 	bl	80034c8 <HAL_TIM_PWM_PulseFinishedCallback>
 8003600:	e7a0      	b.n	8003544 <HAL_TIM_IRQHandler+0x78>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003602:	f7ff ff60 	bl	80034c6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003606:	4620      	mov	r0, r4
 8003608:	f7ff ff5e 	bl	80034c8 <HAL_TIM_PWM_PulseFinishedCallback>
 800360c:	e7af      	b.n	800356e <HAL_TIM_IRQHandler+0xa2>
 800360e:	bd10      	pop	{r4, pc}

08003610 <TIM_Base_SetConfig>:
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8003610:	4a2e      	ldr	r2, [pc, #184]	; (80036cc <TIM_Base_SetConfig+0xbc>)
  tmpcr1 = TIMx->CR1;
 8003612:	6803      	ldr	r3, [r0, #0]
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8003614:	4290      	cmp	r0, r2
 8003616:	d012      	beq.n	800363e <TIM_Base_SetConfig+0x2e>
 8003618:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800361c:	d00f      	beq.n	800363e <TIM_Base_SetConfig+0x2e>
 800361e:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8003622:	4290      	cmp	r0, r2
 8003624:	d00b      	beq.n	800363e <TIM_Base_SetConfig+0x2e>
 8003626:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800362a:	4290      	cmp	r0, r2
 800362c:	d007      	beq.n	800363e <TIM_Base_SetConfig+0x2e>
 800362e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003632:	4290      	cmp	r0, r2
 8003634:	d003      	beq.n	800363e <TIM_Base_SetConfig+0x2e>
 8003636:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 800363a:	4290      	cmp	r0, r2
 800363c:	d11d      	bne.n	800367a <TIM_Base_SetConfig+0x6a>
    tmpcr1 |= Structure->CounterMode;
 800363e:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8003640:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8003644:	4313      	orrs	r3, r2
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8003646:	4a21      	ldr	r2, [pc, #132]	; (80036cc <TIM_Base_SetConfig+0xbc>)
 8003648:	4290      	cmp	r0, r2
 800364a:	d104      	bne.n	8003656 <TIM_Base_SetConfig+0x46>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800364c:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 800364e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8003652:	4313      	orrs	r3, r2
 8003654:	e028      	b.n	80036a8 <TIM_Base_SetConfig+0x98>
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8003656:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800365a:	d0f7      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 800365c:	4a1c      	ldr	r2, [pc, #112]	; (80036d0 <TIM_Base_SetConfig+0xc0>)
 800365e:	4290      	cmp	r0, r2
 8003660:	d0f4      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 8003662:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003666:	4290      	cmp	r0, r2
 8003668:	d0f0      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 800366a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800366e:	4290      	cmp	r0, r2
 8003670:	d0ec      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 8003672:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8003676:	4290      	cmp	r0, r2
 8003678:	d0e8      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 800367a:	4a16      	ldr	r2, [pc, #88]	; (80036d4 <TIM_Base_SetConfig+0xc4>)
 800367c:	4290      	cmp	r0, r2
 800367e:	d0e5      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 8003680:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003684:	4290      	cmp	r0, r2
 8003686:	d0e1      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 8003688:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800368c:	4290      	cmp	r0, r2
 800368e:	d0dd      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 8003690:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8003694:	4290      	cmp	r0, r2
 8003696:	d0d9      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 8003698:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800369c:	4290      	cmp	r0, r2
 800369e:	d0d5      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
 80036a0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80036a4:	4290      	cmp	r0, r2
 80036a6:	d0d1      	beq.n	800364c <TIM_Base_SetConfig+0x3c>
  TIMx->CR1 = tmpcr1;
 80036a8:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80036aa:	688b      	ldr	r3, [r1, #8]
 80036ac:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80036ae:	680b      	ldr	r3, [r1, #0]
 80036b0:	6283      	str	r3, [r0, #40]	; 0x28
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 80036b2:	4b06      	ldr	r3, [pc, #24]	; (80036cc <TIM_Base_SetConfig+0xbc>)
 80036b4:	4298      	cmp	r0, r3
 80036b6:	d006      	beq.n	80036c6 <TIM_Base_SetConfig+0xb6>
 80036b8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80036bc:	4298      	cmp	r0, r3
 80036be:	d002      	beq.n	80036c6 <TIM_Base_SetConfig+0xb6>
  TIMx->EGR = TIM_EGR_UG;
 80036c0:	2301      	movs	r3, #1
 80036c2:	6143      	str	r3, [r0, #20]
}
 80036c4:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
 80036c6:	690b      	ldr	r3, [r1, #16]
 80036c8:	6303      	str	r3, [r0, #48]	; 0x30
 80036ca:	e7f9      	b.n	80036c0 <TIM_Base_SetConfig+0xb0>
 80036cc:	40010000 	.word	0x40010000
 80036d0:	40000400 	.word	0x40000400
 80036d4:	40014000 	.word	0x40014000

080036d8 <HAL_TIM_Base_Init>:
{ 
 80036d8:	b510      	push	{r4, lr}
  if(htim == NULL)
 80036da:	4604      	mov	r4, r0
 80036dc:	b1a0      	cbz	r0, 8003708 <HAL_TIM_Base_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 80036de:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80036e2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80036e6:	b91b      	cbnz	r3, 80036f0 <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 80036e8:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_Base_MspInit(htim);
 80036ec:	f7ff fe9a 	bl	8003424 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 80036f0:	2302      	movs	r3, #2
 80036f2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 80036f6:	6820      	ldr	r0, [r4, #0]
 80036f8:	1d21      	adds	r1, r4, #4
 80036fa:	f7ff ff89 	bl	8003610 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 80036fe:	2301      	movs	r3, #1
 8003700:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8003704:	2000      	movs	r0, #0
 8003706:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8003708:	2001      	movs	r0, #1
}
 800370a:	bd10      	pop	{r4, pc}

0800370c <HAL_TIM_PWM_Init>:
{
 800370c:	b510      	push	{r4, lr}
  if(htim == NULL)
 800370e:	4604      	mov	r4, r0
 8003710:	b1a0      	cbz	r0, 800373c <HAL_TIM_PWM_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 8003712:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8003716:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800371a:	b91b      	cbnz	r3, 8003724 <HAL_TIM_PWM_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 800371c:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_PWM_MspInit(htim);
 8003720:	f7fd fd74 	bl	800120c <HAL_TIM_PWM_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;  
 8003724:	2302      	movs	r3, #2
 8003726:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 800372a:	6820      	ldr	r0, [r4, #0]
 800372c:	1d21      	adds	r1, r4, #4
 800372e:	f7ff ff6f 	bl	8003610 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8003732:	2301      	movs	r3, #1
 8003734:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8003738:	2000      	movs	r0, #0
 800373a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 800373c:	2001      	movs	r0, #1
}  
 800373e:	bd10      	pop	{r4, pc}

08003740 <HAL_TIM_IC_Init>:
{
 8003740:	b510      	push	{r4, lr}
  if(htim == NULL)
 8003742:	4604      	mov	r4, r0
 8003744:	b1a0      	cbz	r0, 8003770 <HAL_TIM_IC_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 8003746:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 800374a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800374e:	b91b      	cbnz	r3, 8003758 <HAL_TIM_IC_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8003750:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_IC_MspInit(htim);
 8003754:	f7fd fe1e 	bl	8001394 <HAL_TIM_IC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;   
 8003758:	2302      	movs	r3, #2
 800375a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 800375e:	6820      	ldr	r0, [r4, #0]
 8003760:	1d21      	adds	r1, r4, #4
 8003762:	f7ff ff55 	bl	8003610 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8003766:	2301      	movs	r3, #1
 8003768:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 800376c:	2000      	movs	r0, #0
 800376e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8003770:	2001      	movs	r0, #1
}
 8003772:	bd10      	pop	{r4, pc}

08003774 <HAL_TIM_Encoder_Init>:
{
 8003774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003776:	460c      	mov	r4, r1
  if(htim == NULL)
 8003778:	4605      	mov	r5, r0
 800377a:	2800      	cmp	r0, #0
 800377c:	d041      	beq.n	8003802 <HAL_TIM_Encoder_Init+0x8e>
  if(htim->State == HAL_TIM_STATE_RESET)
 800377e:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8003782:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003786:	b91b      	cbnz	r3, 8003790 <HAL_TIM_Encoder_Init+0x1c>
    htim->Lock = HAL_UNLOCKED;
 8003788:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_TIM_Encoder_MspInit(htim);
 800378c:	f7fd fd56 	bl	800123c <HAL_TIM_Encoder_MspInit>
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8003790:	4629      	mov	r1, r5
  htim->State= HAL_TIM_STATE_BUSY;   
 8003792:	2302      	movs	r3, #2
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8003794:	f851 0b04 	ldr.w	r0, [r1], #4
  htim->State= HAL_TIM_STATE_BUSY;   
 8003798:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 800379c:	6883      	ldr	r3, [r0, #8]
 800379e:	f023 0307 	bic.w	r3, r3, #7
 80037a2:	6083      	str	r3, [r0, #8]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);  
 80037a4:	f7ff ff34 	bl	8003610 <TIM_Base_SetConfig>
  tmpsmcr = htim->Instance->SMCR;
 80037a8:	6828      	ldr	r0, [r5, #0]
  tmpsmcr |= sConfig->EncoderMode;
 80037aa:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = htim->Instance->SMCR;
 80037ac:	6886      	ldr	r6, [r0, #8]
  tmpccmr1 = htim->Instance->CCMR1;
 80037ae:	6982      	ldr	r2, [r0, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 80037b0:	68a1      	ldr	r1, [r4, #8]
  tmpccer = htim->Instance->CCER;
 80037b2:	6a07      	ldr	r7, [r0, #32]
  tmpsmcr |= sConfig->EncoderMode;
 80037b4:	431e      	orrs	r6, r3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 80037b6:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 80037b8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80037bc:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 80037c0:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
 80037c4:	4313      	orrs	r3, r2
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 80037c6:	f423 427c 	bic.w	r2, r3, #64512	; 0xfc00
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80037ca:	6923      	ldr	r3, [r4, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
 80037cc:	69e1      	ldr	r1, [r4, #28]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80037ce:	011b      	lsls	r3, r3, #4
 80037d0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80037d4:	68e1      	ldr	r1, [r4, #12]
 80037d6:	430b      	orrs	r3, r1
 80037d8:	6a21      	ldr	r1, [r4, #32]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 80037da:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80037de:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
 80037e2:	4313      	orrs	r3, r2
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 80037e4:	6961      	ldr	r1, [r4, #20]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 80037e6:	f027 02aa 	bic.w	r2, r7, #170	; 0xaa
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 80037ea:	6867      	ldr	r7, [r4, #4]
  htim->Instance->SMCR = tmpsmcr;
 80037ec:	6086      	str	r6, [r0, #8]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 80037ee:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
  htim->Instance->CCMR1 = tmpccmr1;
 80037f2:	6183      	str	r3, [r0, #24]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 80037f4:	4317      	orrs	r7, r2
  htim->State= HAL_TIM_STATE_READY;
 80037f6:	2301      	movs	r3, #1
  htim->Instance->CCER = tmpccer;
 80037f8:	6207      	str	r7, [r0, #32]
  htim->State= HAL_TIM_STATE_READY;
 80037fa:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
  return HAL_OK;
 80037fe:	2000      	movs	r0, #0
 8003800:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8003802:	2001      	movs	r0, #1
}
 8003804:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003808 <TIM_TI1_SetConfig>:
{
 8003808:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800380a:	6a04      	ldr	r4, [r0, #32]
  if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 800380c:	4e1a      	ldr	r6, [pc, #104]	; (8003878 <TIM_TI1_SetConfig+0x70>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800380e:	f024 0401 	bic.w	r4, r4, #1
 8003812:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8003814:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8003816:	6a05      	ldr	r5, [r0, #32]
  if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8003818:	42b0      	cmp	r0, r6
 800381a:	f024 0403 	bic.w	r4, r4, #3
 800381e:	d01a      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 8003820:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003824:	d017      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 8003826:	f5a6 467c 	sub.w	r6, r6, #64512	; 0xfc00
 800382a:	42b0      	cmp	r0, r6
 800382c:	d013      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 800382e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8003832:	42b0      	cmp	r0, r6
 8003834:	d00f      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 8003836:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800383a:	42b0      	cmp	r0, r6
 800383c:	d00b      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 800383e:	f506 4678 	add.w	r6, r6, #63488	; 0xf800
 8003842:	42b0      	cmp	r0, r6
 8003844:	d007      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 8003846:	f506 5670 	add.w	r6, r6, #15360	; 0x3c00
 800384a:	42b0      	cmp	r0, r6
 800384c:	d003      	beq.n	8003856 <TIM_TI1_SetConfig+0x4e>
 800384e:	f5a6 3694 	sub.w	r6, r6, #75776	; 0x12800
 8003852:	42b0      	cmp	r0, r6
 8003854:	d10d      	bne.n	8003872 <TIM_TI1_SetConfig+0x6a>
    tmpccmr1 |= TIM_ICSelection;
 8003856:	4322      	orrs	r2, r4
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8003858:	011b      	lsls	r3, r3, #4
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800385a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 800385e:	b2db      	uxtb	r3, r3
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8003860:	f025 050a 	bic.w	r5, r5, #10
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8003864:	f001 010a 	and.w	r1, r1, #10
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8003868:	431a      	orrs	r2, r3
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 800386a:	4329      	orrs	r1, r5
  TIMx->CCMR1 = tmpccmr1;
 800386c:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 800386e:	6201      	str	r1, [r0, #32]
}
 8003870:	bd70      	pop	{r4, r5, r6, pc}
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
 8003872:	f044 0201 	orr.w	r2, r4, #1
 8003876:	e7ef      	b.n	8003858 <TIM_TI1_SetConfig+0x50>
 8003878:	40010000 	.word	0x40010000

0800387c <HAL_TIM_IC_ConfigChannel>:
{
 800387c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 800387e:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003882:	2b01      	cmp	r3, #1
{
 8003884:	4604      	mov	r4, r0
 8003886:	460d      	mov	r5, r1
 8003888:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 800388c:	d019      	beq.n	80038c2 <HAL_TIM_IC_ConfigChannel+0x46>
 800388e:	2301      	movs	r3, #1
 8003890:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  htim->State = HAL_TIM_STATE_BUSY;
 8003894:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
  if (Channel == TIM_CHANNEL_1)
 8003898:	b9a2      	cbnz	r2, 80038c4 <HAL_TIM_IC_ConfigChannel+0x48>
    TIM_TI1_SetConfig(htim->Instance,
 800389a:	68cb      	ldr	r3, [r1, #12]
 800389c:	6820      	ldr	r0, [r4, #0]
 800389e:	c906      	ldmia	r1, {r1, r2}
 80038a0:	f7ff ffb2 	bl	8003808 <TIM_TI1_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 80038a4:	6823      	ldr	r3, [r4, #0]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 80038a6:	68a9      	ldr	r1, [r5, #8]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 80038a8:	699a      	ldr	r2, [r3, #24]
 80038aa:	f022 020c 	bic.w	r2, r2, #12
 80038ae:	619a      	str	r2, [r3, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 80038b0:	699a      	ldr	r2, [r3, #24]
 80038b2:	430a      	orrs	r2, r1
 80038b4:	619a      	str	r2, [r3, #24]
  htim->State = HAL_TIM_STATE_READY;
 80038b6:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 80038b8:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 80038ba:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UNLOCK(htim);
 80038be:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
}
 80038c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Channel == TIM_CHANNEL_2)
 80038c4:	2a04      	cmp	r2, #4
 80038c6:	688e      	ldr	r6, [r1, #8]
 80038c8:	6823      	ldr	r3, [r4, #0]
 80038ca:	68e8      	ldr	r0, [r5, #12]
 80038cc:	c982      	ldmia	r1, {r1, r7}
 80038ce:	d11f      	bne.n	8003910 <HAL_TIM_IC_ConfigChannel+0x94>
{
  uint32_t tmpccmr1 = 0U;
  uint32_t tmpccer = 0U;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80038d0:	6a1a      	ldr	r2, [r3, #32]
 80038d2:	f022 0210 	bic.w	r2, r2, #16
 80038d6:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 80038d8:	699a      	ldr	r2, [r3, #24]
  tmpccer = TIMx->CCER;
 80038da:	6a1d      	ldr	r5, [r3, #32]
  
  /* Select the Input */
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 80038dc:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  tmpccmr1 |= (TIM_ICSelection << 8U);
 80038e0:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
  
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 80038e4:	0300      	lsls	r0, r0, #12
 80038e6:	b280      	uxth	r0, r0
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80038e8:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 80038ec:	0109      	lsls	r1, r1, #4
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 80038ee:	4302      	orrs	r2, r0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 80038f0:	f001 01a0 	and.w	r1, r1, #160	; 0xa0
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80038f4:	f025 00a0 	bic.w	r0, r5, #160	; 0xa0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 80038f8:	4301      	orrs	r1, r0

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 80038fa:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 80038fc:	6219      	str	r1, [r3, #32]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 80038fe:	699a      	ldr	r2, [r3, #24]
 8003900:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8003904:	619a      	str	r2, [r3, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 8003906:	699a      	ldr	r2, [r3, #24]
 8003908:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
 800390c:	619e      	str	r6, [r3, #24]
 800390e:	e7d2      	b.n	80038b6 <HAL_TIM_IC_ConfigChannel+0x3a>
  else if (Channel == TIM_CHANNEL_3)
 8003910:	2a08      	cmp	r2, #8
{
  uint32_t tmpccmr2 = 0U;
  uint32_t tmpccer = 0U;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8003912:	6a1a      	ldr	r2, [r3, #32]
  else if (Channel == TIM_CHANNEL_3)
 8003914:	d11c      	bne.n	8003950 <HAL_TIM_IC_ConfigChannel+0xd4>
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8003916:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800391a:	621a      	str	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 800391c:	69da      	ldr	r2, [r3, #28]
  tmpccer = TIMx->CCER;
 800391e:	6a1d      	ldr	r5, [r3, #32]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
 8003920:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr2 |= TIM_ICSelection;
 8003924:	433a      	orrs	r2, r7

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8003926:	0100      	lsls	r0, r0, #4
 8003928:	b2c0      	uxtb	r0, r0
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 800392a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 800392e:	0209      	lsls	r1, r1, #8
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8003930:	4302      	orrs	r2, r0
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8003932:	f401 6120 	and.w	r1, r1, #2560	; 0xa00
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8003936:	f425 6020 	bic.w	r0, r5, #2560	; 0xa00
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 800393a:	4301      	orrs	r1, r0

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800393c:	61da      	str	r2, [r3, #28]
  TIMx->CCER = tmpccer;
 800393e:	6219      	str	r1, [r3, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 8003940:	69da      	ldr	r2, [r3, #28]
 8003942:	f022 020c 	bic.w	r2, r2, #12
 8003946:	61da      	str	r2, [r3, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 8003948:	69da      	ldr	r2, [r3, #28]
 800394a:	4316      	orrs	r6, r2
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 800394c:	61de      	str	r6, [r3, #28]
 800394e:	e7b2      	b.n	80038b6 <HAL_TIM_IC_ConfigChannel+0x3a>
{
  uint32_t tmpccmr2 = 0U;
  uint32_t tmpccer = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8003950:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003954:	621a      	str	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8003956:	69da      	ldr	r2, [r3, #28]
  tmpccer = TIMx->CCER;
 8003958:	6a1d      	ldr	r5, [r3, #32]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 800395a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  tmpccmr2 |= (TIM_ICSelection << 8U);
 800395e:	ea42 2207 	orr.w	r2, r2, r7, lsl #8

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8003962:	0300      	lsls	r0, r0, #12
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 8003964:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8003968:	b280      	uxth	r0, r0

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 800396a:	0309      	lsls	r1, r1, #12
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 800396c:	4310      	orrs	r0, r2
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 800396e:	f401 4120 	and.w	r1, r1, #40960	; 0xa000
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8003972:	f425 4220 	bic.w	r2, r5, #40960	; 0xa000
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8003976:	4311      	orrs	r1, r2

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8003978:	61d8      	str	r0, [r3, #28]
  TIMx->CCER = tmpccer ;
 800397a:	6219      	str	r1, [r3, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
 800397c:	69da      	ldr	r2, [r3, #28]
 800397e:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8003982:	61da      	str	r2, [r3, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8003984:	69da      	ldr	r2, [r3, #28]
 8003986:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
 800398a:	e7df      	b.n	800394c <HAL_TIM_IC_ConfigChannel+0xd0>

0800398c <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800398c:	6a03      	ldr	r3, [r0, #32]
 800398e:	f023 0310 	bic.w	r3, r3, #16
 8003992:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8003994:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 = TIMx->CR2;
 8003996:	6842      	ldr	r2, [r0, #4]
{
 8003998:	b570      	push	{r4, r5, r6, lr}
  tmpccmrx = TIMx->CCMR1;
 800399a:	6984      	ldr	r4, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800399c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800399e:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80039a2:	ea44 2505 	orr.w	r5, r4, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80039a6:	688c      	ldr	r4, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 80039a8:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80039ac:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 80039b0:	4c0d      	ldr	r4, [pc, #52]	; (80039e8 <TIM_OC2_SetConfig+0x5c>)
 80039b2:	42a0      	cmp	r0, r4
 80039b4:	d009      	beq.n	80039ca <TIM_OC2_SetConfig+0x3e>
 80039b6:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80039ba:	42a0      	cmp	r0, r4
 80039bc:	d005      	beq.n	80039ca <TIM_OC2_SetConfig+0x3e>
  TIMx->CR2 = tmpcr2;
 80039be:	6042      	str	r2, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 80039c0:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 80039c2:	6185      	str	r5, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 80039c4:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 80039c6:	6203      	str	r3, [r0, #32]
}
 80039c8:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80039ca:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 80039cc:	698e      	ldr	r6, [r1, #24]
    tmpccer &= ~TIM_CCER_CC2NP;
 80039ce:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80039d2:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 80039d6:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 80039d8:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 80039dc:	4334      	orrs	r4, r6
    tmpccer &= ~TIM_CCER_CC2NE;
 80039de:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 80039e2:	ea42 0284 	orr.w	r2, r2, r4, lsl #2
 80039e6:	e7ea      	b.n	80039be <TIM_OC2_SetConfig+0x32>
 80039e8:	40010000 	.word	0x40010000

080039ec <HAL_TIM_PWM_ConfigChannel>:
{
 80039ec:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 80039ee:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 80039f2:	2b01      	cmp	r3, #1
{
 80039f4:	4604      	mov	r4, r0
 80039f6:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 80039fa:	d025      	beq.n	8003a48 <HAL_TIM_PWM_ConfigChannel+0x5c>
 80039fc:	2301      	movs	r3, #1
 80039fe:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  htim->State = HAL_TIM_STATE_BUSY;
 8003a02:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
  switch (Channel)
 8003a06:	2a0c      	cmp	r2, #12
 8003a08:	d818      	bhi.n	8003a3c <HAL_TIM_PWM_ConfigChannel+0x50>
 8003a0a:	e8df f002 	tbb	[pc, r2]
 8003a0e:	1707      	.short	0x1707
 8003a10:	171e1717 	.word	0x171e1717
 8003a14:	172f1717 	.word	0x172f1717
 8003a18:	1717      	.short	0x1717
 8003a1a:	40          	.byte	0x40
 8003a1b:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8003a1c:	6820      	ldr	r0, [r4, #0]
 8003a1e:	f7ff fc7d 	bl	800331c <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8003a22:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8003a24:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8003a26:	699a      	ldr	r2, [r3, #24]
 8003a28:	f042 0208 	orr.w	r2, r2, #8
 8003a2c:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8003a2e:	699a      	ldr	r2, [r3, #24]
 8003a30:	f022 0204 	bic.w	r2, r2, #4
 8003a34:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8003a36:	699a      	ldr	r2, [r3, #24]
 8003a38:	430a      	orrs	r2, r1
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8003a3a:	619a      	str	r2, [r3, #24]
  htim->State = HAL_TIM_STATE_READY;
 8003a3c:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8003a3e:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8003a40:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UNLOCK(htim);
 8003a44:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
}
 8003a48:	bd38      	pop	{r3, r4, r5, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8003a4a:	6820      	ldr	r0, [r4, #0]
 8003a4c:	f7ff ff9e 	bl	800398c <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8003a50:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8003a52:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8003a54:	699a      	ldr	r2, [r3, #24]
 8003a56:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8003a5a:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8003a5c:	699a      	ldr	r2, [r3, #24]
 8003a5e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003a62:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8003a64:	699a      	ldr	r2, [r3, #24]
 8003a66:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003a6a:	e7e6      	b.n	8003a3a <HAL_TIM_PWM_ConfigChannel+0x4e>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8003a6c:	6820      	ldr	r0, [r4, #0]
 8003a6e:	f7ff fc81 	bl	8003374 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8003a72:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
 8003a74:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8003a76:	69da      	ldr	r2, [r3, #28]
 8003a78:	f042 0208 	orr.w	r2, r2, #8
 8003a7c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8003a7e:	69da      	ldr	r2, [r3, #28]
 8003a80:	f022 0204 	bic.w	r2, r2, #4
 8003a84:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
 8003a86:	69da      	ldr	r2, [r3, #28]
 8003a88:	430a      	orrs	r2, r1
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
 8003a8a:	61da      	str	r2, [r3, #28]
    break;
 8003a8c:	e7d6      	b.n	8003a3c <HAL_TIM_PWM_ConfigChannel+0x50>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8003a8e:	6820      	ldr	r0, [r4, #0]
 8003a90:	f7ff fca0 	bl	80033d4 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8003a94:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
 8003a96:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8003a98:	69da      	ldr	r2, [r3, #28]
 8003a9a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8003a9e:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8003aa0:	69da      	ldr	r2, [r3, #28]
 8003aa2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003aa6:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
 8003aa8:	69da      	ldr	r2, [r3, #28]
 8003aaa:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003aae:	e7ec      	b.n	8003a8a <HAL_TIM_PWM_ConfigChannel+0x9e>

08003ab0 <TIM_CCxChannelCmd>:
  TIMx->CCER &= ~tmp;
 8003ab0:	6a03      	ldr	r3, [r0, #32]
{
 8003ab2:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1E << Channel;
 8003ab4:	2401      	movs	r4, #1
 8003ab6:	408c      	lsls	r4, r1
  TIMx->CCER &= ~tmp;
 8003ab8:	ea23 0304 	bic.w	r3, r3, r4
 8003abc:	6203      	str	r3, [r0, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << Channel);
 8003abe:	6a03      	ldr	r3, [r0, #32]
 8003ac0:	408a      	lsls	r2, r1
 8003ac2:	431a      	orrs	r2, r3
 8003ac4:	6202      	str	r2, [r0, #32]
 8003ac6:	bd10      	pop	{r4, pc}

08003ac8 <HAL_TIM_PWM_Start>:
{
 8003ac8:	b510      	push	{r4, lr}
 8003aca:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8003acc:	2201      	movs	r2, #1
 8003ace:	6800      	ldr	r0, [r0, #0]
 8003ad0:	f7ff ffee 	bl	8003ab0 <TIM_CCxChannelCmd>
  if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
 8003ad4:	6823      	ldr	r3, [r4, #0]
 8003ad6:	4a08      	ldr	r2, [pc, #32]	; (8003af8 <HAL_TIM_PWM_Start+0x30>)
 8003ad8:	4293      	cmp	r3, r2
 8003ada:	d003      	beq.n	8003ae4 <HAL_TIM_PWM_Start+0x1c>
 8003adc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003ae0:	4293      	cmp	r3, r2
 8003ae2:	d103      	bne.n	8003aec <HAL_TIM_PWM_Start+0x24>
    __HAL_TIM_MOE_ENABLE(htim);
 8003ae4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003ae6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003aea:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_ENABLE(htim);
 8003aec:	681a      	ldr	r2, [r3, #0]
 8003aee:	f042 0201 	orr.w	r2, r2, #1
 8003af2:	601a      	str	r2, [r3, #0]
} 
 8003af4:	2000      	movs	r0, #0
 8003af6:	bd10      	pop	{r4, pc}
 8003af8:	40010000 	.word	0x40010000

08003afc <HAL_TIMEx_MasterConfigSynchronization>:
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
  
  __HAL_LOCK(htim);
 8003afc:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003b00:	2b01      	cmp	r3, #1
{
 8003b02:	b510      	push	{r4, lr}
 8003b04:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 8003b08:	d018      	beq.n	8003b3c <HAL_TIMEx_MasterConfigSynchronization+0x40>
  
  htim->State = HAL_TIM_STATE_BUSY;
 8003b0a:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8003b0e:	6803      	ldr	r3, [r0, #0]
  /* Select the TRGO source */
  htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
 8003b10:	680c      	ldr	r4, [r1, #0]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8003b12:	685a      	ldr	r2, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8003b14:	6849      	ldr	r1, [r1, #4]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8003b16:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8003b1a:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
 8003b1c:	685a      	ldr	r2, [r3, #4]
 8003b1e:	4322      	orrs	r2, r4
 8003b20:	605a      	str	r2, [r3, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8003b22:	689a      	ldr	r2, [r3, #8]
 8003b24:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003b28:	609a      	str	r2, [r3, #8]
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8003b2a:	689a      	ldr	r2, [r3, #8]
 8003b2c:	430a      	orrs	r2, r1
 8003b2e:	609a      	str	r2, [r3, #8]
  
  htim->State = HAL_TIM_STATE_READY;
 8003b30:	2301      	movs	r3, #1
 8003b32:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  
  __HAL_UNLOCK(htim);
 8003b36:	2300      	movs	r3, #0
 8003b38:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  __HAL_LOCK(htim);
 8003b3c:	4618      	mov	r0, r3
  
  return HAL_OK;
} 
 8003b3e:	bd10      	pop	{r4, pc}

08003b40 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  
  /* Check input state */
  __HAL_LOCK(htim);
 8003b40:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003b44:	2b01      	cmp	r3, #1
 8003b46:	d01f      	beq.n	8003b88 <HAL_TIMEx_ConfigBreakDeadTime+0x48>
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
  the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8003b48:	68cb      	ldr	r3, [r1, #12]
 8003b4a:	688a      	ldr	r2, [r1, #8]
 8003b4c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003b50:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8003b52:	684a      	ldr	r2, [r1, #4]
 8003b54:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003b58:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8003b5a:	680a      	ldr	r2, [r1, #0]
 8003b5c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003b60:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8003b62:	690a      	ldr	r2, [r1, #16]
 8003b64:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003b68:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8003b6a:	694a      	ldr	r2, [r1, #20]
 8003b6c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003b70:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003b72:	698a      	ldr	r2, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003b74:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8003b78:	4313      	orrs	r3, r2
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 8003b7a:	6802      	ldr	r2, [r0, #0]
 8003b7c:	6453      	str	r3, [r2, #68]	; 0x44
  
  __HAL_UNLOCK(htim);
 8003b7e:	2300      	movs	r3, #0
 8003b80:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

  return HAL_OK;
 8003b84:	4618      	mov	r0, r3
 8003b86:	4770      	bx	lr
  __HAL_LOCK(htim);
 8003b88:	2002      	movs	r0, #2
}
 8003b8a:	4770      	bx	lr

08003b8c <HAL_TIMEx_CommutationCallback>:
 8003b8c:	4770      	bx	lr

08003b8e <HAL_TIMEx_BreakCallback>:
  * @param  htim pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8003b8e:	4770      	bx	lr

08003b90 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003b90:	6803      	ldr	r3, [r0, #0]
 8003b92:	68da      	ldr	r2, [r3, #12]
 8003b94:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8003b98:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003b9a:	695a      	ldr	r2, [r3, #20]
 8003b9c:	f022 0201 	bic.w	r2, r2, #1
 8003ba0:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8003ba2:	2320      	movs	r3, #32
 8003ba4:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
 8003ba8:	4770      	bx	lr
	...

08003bac <UART_SetConfig>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8003bac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8003bb0:	6806      	ldr	r6, [r0, #0]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8003bb2:	68c2      	ldr	r2, [r0, #12]
  tmpreg = huart->Instance->CR2;
 8003bb4:	6933      	ldr	r3, [r6, #16]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8003bb6:	69c1      	ldr	r1, [r0, #28]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8003bb8:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8003bbc:	4313      	orrs	r3, r2
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 8003bbe:	6133      	str	r3, [r6, #16]
{
 8003bc0:	4604      	mov	r4, r0
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8003bc2:	6883      	ldr	r3, [r0, #8]
 8003bc4:	6900      	ldr	r0, [r0, #16]
  tmpreg = huart->Instance->CR1;
 8003bc6:	68f2      	ldr	r2, [r6, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8003bc8:	4303      	orrs	r3, r0
 8003bca:	6960      	ldr	r0, [r4, #20]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8003bcc:	f422 4216 	bic.w	r2, r2, #38400	; 0x9600
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8003bd0:	4303      	orrs	r3, r0
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8003bd2:	f022 020c 	bic.w	r2, r2, #12
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8003bd6:	430b      	orrs	r3, r1
 8003bd8:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8003bda:	60f3      	str	r3, [r6, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 8003bdc:	6973      	ldr	r3, [r6, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8003bde:	69a2      	ldr	r2, [r4, #24]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8003be0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tmpreg |= huart->Init.HwFlowCtl;
 8003be4:	4313      	orrs	r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003be6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8003bea:	6173      	str	r3, [r6, #20]
 8003bec:	4b7a      	ldr	r3, [pc, #488]	; (8003dd8 <UART_SetConfig+0x22c>)
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003bee:	d17c      	bne.n	8003cea <UART_SetConfig+0x13e>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6) 
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8003bf0:	429e      	cmp	r6, r3
 8003bf2:	d003      	beq.n	8003bfc <UART_SetConfig+0x50>
 8003bf4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003bf8:	429e      	cmp	r6, r3
 8003bfa:	d144      	bne.n	8003c86 <UART_SetConfig+0xda>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8003bfc:	f7ff faa6 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003c00:	2519      	movs	r5, #25
 8003c02:	fb05 f300 	mul.w	r3, r5, r0
 8003c06:	6860      	ldr	r0, [r4, #4]
 8003c08:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003c0c:	0040      	lsls	r0, r0, #1
 8003c0e:	fbb3 f3f0 	udiv	r3, r3, r0
 8003c12:	fbb3 f3f9 	udiv	r3, r3, r9
 8003c16:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8003c1a:	f7ff fa97 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003c1e:	6863      	ldr	r3, [r4, #4]
 8003c20:	4368      	muls	r0, r5
 8003c22:	005b      	lsls	r3, r3, #1
 8003c24:	fbb0 f7f3 	udiv	r7, r0, r3
 8003c28:	f7ff fa90 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003c2c:	6863      	ldr	r3, [r4, #4]
 8003c2e:	4368      	muls	r0, r5
 8003c30:	005b      	lsls	r3, r3, #1
 8003c32:	fbb0 f3f3 	udiv	r3, r0, r3
 8003c36:	fbb3 f3f9 	udiv	r3, r3, r9
 8003c3a:	fb09 7313 	mls	r3, r9, r3, r7
 8003c3e:	00db      	lsls	r3, r3, #3
 8003c40:	3332      	adds	r3, #50	; 0x32
 8003c42:	fbb3 f3f9 	udiv	r3, r3, r9
 8003c46:	005b      	lsls	r3, r3, #1
 8003c48:	f403 77f8 	and.w	r7, r3, #496	; 0x1f0
 8003c4c:	f7ff fa7e 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003c50:	6862      	ldr	r2, [r4, #4]
 8003c52:	4368      	muls	r0, r5
 8003c54:	0052      	lsls	r2, r2, #1
 8003c56:	fbb0 faf2 	udiv	sl, r0, r2
 8003c5a:	f7ff fa77 	bl	800314c <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8003c5e:	6863      	ldr	r3, [r4, #4]
 8003c60:	4368      	muls	r0, r5
 8003c62:	005b      	lsls	r3, r3, #1
 8003c64:	fbb0 f3f3 	udiv	r3, r0, r3
 8003c68:	fbb3 f3f9 	udiv	r3, r3, r9
 8003c6c:	fb09 a313 	mls	r3, r9, r3, sl
 8003c70:	00db      	lsls	r3, r3, #3
 8003c72:	3332      	adds	r3, #50	; 0x32
 8003c74:	fbb3 f3f9 	udiv	r3, r3, r9
 8003c78:	f003 0307 	and.w	r3, r3, #7
 8003c7c:	4443      	add	r3, r8
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8003c7e:	443b      	add	r3, r7
 8003c80:	60b3      	str	r3, [r6, #8]
 8003c82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8003c86:	f7ff fa51 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003c8a:	2519      	movs	r5, #25
 8003c8c:	fb05 f300 	mul.w	r3, r5, r0
 8003c90:	6860      	ldr	r0, [r4, #4]
 8003c92:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003c96:	0040      	lsls	r0, r0, #1
 8003c98:	fbb3 f3f0 	udiv	r3, r3, r0
 8003c9c:	fbb3 f3f9 	udiv	r3, r3, r9
 8003ca0:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8003ca4:	f7ff fa42 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003ca8:	6863      	ldr	r3, [r4, #4]
 8003caa:	4368      	muls	r0, r5
 8003cac:	005b      	lsls	r3, r3, #1
 8003cae:	fbb0 f7f3 	udiv	r7, r0, r3
 8003cb2:	f7ff fa3b 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003cb6:	6863      	ldr	r3, [r4, #4]
 8003cb8:	4368      	muls	r0, r5
 8003cba:	005b      	lsls	r3, r3, #1
 8003cbc:	fbb0 f3f3 	udiv	r3, r0, r3
 8003cc0:	fbb3 f3f9 	udiv	r3, r3, r9
 8003cc4:	fb09 7313 	mls	r3, r9, r3, r7
 8003cc8:	00db      	lsls	r3, r3, #3
 8003cca:	3332      	adds	r3, #50	; 0x32
 8003ccc:	fbb3 f3f9 	udiv	r3, r3, r9
 8003cd0:	005b      	lsls	r3, r3, #1
 8003cd2:	f403 77f8 	and.w	r7, r3, #496	; 0x1f0
 8003cd6:	f7ff fa29 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003cda:	6862      	ldr	r2, [r4, #4]
 8003cdc:	4368      	muls	r0, r5
 8003cde:	0052      	lsls	r2, r2, #1
 8003ce0:	fbb0 faf2 	udiv	sl, r0, r2
 8003ce4:	f7ff fa22 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003ce8:	e7b9      	b.n	8003c5e <UART_SetConfig+0xb2>
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8003cea:	429e      	cmp	r6, r3
 8003cec:	d002      	beq.n	8003cf4 <UART_SetConfig+0x148>
 8003cee:	4b3b      	ldr	r3, [pc, #236]	; (8003ddc <UART_SetConfig+0x230>)
 8003cf0:	429e      	cmp	r6, r3
 8003cf2:	d140      	bne.n	8003d76 <UART_SetConfig+0x1ca>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8003cf4:	f7ff fa2a 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003cf8:	6867      	ldr	r7, [r4, #4]
 8003cfa:	2519      	movs	r5, #25
 8003cfc:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003d00:	fb05 f300 	mul.w	r3, r5, r0
 8003d04:	00bf      	lsls	r7, r7, #2
 8003d06:	fbb3 f3f7 	udiv	r3, r3, r7
 8003d0a:	fbb3 f3f9 	udiv	r3, r3, r9
 8003d0e:	011f      	lsls	r7, r3, #4
 8003d10:	f7ff fa1c 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003d14:	6863      	ldr	r3, [r4, #4]
 8003d16:	4368      	muls	r0, r5
 8003d18:	009b      	lsls	r3, r3, #2
 8003d1a:	fbb0 f8f3 	udiv	r8, r0, r3
 8003d1e:	f7ff fa15 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003d22:	6863      	ldr	r3, [r4, #4]
 8003d24:	4368      	muls	r0, r5
 8003d26:	009b      	lsls	r3, r3, #2
 8003d28:	fbb0 f3f3 	udiv	r3, r0, r3
 8003d2c:	fbb3 f3f9 	udiv	r3, r3, r9
 8003d30:	fb09 8313 	mls	r3, r9, r3, r8
 8003d34:	011b      	lsls	r3, r3, #4
 8003d36:	3332      	adds	r3, #50	; 0x32
 8003d38:	fbb3 f3f9 	udiv	r3, r3, r9
 8003d3c:	f003 08f0 	and.w	r8, r3, #240	; 0xf0
 8003d40:	f7ff fa04 	bl	800314c <HAL_RCC_GetPCLK2Freq>
 8003d44:	6862      	ldr	r2, [r4, #4]
 8003d46:	4368      	muls	r0, r5
 8003d48:	0092      	lsls	r2, r2, #2
 8003d4a:	fbb0 faf2 	udiv	sl, r0, r2
 8003d4e:	f7ff f9fd 	bl	800314c <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8003d52:	6863      	ldr	r3, [r4, #4]
 8003d54:	4368      	muls	r0, r5
 8003d56:	009b      	lsls	r3, r3, #2
 8003d58:	fbb0 f3f3 	udiv	r3, r0, r3
 8003d5c:	fbb3 f3f9 	udiv	r3, r3, r9
 8003d60:	fb09 a313 	mls	r3, r9, r3, sl
 8003d64:	011b      	lsls	r3, r3, #4
 8003d66:	3332      	adds	r3, #50	; 0x32
 8003d68:	fbb3 f3f9 	udiv	r3, r3, r9
 8003d6c:	f003 030f 	and.w	r3, r3, #15
 8003d70:	ea43 0308 	orr.w	r3, r3, r8
 8003d74:	e783      	b.n	8003c7e <UART_SetConfig+0xd2>
 8003d76:	f7ff f9d9 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003d7a:	6867      	ldr	r7, [r4, #4]
 8003d7c:	2519      	movs	r5, #25
 8003d7e:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003d82:	fb05 f300 	mul.w	r3, r5, r0
 8003d86:	00bf      	lsls	r7, r7, #2
 8003d88:	fbb3 f3f7 	udiv	r3, r3, r7
 8003d8c:	fbb3 f3f9 	udiv	r3, r3, r9
 8003d90:	011f      	lsls	r7, r3, #4
 8003d92:	f7ff f9cb 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003d96:	6863      	ldr	r3, [r4, #4]
 8003d98:	4368      	muls	r0, r5
 8003d9a:	009b      	lsls	r3, r3, #2
 8003d9c:	fbb0 f8f3 	udiv	r8, r0, r3
 8003da0:	f7ff f9c4 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003da4:	6863      	ldr	r3, [r4, #4]
 8003da6:	4368      	muls	r0, r5
 8003da8:	009b      	lsls	r3, r3, #2
 8003daa:	fbb0 f3f3 	udiv	r3, r0, r3
 8003dae:	fbb3 f3f9 	udiv	r3, r3, r9
 8003db2:	fb09 8313 	mls	r3, r9, r3, r8
 8003db6:	011b      	lsls	r3, r3, #4
 8003db8:	3332      	adds	r3, #50	; 0x32
 8003dba:	fbb3 f3f9 	udiv	r3, r3, r9
 8003dbe:	f003 08f0 	and.w	r8, r3, #240	; 0xf0
 8003dc2:	f7ff f9b3 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003dc6:	6862      	ldr	r2, [r4, #4]
 8003dc8:	4368      	muls	r0, r5
 8003dca:	0092      	lsls	r2, r2, #2
 8003dcc:	fbb0 faf2 	udiv	sl, r0, r2
 8003dd0:	f7ff f9ac 	bl	800312c <HAL_RCC_GetPCLK1Freq>
 8003dd4:	e7bd      	b.n	8003d52 <UART_SetConfig+0x1a6>
 8003dd6:	bf00      	nop
 8003dd8:	40011000 	.word	0x40011000
 8003ddc:	40011400 	.word	0x40011400

08003de0 <HAL_UART_Init>:
{
 8003de0:	b510      	push	{r4, lr}
  if(huart == NULL)
 8003de2:	4604      	mov	r4, r0
 8003de4:	b340      	cbz	r0, 8003e38 <HAL_UART_Init+0x58>
  if(huart->gState == HAL_UART_STATE_RESET)
 8003de6:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8003dea:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003dee:	b91b      	cbnz	r3, 8003df8 <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8003df0:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 8003df4:	f7fd fc0c 	bl	8001610 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8003df8:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8003dfa:	2324      	movs	r3, #36	; 0x24
 8003dfc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 8003e00:	68d3      	ldr	r3, [r2, #12]
 8003e02:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003e06:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8003e08:	4620      	mov	r0, r4
 8003e0a:	f7ff fecf 	bl	8003bac <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003e0e:	6823      	ldr	r3, [r4, #0]
 8003e10:	691a      	ldr	r2, [r3, #16]
 8003e12:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8003e16:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003e18:	695a      	ldr	r2, [r3, #20]
 8003e1a:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8003e1e:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 8003e20:	68da      	ldr	r2, [r3, #12]
 8003e22:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8003e26:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003e28:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8003e2a:	2320      	movs	r3, #32
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003e2c:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8003e2e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8003e32:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  return HAL_OK;
 8003e36:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8003e38:	2001      	movs	r0, #1
}
 8003e3a:	bd10      	pop	{r4, pc}

08003e3c <HAL_UART_Transmit_DMA>:
{
 8003e3c:	b538      	push	{r3, r4, r5, lr}
 8003e3e:	4604      	mov	r4, r0
 8003e40:	4613      	mov	r3, r2
  if(huart->gState == HAL_UART_STATE_READY)
 8003e42:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8003e46:	2a20      	cmp	r2, #32
 8003e48:	d12a      	bne.n	8003ea0 <HAL_UART_Transmit_DMA+0x64>
    if((pData == NULL ) || (Size == 0))
 8003e4a:	b339      	cbz	r1, 8003e9c <HAL_UART_Transmit_DMA+0x60>
 8003e4c:	b333      	cbz	r3, 8003e9c <HAL_UART_Transmit_DMA+0x60>
    __HAL_LOCK(huart);
 8003e4e:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 8003e52:	2a01      	cmp	r2, #1
 8003e54:	d024      	beq.n	8003ea0 <HAL_UART_Transmit_DMA+0x64>
 8003e56:	2201      	movs	r2, #1
 8003e58:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8003e5c:	6b20      	ldr	r0, [r4, #48]	; 0x30
    huart->TxXferCount = Size;
 8003e5e:	84e3      	strh	r3, [r4, #38]	; 0x26
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003e60:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003e62:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003e64:	63e5      	str	r5, [r4, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003e66:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8003e6a:	4a0e      	ldr	r2, [pc, #56]	; (8003ea4 <HAL_UART_Transmit_DMA+0x68>)
    huart->TxXferSize = Size;
 8003e6c:	84a3      	strh	r3, [r4, #36]	; 0x24
    huart->pTxBuffPtr = pData;
 8003e6e:	6221      	str	r1, [r4, #32]
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8003e70:	63c2      	str	r2, [r0, #60]	; 0x3c
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8003e72:	4a0d      	ldr	r2, [pc, #52]	; (8003ea8 <HAL_UART_Transmit_DMA+0x6c>)
 8003e74:	6402      	str	r2, [r0, #64]	; 0x40
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 8003e76:	4a0d      	ldr	r2, [pc, #52]	; (8003eac <HAL_UART_Transmit_DMA+0x70>)
 8003e78:	64c2      	str	r2, [r0, #76]	; 0x4c
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
 8003e7a:	6822      	ldr	r2, [r4, #0]
    huart->hdmatx->XferAbortCallback = NULL;
 8003e7c:	6505      	str	r5, [r0, #80]	; 0x50
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
 8003e7e:	3204      	adds	r2, #4
 8003e80:	f7fd ff68 	bl	8001d54 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8003e84:	6823      	ldr	r3, [r4, #0]
 8003e86:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8003e8a:	601a      	str	r2, [r3, #0]
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8003e8c:	695a      	ldr	r2, [r3, #20]
    __HAL_UNLOCK(huart);
 8003e8e:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8003e92:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003e96:	615a      	str	r2, [r3, #20]
    return HAL_OK;
 8003e98:	4628      	mov	r0, r5
 8003e9a:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 8003e9c:	2001      	movs	r0, #1
 8003e9e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
 8003ea0:	2002      	movs	r0, #2
}
 8003ea2:	bd38      	pop	{r3, r4, r5, pc}
 8003ea4:	08003f41 	.word	0x08003f41
 8003ea8:	08003f6f 	.word	0x08003f6f
 8003eac:	08004035 	.word	0x08004035

08003eb0 <HAL_UART_Receive_DMA>:
{  
 8003eb0:	4613      	mov	r3, r2
  if(huart->RxState == HAL_UART_STATE_READY) 
 8003eb2:	f890 203a 	ldrb.w	r2, [r0, #58]	; 0x3a
 8003eb6:	2a20      	cmp	r2, #32
{  
 8003eb8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003eba:	4605      	mov	r5, r0
  if(huart->RxState == HAL_UART_STATE_READY) 
 8003ebc:	d138      	bne.n	8003f30 <HAL_UART_Receive_DMA+0x80>
    if((pData == NULL ) || (Size == 0)) 
 8003ebe:	2900      	cmp	r1, #0
 8003ec0:	d034      	beq.n	8003f2c <HAL_UART_Receive_DMA+0x7c>
 8003ec2:	2b00      	cmp	r3, #0
 8003ec4:	d032      	beq.n	8003f2c <HAL_UART_Receive_DMA+0x7c>
    __HAL_LOCK(huart);
 8003ec6:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38
 8003eca:	2a01      	cmp	r2, #1
 8003ecc:	d030      	beq.n	8003f30 <HAL_UART_Receive_DMA+0x80>
 8003ece:	2201      	movs	r2, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003ed0:	2400      	movs	r4, #0
    __HAL_LOCK(huart);
 8003ed2:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003ed6:	2222      	movs	r2, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003ed8:	63c4      	str	r4, [r0, #60]	; 0x3c
    huart->pRxBuffPtr = pData;
 8003eda:	6281      	str	r1, [r0, #40]	; 0x28
    huart->RxXferSize = Size;
 8003edc:	8583      	strh	r3, [r0, #44]	; 0x2c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003ede:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8003ee2:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8003ee4:	4a13      	ldr	r2, [pc, #76]	; (8003f34 <HAL_UART_Receive_DMA+0x84>)
 8003ee6:	63c2      	str	r2, [r0, #60]	; 0x3c
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 8003ee8:	682e      	ldr	r6, [r5, #0]
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8003eea:	4a13      	ldr	r2, [pc, #76]	; (8003f38 <HAL_UART_Receive_DMA+0x88>)
 8003eec:	6402      	str	r2, [r0, #64]	; 0x40
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8003eee:	4a13      	ldr	r2, [pc, #76]	; (8003f3c <HAL_UART_Receive_DMA+0x8c>)
 8003ef0:	64c2      	str	r2, [r0, #76]	; 0x4c
    huart->hdmarx->XferAbortCallback = NULL;
 8003ef2:	6504      	str	r4, [r0, #80]	; 0x50
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 8003ef4:	460a      	mov	r2, r1
 8003ef6:	1d31      	adds	r1, r6, #4
 8003ef8:	f7fd ff2c 	bl	8001d54 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_OREFLAG(huart);
 8003efc:	682b      	ldr	r3, [r5, #0]
 8003efe:	9401      	str	r4, [sp, #4]
 8003f00:	681a      	ldr	r2, [r3, #0]
 8003f02:	9201      	str	r2, [sp, #4]
 8003f04:	685a      	ldr	r2, [r3, #4]
 8003f06:	9201      	str	r2, [sp, #4]
 8003f08:	9a01      	ldr	r2, [sp, #4]
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003f0a:	68da      	ldr	r2, [r3, #12]
    __HAL_UNLOCK(huart);
 8003f0c:	f885 4038 	strb.w	r4, [r5, #56]	; 0x38
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003f10:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003f14:	60da      	str	r2, [r3, #12]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003f16:	695a      	ldr	r2, [r3, #20]
 8003f18:	f042 0201 	orr.w	r2, r2, #1
 8003f1c:	615a      	str	r2, [r3, #20]
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003f1e:	695a      	ldr	r2, [r3, #20]
 8003f20:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003f24:	615a      	str	r2, [r3, #20]
    return HAL_OK;
 8003f26:	4620      	mov	r0, r4
}
 8003f28:	b002      	add	sp, #8
 8003f2a:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8003f2c:	2001      	movs	r0, #1
 8003f2e:	e7fb      	b.n	8003f28 <HAL_UART_Receive_DMA+0x78>
    return HAL_BUSY; 
 8003f30:	2002      	movs	r0, #2
 8003f32:	e7f9      	b.n	8003f28 <HAL_UART_Receive_DMA+0x78>
 8003f34:	08003f7b 	.word	0x08003f7b
 8003f38:	08004029 	.word	0x08004029
 8003f3c:	08004035 	.word	0x08004035

08003f40 <UART_DMATransmitCplt>:
{
 8003f40:	b508      	push	{r3, lr}
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8003f42:	6803      	ldr	r3, [r0, #0]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003f44:	6b82      	ldr	r2, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8003f46:	681b      	ldr	r3, [r3, #0]
 8003f48:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8003f4c:	d10a      	bne.n	8003f64 <UART_DMATransmitCplt+0x24>
    huart->TxXferCount = 0U;
 8003f4e:	84d3      	strh	r3, [r2, #38]	; 0x26
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8003f50:	6813      	ldr	r3, [r2, #0]
 8003f52:	695a      	ldr	r2, [r3, #20]
 8003f54:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003f58:	615a      	str	r2, [r3, #20]
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003f5a:	68da      	ldr	r2, [r3, #12]
 8003f5c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003f60:	60da      	str	r2, [r3, #12]
 8003f62:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 8003f64:	4610      	mov	r0, r2
 8003f66:	f002 fb15 	bl	8006594 <HAL_UART_TxCpltCallback>
 8003f6a:	bd08      	pop	{r3, pc}

08003f6c <HAL_UART_TxHalfCpltCallback>:
 8003f6c:	4770      	bx	lr

08003f6e <UART_DMATxHalfCplt>:
{
 8003f6e:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 8003f70:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8003f72:	f7ff fffb 	bl	8003f6c <HAL_UART_TxHalfCpltCallback>
 8003f76:	bd08      	pop	{r3, pc}

08003f78 <HAL_UART_RxCpltCallback>:
 8003f78:	4770      	bx	lr

08003f7a <UART_DMAReceiveCplt>:
{
 8003f7a:	b508      	push	{r3, lr}
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8003f7c:	6803      	ldr	r3, [r0, #0]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003f7e:	6b82      	ldr	r2, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8003f80:	681b      	ldr	r3, [r3, #0]
 8003f82:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8003f86:	d110      	bne.n	8003faa <UART_DMAReceiveCplt+0x30>
    huart->RxXferCount = 0U;
 8003f88:	85d3      	strh	r3, [r2, #46]	; 0x2e
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003f8a:	6813      	ldr	r3, [r2, #0]
 8003f8c:	68d9      	ldr	r1, [r3, #12]
 8003f8e:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8003f92:	60d9      	str	r1, [r3, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003f94:	6959      	ldr	r1, [r3, #20]
 8003f96:	f021 0101 	bic.w	r1, r1, #1
 8003f9a:	6159      	str	r1, [r3, #20]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003f9c:	6959      	ldr	r1, [r3, #20]
 8003f9e:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8003fa2:	6159      	str	r1, [r3, #20]
    huart->RxState = HAL_UART_STATE_READY;
 8003fa4:	2320      	movs	r3, #32
 8003fa6:	f882 303a 	strb.w	r3, [r2, #58]	; 0x3a
  HAL_UART_RxCpltCallback(huart);
 8003faa:	4610      	mov	r0, r2
 8003fac:	f7ff ffe4 	bl	8003f78 <HAL_UART_RxCpltCallback>
 8003fb0:	bd08      	pop	{r3, pc}

08003fb2 <UART_Receive_IT>:
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8003fb2:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8003fb6:	2b22      	cmp	r3, #34	; 0x22
{
 8003fb8:	b510      	push	{r4, lr}
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8003fba:	d132      	bne.n	8004022 <UART_Receive_IT+0x70>
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8003fbc:	6883      	ldr	r3, [r0, #8]
 8003fbe:	6901      	ldr	r1, [r0, #16]
 8003fc0:	6802      	ldr	r2, [r0, #0]
 8003fc2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003fc6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003fc8:	d11f      	bne.n	800400a <UART_Receive_IT+0x58>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8003fca:	6852      	ldr	r2, [r2, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8003fcc:	b9c9      	cbnz	r1, 8004002 <UART_Receive_IT+0x50>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8003fce:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8003fd2:	f823 2b02 	strh.w	r2, [r3], #2
        huart->pRxBuffPtr += 1U;
 8003fd6:	6283      	str	r3, [r0, #40]	; 0x28
    if(--huart->RxXferCount == 0U)
 8003fd8:	8dc4      	ldrh	r4, [r0, #46]	; 0x2e
 8003fda:	3c01      	subs	r4, #1
 8003fdc:	b2a4      	uxth	r4, r4
 8003fde:	85c4      	strh	r4, [r0, #46]	; 0x2e
 8003fe0:	b96c      	cbnz	r4, 8003ffe <UART_Receive_IT+0x4c>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003fe2:	6803      	ldr	r3, [r0, #0]
 8003fe4:	68da      	ldr	r2, [r3, #12]
 8003fe6:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8003fea:	60da      	str	r2, [r3, #12]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003fec:	695a      	ldr	r2, [r3, #20]
 8003fee:	f022 0201 	bic.w	r2, r2, #1
 8003ff2:	615a      	str	r2, [r3, #20]
      huart->RxState = HAL_UART_STATE_READY;
 8003ff4:	2320      	movs	r3, #32
 8003ff6:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
      HAL_UART_RxCpltCallback(huart);
 8003ffa:	f7ff ffbd 	bl	8003f78 <HAL_UART_RxCpltCallback>
    if(--huart->RxXferCount == 0U)
 8003ffe:	2000      	movs	r0, #0
}
 8004000:	bd10      	pop	{r4, pc}
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8004002:	b2d2      	uxtb	r2, r2
 8004004:	f823 2b01 	strh.w	r2, [r3], #1
 8004008:	e7e5      	b.n	8003fd6 <UART_Receive_IT+0x24>
      if(huart->Init.Parity == UART_PARITY_NONE)
 800400a:	b921      	cbnz	r1, 8004016 <UART_Receive_IT+0x64>
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 800400c:	1c59      	adds	r1, r3, #1
 800400e:	6852      	ldr	r2, [r2, #4]
 8004010:	6281      	str	r1, [r0, #40]	; 0x28
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8004012:	701a      	strb	r2, [r3, #0]
 8004014:	e7e0      	b.n	8003fd8 <UART_Receive_IT+0x26>
 8004016:	6852      	ldr	r2, [r2, #4]
 8004018:	1c59      	adds	r1, r3, #1
 800401a:	6281      	str	r1, [r0, #40]	; 0x28
 800401c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8004020:	e7f7      	b.n	8004012 <UART_Receive_IT+0x60>
    return HAL_BUSY;
 8004022:	2002      	movs	r0, #2
 8004024:	bd10      	pop	{r4, pc}

08004026 <HAL_UART_RxHalfCpltCallback>:
 8004026:	4770      	bx	lr

08004028 <UART_DMARxHalfCplt>:
{
 8004028:	b508      	push	{r3, lr}
  HAL_UART_RxHalfCpltCallback(huart); 
 800402a:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800402c:	f7ff fffb 	bl	8004026 <HAL_UART_RxHalfCpltCallback>
 8004030:	bd08      	pop	{r3, pc}

08004032 <HAL_UART_ErrorCallback>:
 8004032:	4770      	bx	lr

08004034 <UART_DMAError>:
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8004034:	6b81      	ldr	r1, [r0, #56]	; 0x38
{
 8004036:	b508      	push	{r3, lr}
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8004038:	680b      	ldr	r3, [r1, #0]
 800403a:	695a      	ldr	r2, [r3, #20]
  if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 800403c:	f891 0039 	ldrb.w	r0, [r1, #57]	; 0x39
 8004040:	2821      	cmp	r0, #33	; 0x21
 8004042:	d10a      	bne.n	800405a <UART_DMAError+0x26>
 8004044:	0612      	lsls	r2, r2, #24
 8004046:	d508      	bpl.n	800405a <UART_DMAError+0x26>
    huart->TxXferCount = 0U;
 8004048:	2200      	movs	r2, #0
 800404a:	84ca      	strh	r2, [r1, #38]	; 0x26
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800404c:	68da      	ldr	r2, [r3, #12]
 800404e:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8004052:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 8004054:	2220      	movs	r2, #32
 8004056:	f881 2039 	strb.w	r2, [r1, #57]	; 0x39
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
 800405a:	695b      	ldr	r3, [r3, #20]
  if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 800405c:	f891 203a 	ldrb.w	r2, [r1, #58]	; 0x3a
 8004060:	2a22      	cmp	r2, #34	; 0x22
 8004062:	d106      	bne.n	8004072 <UART_DMAError+0x3e>
 8004064:	065b      	lsls	r3, r3, #25
 8004066:	d504      	bpl.n	8004072 <UART_DMAError+0x3e>
    huart->RxXferCount = 0U;
 8004068:	2300      	movs	r3, #0
 800406a:	85cb      	strh	r3, [r1, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 800406c:	4608      	mov	r0, r1
 800406e:	f7ff fd8f 	bl	8003b90 <UART_EndRxTransfer>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8004072:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8004074:	f043 0310 	orr.w	r3, r3, #16
 8004078:	63cb      	str	r3, [r1, #60]	; 0x3c
  HAL_UART_ErrorCallback(huart);
 800407a:	4608      	mov	r0, r1
 800407c:	f7ff ffd9 	bl	8004032 <HAL_UART_ErrorCallback>
 8004080:	bd08      	pop	{r3, pc}
	...

08004084 <HAL_UART_IRQHandler>:
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8004084:	6803      	ldr	r3, [r0, #0]
 8004086:	681a      	ldr	r2, [r3, #0]
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8004088:	68d9      	ldr	r1, [r3, #12]
{
 800408a:	b570      	push	{r4, r5, r6, lr}
  if(errorflags == RESET)
 800408c:	0716      	lsls	r6, r2, #28
{
 800408e:	4604      	mov	r4, r0
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8004090:	695d      	ldr	r5, [r3, #20]
  if(errorflags == RESET)
 8004092:	d107      	bne.n	80040a4 <HAL_UART_IRQHandler+0x20>
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8004094:	0696      	lsls	r6, r2, #26
 8004096:	d55a      	bpl.n	800414e <HAL_UART_IRQHandler+0xca>
 8004098:	068d      	lsls	r5, r1, #26
 800409a:	d558      	bpl.n	800414e <HAL_UART_IRQHandler+0xca>
}
 800409c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      UART_Receive_IT(huart);
 80040a0:	f7ff bf87 	b.w	8003fb2 <UART_Receive_IT>
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 80040a4:	f015 0501 	ands.w	r5, r5, #1
 80040a8:	d102      	bne.n	80040b0 <HAL_UART_IRQHandler+0x2c>
 80040aa:	f411 7f90 	tst.w	r1, #288	; 0x120
 80040ae:	d04e      	beq.n	800414e <HAL_UART_IRQHandler+0xca>
    if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 80040b0:	07d3      	lsls	r3, r2, #31
 80040b2:	d505      	bpl.n	80040c0 <HAL_UART_IRQHandler+0x3c>
 80040b4:	05ce      	lsls	r6, r1, #23
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80040b6:	bf42      	ittt	mi
 80040b8:	6be3      	ldrmi	r3, [r4, #60]	; 0x3c
 80040ba:	f043 0301 	orrmi.w	r3, r3, #1
 80040be:	63e3      	strmi	r3, [r4, #60]	; 0x3c
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80040c0:	0750      	lsls	r0, r2, #29
 80040c2:	d504      	bpl.n	80040ce <HAL_UART_IRQHandler+0x4a>
 80040c4:	b11d      	cbz	r5, 80040ce <HAL_UART_IRQHandler+0x4a>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80040c6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80040c8:	f043 0302 	orr.w	r3, r3, #2
 80040cc:	63e3      	str	r3, [r4, #60]	; 0x3c
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80040ce:	0793      	lsls	r3, r2, #30
 80040d0:	d504      	bpl.n	80040dc <HAL_UART_IRQHandler+0x58>
 80040d2:	b11d      	cbz	r5, 80040dc <HAL_UART_IRQHandler+0x58>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80040d4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80040d6:	f043 0304 	orr.w	r3, r3, #4
 80040da:	63e3      	str	r3, [r4, #60]	; 0x3c
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80040dc:	0716      	lsls	r6, r2, #28
 80040de:	d504      	bpl.n	80040ea <HAL_UART_IRQHandler+0x66>
 80040e0:	b11d      	cbz	r5, 80040ea <HAL_UART_IRQHandler+0x66>
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80040e2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80040e4:	f043 0308 	orr.w	r3, r3, #8
 80040e8:	63e3      	str	r3, [r4, #60]	; 0x3c
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 80040ea:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80040ec:	2b00      	cmp	r3, #0
 80040ee:	d066      	beq.n	80041be <HAL_UART_IRQHandler+0x13a>
      if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 80040f0:	0695      	lsls	r5, r2, #26
 80040f2:	d504      	bpl.n	80040fe <HAL_UART_IRQHandler+0x7a>
 80040f4:	0688      	lsls	r0, r1, #26
 80040f6:	d502      	bpl.n	80040fe <HAL_UART_IRQHandler+0x7a>
        UART_Receive_IT(huart);
 80040f8:	4620      	mov	r0, r4
 80040fa:	f7ff ff5a 	bl	8003fb2 <UART_Receive_IT>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 80040fe:	6823      	ldr	r3, [r4, #0]
 8004100:	695d      	ldr	r5, [r3, #20]
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8004102:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8004104:	0711      	lsls	r1, r2, #28
        UART_EndRxTransfer(huart);
 8004106:	4620      	mov	r0, r4
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8004108:	d402      	bmi.n	8004110 <HAL_UART_IRQHandler+0x8c>
 800410a:	f015 0540 	ands.w	r5, r5, #64	; 0x40
 800410e:	d01a      	beq.n	8004146 <HAL_UART_IRQHandler+0xc2>
        UART_EndRxTransfer(huart);
 8004110:	f7ff fd3e 	bl	8003b90 <UART_EndRxTransfer>
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004114:	6823      	ldr	r3, [r4, #0]
 8004116:	695a      	ldr	r2, [r3, #20]
 8004118:	0652      	lsls	r2, r2, #25
 800411a:	d510      	bpl.n	800413e <HAL_UART_IRQHandler+0xba>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800411c:	695a      	ldr	r2, [r3, #20]
          if(huart->hdmarx != NULL)
 800411e:	6b60      	ldr	r0, [r4, #52]	; 0x34
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8004120:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8004124:	615a      	str	r2, [r3, #20]
          if(huart->hdmarx != NULL)
 8004126:	b150      	cbz	r0, 800413e <HAL_UART_IRQHandler+0xba>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8004128:	4b25      	ldr	r3, [pc, #148]	; (80041c0 <HAL_UART_IRQHandler+0x13c>)
 800412a:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800412c:	f7fd fe50 	bl	8001dd0 <HAL_DMA_Abort_IT>
 8004130:	2800      	cmp	r0, #0
 8004132:	d044      	beq.n	80041be <HAL_UART_IRQHandler+0x13a>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8004134:	6b60      	ldr	r0, [r4, #52]	; 0x34
}
 8004136:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800413a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800413c:	4718      	bx	r3
            HAL_UART_ErrorCallback(huart);
 800413e:	4620      	mov	r0, r4
 8004140:	f7ff ff77 	bl	8004032 <HAL_UART_ErrorCallback>
 8004144:	bd70      	pop	{r4, r5, r6, pc}
        HAL_UART_ErrorCallback(huart);
 8004146:	f7ff ff74 	bl	8004032 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800414a:	63e5      	str	r5, [r4, #60]	; 0x3c
 800414c:	bd70      	pop	{r4, r5, r6, pc}
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 800414e:	0616      	lsls	r6, r2, #24
 8004150:	d527      	bpl.n	80041a2 <HAL_UART_IRQHandler+0x11e>
 8004152:	060d      	lsls	r5, r1, #24
 8004154:	d525      	bpl.n	80041a2 <HAL_UART_IRQHandler+0x11e>
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
 8004156:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 800415a:	2a21      	cmp	r2, #33	; 0x21
 800415c:	d12f      	bne.n	80041be <HAL_UART_IRQHandler+0x13a>
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 800415e:	68a2      	ldr	r2, [r4, #8]
 8004160:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8004164:	6a22      	ldr	r2, [r4, #32]
 8004166:	d117      	bne.n	8004198 <HAL_UART_IRQHandler+0x114>
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8004168:	8811      	ldrh	r1, [r2, #0]
 800416a:	f3c1 0108 	ubfx	r1, r1, #0, #9
 800416e:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8004170:	6921      	ldr	r1, [r4, #16]
 8004172:	b979      	cbnz	r1, 8004194 <HAL_UART_IRQHandler+0x110>
        huart->pTxBuffPtr += 2U;
 8004174:	3202      	adds	r2, #2
        huart->pTxBuffPtr += 1U;
 8004176:	6222      	str	r2, [r4, #32]
    if(--huart->TxXferCount == 0U)
 8004178:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 800417a:	3a01      	subs	r2, #1
 800417c:	b292      	uxth	r2, r2
 800417e:	84e2      	strh	r2, [r4, #38]	; 0x26
 8004180:	b9ea      	cbnz	r2, 80041be <HAL_UART_IRQHandler+0x13a>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8004182:	68da      	ldr	r2, [r3, #12]
 8004184:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8004188:	60da      	str	r2, [r3, #12]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800418a:	68da      	ldr	r2, [r3, #12]
 800418c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004190:	60da      	str	r2, [r3, #12]
 8004192:	bd70      	pop	{r4, r5, r6, pc}
        huart->pTxBuffPtr += 1U;
 8004194:	3201      	adds	r2, #1
 8004196:	e7ee      	b.n	8004176 <HAL_UART_IRQHandler+0xf2>
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8004198:	1c51      	adds	r1, r2, #1
 800419a:	6221      	str	r1, [r4, #32]
 800419c:	7812      	ldrb	r2, [r2, #0]
 800419e:	605a      	str	r2, [r3, #4]
 80041a0:	e7ea      	b.n	8004178 <HAL_UART_IRQHandler+0xf4>
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 80041a2:	0650      	lsls	r0, r2, #25
 80041a4:	d50b      	bpl.n	80041be <HAL_UART_IRQHandler+0x13a>
 80041a6:	064a      	lsls	r2, r1, #25
 80041a8:	d509      	bpl.n	80041be <HAL_UART_IRQHandler+0x13a>
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80041aa:	68da      	ldr	r2, [r3, #12]
 80041ac:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80041b0:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 80041b2:	2320      	movs	r3, #32
 80041b4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  HAL_UART_TxCpltCallback(huart);
 80041b8:	4620      	mov	r0, r4
 80041ba:	f002 f9eb 	bl	8006594 <HAL_UART_TxCpltCallback>
 80041be:	bd70      	pop	{r4, r5, r6, pc}
 80041c0:	080041c5 	.word	0x080041c5

080041c4 <UART_DMAAbortOnError>:
{
 80041c4:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80041c6:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 80041c8:	2300      	movs	r3, #0
 80041ca:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0U;
 80041cc:	84c3      	strh	r3, [r0, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 80041ce:	f7ff ff30 	bl	8004032 <HAL_UART_ErrorCallback>
 80041d2:	bd08      	pop	{r3, pc}

080041d4 <USB_CoreInit>:
  * @param  cfg  pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80041d4:	b084      	sub	sp, #16
 80041d6:	b538      	push	{r3, r4, r5, lr}
 80041d8:	ad05      	add	r5, sp, #20
 80041da:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80041de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80041e0:	2b01      	cmp	r3, #1
{
 80041e2:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80041e4:	d126      	bne.n	8004234 <USB_CoreInit+0x60>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80041e6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80041e8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80041ec:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80041ee:	68c3      	ldr	r3, [r0, #12]
 80041f0:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 80041f4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80041f8:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80041fa:	68c3      	ldr	r3, [r0, #12]
 80041fc:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8004200:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1U)
 8004202:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8004204:	2b01      	cmp	r3, #1
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8004206:	bf02      	ittt	eq
 8004208:	68c3      	ldreq	r3, [r0, #12]
 800420a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 800420e:	60c3      	streq	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8004210:	f000 f90a 	bl	8004428 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  }
 
  if(cfg.dma_enable == ENABLE)
 8004214:	9b08      	ldr	r3, [sp, #32]
 8004216:	2b01      	cmp	r3, #1
 8004218:	d107      	bne.n	800422a <USB_CoreInit+0x56>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800421a:	68a3      	ldr	r3, [r4, #8]
 800421c:	f043 0306 	orr.w	r3, r3, #6
 8004220:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8004222:	68a3      	ldr	r3, [r4, #8]
 8004224:	f043 0320 	orr.w	r3, r3, #32
 8004228:	60a3      	str	r3, [r4, #8]
  }  

  return HAL_OK;
}
 800422a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800422e:	2000      	movs	r0, #0
 8004230:	b004      	add	sp, #16
 8004232:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8004234:	68c3      	ldr	r3, [r0, #12]
 8004236:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800423a:	60c3      	str	r3, [r0, #12]
    USB_CoreReset(USBx);
 800423c:	f000 f8f4 	bl	8004428 <USB_CoreReset>
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8004240:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004244:	63a3      	str	r3, [r4, #56]	; 0x38
 8004246:	e7e5      	b.n	8004214 <USB_CoreInit+0x40>

08004248 <USB_DisableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8004248:	6883      	ldr	r3, [r0, #8]
 800424a:	f023 0301 	bic.w	r3, r3, #1
 800424e:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8004250:	2000      	movs	r0, #0
 8004252:	4770      	bx	lr

08004254 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 8004254:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8004256:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8004258:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 800425a:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800425e:	60c3      	str	r3, [r0, #12]
  if ( mode == USB_OTG_HOST_MODE)
 8004260:	d108      	bne.n	8004274 <USB_SetCurrentMode+0x20>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8004262:	68c3      	ldr	r3, [r0, #12]
 8004264:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004268:	60c3      	str	r3, [r0, #12]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  }
  HAL_Delay(50U);
 800426a:	2032      	movs	r0, #50	; 0x32
 800426c:	f7fd fb3e 	bl	80018ec <HAL_Delay>
  
  return HAL_OK;
}
 8004270:	2000      	movs	r0, #0
 8004272:	bd08      	pop	{r3, pc}
  else if ( mode == USB_OTG_DEVICE_MODE)
 8004274:	2900      	cmp	r1, #0
 8004276:	d1f8      	bne.n	800426a <USB_SetCurrentMode+0x16>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8004278:	68c3      	ldr	r3, [r0, #12]
 800427a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800427e:	60c3      	str	r3, [r0, #12]
 8004280:	e7f3      	b.n	800426a <USB_SetCurrentMode+0x16>
	...

08004284 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8004284:	b084      	sub	sp, #16
 8004286:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800428a:	4604      	mov	r4, r0
 800428c:	a807      	add	r0, sp, #28
 800428e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 8004292:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8004294:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  if (cfg.vbus_sensing_enable == 0U)
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8004296:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004298:	4688      	mov	r8, r1
  if (cfg.vbus_sensing_enable == 0U)
 800429a:	b9a6      	cbnz	r6, 80042c6 <USB_DevInit+0x42>
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 800429c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80042a0:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx || STM32F413xx || STM32F423xx  */
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 80042a2:	2300      	movs	r3, #0
 80042a4:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80042a8:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 80042ac:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 80042b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80042b2:	2b01      	cmp	r3, #1
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80042b4:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 80042b8:	d15e      	bne.n	8004378 <USB_DevInit+0xf4>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 80042ba:	9909      	ldr	r1, [sp, #36]	; 0x24
 80042bc:	b939      	cbnz	r1, 80042ce <USB_DevInit+0x4a>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 80042be:	4620      	mov	r0, r4
 80042c0:	f000 f89e 	bl	8004400 <USB_SetDevSpeed>
 80042c4:	e007      	b.n	80042d6 <USB_DevInit+0x52>
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 80042c6:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80042ca:	63a3      	str	r3, [r4, #56]	; 0x38
 80042cc:	e7e9      	b.n	80042a2 <USB_DevInit+0x1e>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 80042ce:	4619      	mov	r1, r3
 80042d0:	4620      	mov	r0, r4
 80042d2:	f000 f895 	bl	8004400 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 80042d6:	2110      	movs	r1, #16
 80042d8:	4620      	mov	r0, r4
 80042da:	f000 f86f 	bl	80043bc <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 80042de:	4620      	mov	r0, r4
 80042e0:	f000 f87e 	bl	80043e0 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 80042e4:	2300      	movs	r3, #0
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80042e6:	f04f 32ff 	mov.w	r2, #4294967295
  USBx_DEVICE->DIEPMSK = 0U;
 80042ea:	612b      	str	r3, [r5, #16]
 80042ec:	4619      	mov	r1, r3
  USBx_DEVICE->DOEPMSK = 0U;
 80042ee:	616b      	str	r3, [r5, #20]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 80042f0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80042f4:	61aa      	str	r2, [r5, #24]
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 80042f6:	f04f 0eff 	mov.w	lr, #255	; 0xff
  USBx_DEVICE->DAINTMSK = 0U;
 80042fa:	61eb      	str	r3, [r5, #28]
 80042fc:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004300:	4543      	cmp	r3, r8
 8004302:	d13b      	bne.n	800437c <USB_DevInit+0xf8>
 8004304:	2100      	movs	r1, #0
 8004306:	f504 6230 	add.w	r2, r4, #2816	; 0xb00
 800430a:	4608      	mov	r0, r1
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 800430c:	f04f 4e90 	mov.w	lr, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8004310:	f04f 0cff 	mov.w	ip, #255	; 0xff
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004314:	428b      	cmp	r3, r1
 8004316:	d13e      	bne.n	8004396 <USB_DevInit+0x112>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8004318:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 800431a:	2f01      	cmp	r7, #1
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800431c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004320:	612b      	str	r3, [r5, #16]
  if (cfg.dma_enable == 1U)
 8004322:	d108      	bne.n	8004336 <USB_DevInit+0xb2>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8004324:	4b23      	ldr	r3, [pc, #140]	; (80043b4 <USB_DevInit+0x130>)
 8004326:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8004328:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800432a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800432e:	f043 0303 	orr.w	r3, r3, #3
 8004332:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 8004334:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8004336:	2300      	movs	r3, #0
 8004338:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 800433a:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 800433e:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8004340:	b91f      	cbnz	r7, 800434a <USB_DevInit+0xc6>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8004342:	69a3      	ldr	r3, [r4, #24]
 8004344:	f043 0310 	orr.w	r3, r3, #16
 8004348:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 800434a:	69a2      	ldr	r2, [r4, #24]
 800434c:	4b1a      	ldr	r3, [pc, #104]	; (80043b8 <USB_DevInit+0x134>)
 800434e:	4313      	orrs	r3, r2
 8004350:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8004352:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004354:	b11b      	cbz	r3, 800435e <USB_DevInit+0xda>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8004356:	69a3      	ldr	r3, [r4, #24]
 8004358:	f043 0308 	orr.w	r3, r3, #8
 800435c:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 800435e:	2e01      	cmp	r6, #1
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8004360:	bf01      	itttt	eq
 8004362:	69a3      	ldreq	r3, [r4, #24]
 8004364:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 8004368:	f043 0304 	orreq.w	r3, r3, #4
 800436c:	61a3      	streq	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 800436e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8004372:	2000      	movs	r0, #0
 8004374:	b004      	add	sp, #16
 8004376:	4770      	bx	lr
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8004378:	2103      	movs	r1, #3
 800437a:	e7a0      	b.n	80042be <USB_DevInit+0x3a>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800437c:	f8d2 c000 	ldr.w	ip, [r2]
 8004380:	f1bc 0f00 	cmp.w	ip, #0
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8004384:	bfb4      	ite	lt
 8004386:	6010      	strlt	r0, [r2, #0]
      USBx_INEP(i)->DIEPCTL = 0U;
 8004388:	6011      	strge	r1, [r2, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800438a:	3301      	adds	r3, #1
    USBx_INEP(i)->DIEPTSIZ = 0U;
 800438c:	6111      	str	r1, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 800438e:	f8c2 e008 	str.w	lr, [r2, #8]
 8004392:	3220      	adds	r2, #32
 8004394:	e7b4      	b.n	8004300 <USB_DevInit+0x7c>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004396:	f8d2 8000 	ldr.w	r8, [r2]
 800439a:	f1b8 0f00 	cmp.w	r8, #0
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 800439e:	bfb4      	ite	lt
 80043a0:	f8c2 e000 	strlt.w	lr, [r2]
      USBx_OUTEP(i)->DOEPCTL = 0U;
 80043a4:	6010      	strge	r0, [r2, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80043a6:	3101      	adds	r1, #1
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 80043a8:	6110      	str	r0, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 80043aa:	f8c2 c008 	str.w	ip, [r2, #8]
 80043ae:	3220      	adds	r2, #32
 80043b0:	e7b0      	b.n	8004314 <USB_DevInit+0x90>
 80043b2:	bf00      	nop
 80043b4:	00800100 	.word	0x00800100
 80043b8:	803c3800 	.word	0x803c3800

080043bc <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 80043bc:	0189      	lsls	r1, r1, #6
 80043be:	f041 0120 	orr.w	r1, r1, #32
 80043c2:	4a06      	ldr	r2, [pc, #24]	; (80043dc <USB_FlushTxFifo+0x20>)
 80043c4:	6101      	str	r1, [r0, #16]
  
  do
  {
    if (++count > 200000)
 80043c6:	3a01      	subs	r2, #1
 80043c8:	d005      	beq.n	80043d6 <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 80043ca:	6903      	ldr	r3, [r0, #16]
 80043cc:	f013 0320 	ands.w	r3, r3, #32
 80043d0:	d1f9      	bne.n	80043c6 <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 80043d2:	4618      	mov	r0, r3
 80043d4:	4770      	bx	lr
      return HAL_TIMEOUT;
 80043d6:	2003      	movs	r0, #3
}
 80043d8:	4770      	bx	lr
 80043da:	bf00      	nop
 80043dc:	00030d41 	.word	0x00030d41

080043e0 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80043e0:	2310      	movs	r3, #16
 80043e2:	4a06      	ldr	r2, [pc, #24]	; (80043fc <USB_FlushRxFifo+0x1c>)
 80043e4:	6103      	str	r3, [r0, #16]
  
  do
  {
    if (++count > 200000)
 80043e6:	3a01      	subs	r2, #1
 80043e8:	d005      	beq.n	80043f6 <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80043ea:	6903      	ldr	r3, [r0, #16]
 80043ec:	f013 0310 	ands.w	r3, r3, #16
 80043f0:	d1f9      	bne.n	80043e6 <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 80043f2:	4618      	mov	r0, r3
 80043f4:	4770      	bx	lr
      return HAL_TIMEOUT;
 80043f6:	2003      	movs	r0, #3
}
 80043f8:	4770      	bx	lr
 80043fa:	bf00      	nop
 80043fc:	00030d41 	.word	0x00030d41

08004400 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 8004400:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8004404:	4319      	orrs	r1, r3
 8004406:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 800440a:	2000      	movs	r0, #0
 800440c:	4770      	bx	lr

0800440e <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 800440e:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 8004410:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8004414:	f043 0302 	orr.w	r3, r3, #2
 8004418:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 800441c:	2003      	movs	r0, #3
 800441e:	f7fd fa65 	bl	80018ec <HAL_Delay>
  
  return HAL_OK;  
}
 8004422:	2000      	movs	r0, #0
 8004424:	bd08      	pop	{r3, pc}
	...

08004428 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8004428:	4b0a      	ldr	r3, [pc, #40]	; (8004454 <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 800442a:	3b01      	subs	r3, #1
 800442c:	d101      	bne.n	8004432 <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 800442e:	2003      	movs	r0, #3
 8004430:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8004432:	6902      	ldr	r2, [r0, #16]
 8004434:	2a00      	cmp	r2, #0
 8004436:	daf8      	bge.n	800442a <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8004438:	6903      	ldr	r3, [r0, #16]
 800443a:	4a06      	ldr	r2, [pc, #24]	; (8004454 <USB_CoreReset+0x2c>)
 800443c:	f043 0301 	orr.w	r3, r3, #1
 8004440:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000U)
 8004442:	3a01      	subs	r2, #1
 8004444:	d0f3      	beq.n	800442e <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8004446:	6903      	ldr	r3, [r0, #16]
 8004448:	f013 0301 	ands.w	r3, r3, #1
 800444c:	d1f9      	bne.n	8004442 <USB_CoreReset+0x1a>
  
  return HAL_OK;
 800444e:	4618      	mov	r0, r3
}
 8004450:	4770      	bx	lr
 8004452:	bf00      	nop
 8004454:	00030d41 	.word	0x00030d41

08004458 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8004458:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 800445a:	f001 f8b3 	bl	80055c4 <vTaskStartScheduler>
  
  return osOK;
}
 800445e:	2000      	movs	r0, #0
 8004460:	bd08      	pop	{r3, pc}

08004462 <osKernelSysTick>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8004462:	f3ef 8305 	mrs	r3, IPSR
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
  if (inHandlerMode()) {
 8004466:	b10b      	cbz	r3, 800446c <osKernelSysTick+0xa>
    return xTaskGetTickCountFromISR();
 8004468:	f001 b8f6 	b.w	8005658 <xTaskGetTickCountFromISR>
  }
  else {
    return xTaskGetTickCount();
 800446c:	f001 b8ee 	b.w	800564c <xTaskGetTickCount>

08004470 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8004470:	b530      	push	{r4, r5, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8004472:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 8004476:	8a02      	ldrh	r2, [r0, #16]
{
 8004478:	460b      	mov	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800447a:	e890 0022 	ldmia.w	r0, {r1, r5}
{
 800447e:	b085      	sub	sp, #20
  if (priority != osPriorityError) {
 8004480:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 8004482:	bf14      	ite	ne
 8004484:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8004486:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8004488:	a803      	add	r0, sp, #12
 800448a:	9001      	str	r0, [sp, #4]
 800448c:	9400      	str	r4, [sp, #0]
 800448e:	4628      	mov	r0, r5
 8004490:	f000 fed0 	bl	8005234 <xTaskCreate>
 8004494:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8004496:	bf0c      	ite	eq
 8004498:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 800449a:	2000      	movne	r0, #0
}
 800449c:	b005      	add	sp, #20
 800449e:	bd30      	pop	{r4, r5, pc}

080044a0 <osThreadGetId>:
* @note   MUST REMAIN UNCHANGED: \b osThreadGetId shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadGetId (void)
{
#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
  return xTaskGetCurrentTaskHandle();
 80044a0:	f001 bb86 	b.w	8005bb0 <xTaskGetCurrentTaskHandle>

080044a4 <osThreadSetPriority>:
* @param   priority      new priority value for the thread function.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadSetPriority shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority)
{
 80044a4:	b508      	push	{r3, lr}
  if (priority != osPriorityError) {
 80044a6:	2984      	cmp	r1, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 80044a8:	bf14      	ite	ne
 80044aa:	3103      	addne	r1, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80044ac:	2100      	moveq	r1, #0
#if (INCLUDE_vTaskPrioritySet == 1)
  vTaskPrioritySet(thread_id, makeFreeRtosPriority(priority));
 80044ae:	f000 ff8b 	bl	80053c8 <vTaskPrioritySet>
  return osOK;
#else
  return osErrorOS;
#endif
}
 80044b2:	2000      	movs	r0, #0
 80044b4:	bd08      	pop	{r3, pc}

080044b6 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 80044b6:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 80044b8:	2800      	cmp	r0, #0
 80044ba:	bf08      	it	eq
 80044bc:	2001      	moveq	r0, #1
 80044be:	f001 f9dd 	bl	800587c <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 80044c2:	2000      	movs	r0, #0
 80044c4:	bd08      	pop	{r3, pc}

080044c6 <osSemaphoreCreate>:
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 80044c6:	2901      	cmp	r1, #1
{ 
 80044c8:	b510      	push	{r4, lr}
 80044ca:	4608      	mov	r0, r1
  if (count == 1) {
 80044cc:	d10c      	bne.n	80044e8 <osSemaphoreCreate+0x22>
    vSemaphoreCreateBinary(sema);
 80044ce:	2203      	movs	r2, #3
 80044d0:	2100      	movs	r1, #0
 80044d2:	f000 fbf7 	bl	8004cc4 <xQueueGenericCreate>
 80044d6:	4604      	mov	r4, r0
 80044d8:	b120      	cbz	r0, 80044e4 <osSemaphoreCreate+0x1e>
 80044da:	2300      	movs	r3, #0
 80044dc:	461a      	mov	r2, r3
 80044de:	4619      	mov	r1, r3
 80044e0:	f000 fc12 	bl	8004d08 <xQueueGenericSend>
#else
    return NULL;
#endif
  }
#endif
}
 80044e4:	4620      	mov	r0, r4
 80044e6:	bd10      	pop	{r4, pc}
    return NULL;
 80044e8:	2400      	movs	r4, #0
 80044ea:	e7fb      	b.n	80044e4 <osSemaphoreCreate+0x1e>

080044ec <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 80044ec:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 80044ee:	2400      	movs	r4, #0
{
 80044f0:	460a      	mov	r2, r1
  portBASE_TYPE taskWoken = pdFALSE;  
 80044f2:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 80044f4:	b1e8      	cbz	r0, 8004532 <osSemaphoreWait+0x46>
 80044f6:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 80044fa:	b1a3      	cbz	r3, 8004526 <osSemaphoreWait+0x3a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 80044fc:	aa01      	add	r2, sp, #4
 80044fe:	4621      	mov	r1, r4
 8004500:	f000 fdd0 	bl	80050a4 <xQueueReceiveFromISR>
 8004504:	2801      	cmp	r0, #1
 8004506:	d002      	beq.n	800450e <osSemaphoreWait+0x22>
      return osErrorOS;
 8004508:	20ff      	movs	r0, #255	; 0xff
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 800450a:	b002      	add	sp, #8
 800450c:	bd10      	pop	{r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 800450e:	9b01      	ldr	r3, [sp, #4]
 8004510:	b13b      	cbz	r3, 8004522 <osSemaphoreWait+0x36>
 8004512:	4b09      	ldr	r3, [pc, #36]	; (8004538 <osSemaphoreWait+0x4c>)
 8004514:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004518:	601a      	str	r2, [r3, #0]
 800451a:	f3bf 8f4f 	dsb	sy
 800451e:	f3bf 8f6f 	isb	sy
  return osOK;
 8004522:	2000      	movs	r0, #0
 8004524:	e7f1      	b.n	800450a <osSemaphoreWait+0x1e>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8004526:	4619      	mov	r1, r3
 8004528:	f000 fcf8 	bl	8004f1c <xQueueGenericReceive>
 800452c:	2801      	cmp	r0, #1
 800452e:	d1eb      	bne.n	8004508 <osSemaphoreWait+0x1c>
 8004530:	e7f7      	b.n	8004522 <osSemaphoreWait+0x36>
    return osErrorParameter;
 8004532:	2080      	movs	r0, #128	; 0x80
 8004534:	e7e9      	b.n	800450a <osSemaphoreWait+0x1e>
 8004536:	bf00      	nop
 8004538:	e000ed04 	.word	0xe000ed04

0800453c <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 800453c:	b513      	push	{r0, r1, r4, lr}
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 800453e:	2400      	movs	r4, #0
 8004540:	9401      	str	r4, [sp, #4]
 8004542:	f3ef 8305 	mrs	r3, IPSR
  
  
  if (inHandlerMode()) {
 8004546:	b193      	cbz	r3, 800456e <osSemaphoreRelease+0x32>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8004548:	a901      	add	r1, sp, #4
 800454a:	f000 fc93 	bl	8004e74 <xQueueGiveFromISR>
 800454e:	2801      	cmp	r0, #1
 8004550:	d113      	bne.n	800457a <osSemaphoreRelease+0x3e>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8004552:	9b01      	ldr	r3, [sp, #4]
 8004554:	b913      	cbnz	r3, 800455c <osSemaphoreRelease+0x20>
  osStatus result = osOK;
 8004556:	2000      	movs	r0, #0
      result = osErrorOS;
    }
  }
  
  return result;
}
 8004558:	b002      	add	sp, #8
 800455a:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 800455c:	4b08      	ldr	r3, [pc, #32]	; (8004580 <osSemaphoreRelease+0x44>)
 800455e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004562:	601a      	str	r2, [r3, #0]
 8004564:	f3bf 8f4f 	dsb	sy
 8004568:	f3bf 8f6f 	isb	sy
 800456c:	e7f3      	b.n	8004556 <osSemaphoreRelease+0x1a>
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 800456e:	461a      	mov	r2, r3
 8004570:	4619      	mov	r1, r3
 8004572:	f000 fbc9 	bl	8004d08 <xQueueGenericSend>
 8004576:	2801      	cmp	r0, #1
 8004578:	d0ed      	beq.n	8004556 <osSemaphoreRelease+0x1a>
      result = osErrorOS;
 800457a:	20ff      	movs	r0, #255	; 0xff
 800457c:	e7ec      	b.n	8004558 <osSemaphoreRelease+0x1c>
 800457e:	bf00      	nop
 8004580:	e000ed04 	.word	0xe000ed04

08004584 <osThreadSuspend>:
* @brief  Suspend execution of a thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
*/
osStatus osThreadSuspend (osThreadId thread_id)
{
 8004584:	b508      	push	{r3, lr}
#if (INCLUDE_vTaskSuspend == 1)
    vTaskSuspend(thread_id);
 8004586:	f001 fa01 	bl	800598c <vTaskSuspend>
  
  return osOK;
#else
  return osErrorResource;
#endif
}
 800458a:	2000      	movs	r0, #0
 800458c:	bd08      	pop	{r3, pc}
	...

08004590 <osThreadResume>:
* @brief  Resume execution of a suspended thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
*/
osStatus osThreadResume (osThreadId thread_id)
{
 8004590:	b508      	push	{r3, lr}
 8004592:	f3ef 8305 	mrs	r3, IPSR
#if (INCLUDE_vTaskSuspend == 1)  
  if(inHandlerMode())
 8004596:	b16b      	cbz	r3, 80045b4 <osThreadResume+0x24>
  {
    if (xTaskResumeFromISR(thread_id) == pdTRUE)
 8004598:	f000 ffc4 	bl	8005524 <xTaskResumeFromISR>
 800459c:	2801      	cmp	r0, #1
 800459e:	d107      	bne.n	80045b0 <osThreadResume+0x20>
    {
      portYIELD_FROM_ISR(pdTRUE);
 80045a0:	4b06      	ldr	r3, [pc, #24]	; (80045bc <osThreadResume+0x2c>)
 80045a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80045a6:	601a      	str	r2, [r3, #0]
 80045a8:	f3bf 8f4f 	dsb	sy
 80045ac:	f3bf 8f6f 	isb	sy
  }
  return osOK;
#else
  return osErrorResource;
#endif
}
 80045b0:	2000      	movs	r0, #0
 80045b2:	bd08      	pop	{r3, pc}
    vTaskResume(thread_id);
 80045b4:	f000 ff74 	bl	80054a0 <vTaskResume>
 80045b8:	e7fa      	b.n	80045b0 <osThreadResume+0x20>
 80045ba:	bf00      	nop
 80045bc:	e000ed04 	.word	0xe000ed04

080045c0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80045c0:	f100 0308 	add.w	r3, r0, #8
 80045c4:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80045c6:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80045ca:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80045cc:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80045ce:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80045d0:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80045d2:	6003      	str	r3, [r0, #0]
 80045d4:	4770      	bx	lr

080045d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80045d6:	2300      	movs	r3, #0
 80045d8:	6103      	str	r3, [r0, #16]
 80045da:	4770      	bx	lr

080045dc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80045dc:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80045de:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80045e0:	689a      	ldr	r2, [r3, #8]
 80045e2:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80045e4:	689a      	ldr	r2, [r3, #8]
 80045e6:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80045e8:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80045ea:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80045ec:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80045ee:	3301      	adds	r3, #1
 80045f0:	6003      	str	r3, [r0, #0]
 80045f2:	4770      	bx	lr

080045f4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80045f4:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80045f6:	1c53      	adds	r3, r2, #1
{
 80045f8:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 80045fa:	d10a      	bne.n	8004612 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80045fc:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80045fe:	685a      	ldr	r2, [r3, #4]
 8004600:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8004602:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8004604:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8004606:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004608:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800460a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800460c:	3301      	adds	r3, #1
 800460e:	6003      	str	r3, [r0, #0]
 8004610:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004612:	f100 0308 	add.w	r3, r0, #8
 8004616:	685c      	ldr	r4, [r3, #4]
 8004618:	6825      	ldr	r5, [r4, #0]
 800461a:	42aa      	cmp	r2, r5
 800461c:	d3ef      	bcc.n	80045fe <vListInsert+0xa>
 800461e:	4623      	mov	r3, r4
 8004620:	e7f9      	b.n	8004616 <vListInsert+0x22>

08004622 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004622:	6841      	ldr	r1, [r0, #4]
 8004624:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8004626:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004628:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800462a:	6882      	ldr	r2, [r0, #8]
 800462c:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800462e:	6859      	ldr	r1, [r3, #4]
 8004630:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004632:	bf08      	it	eq
 8004634:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8004636:	2200      	movs	r2, #0
 8004638:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800463a:	6818      	ldr	r0, [r3, #0]
 800463c:	3801      	subs	r0, #1
 800463e:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8004640:	4770      	bx	lr
	...

08004644 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8004644:	4b0a      	ldr	r3, [pc, #40]	; (8004670 <prvTaskExitError+0x2c>)
 8004646:	681b      	ldr	r3, [r3, #0]
 8004648:	3301      	adds	r3, #1
 800464a:	d008      	beq.n	800465e <prvTaskExitError+0x1a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800464c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004650:	f383 8811 	msr	BASEPRI, r3
 8004654:	f3bf 8f6f 	isb	sy
 8004658:	f3bf 8f4f 	dsb	sy
 800465c:	e7fe      	b.n	800465c <prvTaskExitError+0x18>
 800465e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004662:	f383 8811 	msr	BASEPRI, r3
 8004666:	f3bf 8f6f 	isb	sy
 800466a:	f3bf 8f4f 	dsb	sy
 800466e:	e7fe      	b.n	800466e <prvTaskExitError+0x2a>
 8004670:	20000008 	.word	0x20000008

08004674 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004674:	4806      	ldr	r0, [pc, #24]	; (8004690 <prvPortStartFirstTask+0x1c>)
 8004676:	6800      	ldr	r0, [r0, #0]
 8004678:	6800      	ldr	r0, [r0, #0]
 800467a:	f380 8808 	msr	MSP, r0
 800467e:	b662      	cpsie	i
 8004680:	b661      	cpsie	f
 8004682:	f3bf 8f4f 	dsb	sy
 8004686:	f3bf 8f6f 	isb	sy
 800468a:	df00      	svc	0
 800468c:	bf00      	nop
 800468e:	0000      	.short	0x0000
 8004690:	e000ed08 	.word	0xe000ed08

08004694 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8004694:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80046a4 <vPortEnableVFP+0x10>
 8004698:	6801      	ldr	r1, [r0, #0]
 800469a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800469e:	6001      	str	r1, [r0, #0]
 80046a0:	4770      	bx	lr
 80046a2:	0000      	.short	0x0000
 80046a4:	e000ed88 	.word	0xe000ed88

080046a8 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80046a8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80046ac:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80046b0:	4b07      	ldr	r3, [pc, #28]	; (80046d0 <pxPortInitialiseStack+0x28>)
 80046b2:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80046b6:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80046ba:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80046be:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80046c2:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80046c6:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80046ca:	3844      	subs	r0, #68	; 0x44
 80046cc:	4770      	bx	lr
 80046ce:	bf00      	nop
 80046d0:	08004645 	.word	0x08004645
	...

080046e0 <SVC_Handler>:
	__asm volatile (
 80046e0:	4b07      	ldr	r3, [pc, #28]	; (8004700 <pxCurrentTCBConst2>)
 80046e2:	6819      	ldr	r1, [r3, #0]
 80046e4:	6808      	ldr	r0, [r1, #0]
 80046e6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80046ea:	f380 8809 	msr	PSP, r0
 80046ee:	f3bf 8f6f 	isb	sy
 80046f2:	f04f 0000 	mov.w	r0, #0
 80046f6:	f380 8811 	msr	BASEPRI, r0
 80046fa:	4770      	bx	lr
 80046fc:	f3af 8000 	nop.w

08004700 <pxCurrentTCBConst2>:
 8004700:	20003e44 	.word	0x20003e44

08004704 <vPortEnterCritical>:
 8004704:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004708:	f383 8811 	msr	BASEPRI, r3
 800470c:	f3bf 8f6f 	isb	sy
 8004710:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8004714:	4a0a      	ldr	r2, [pc, #40]	; (8004740 <vPortEnterCritical+0x3c>)
 8004716:	6813      	ldr	r3, [r2, #0]
 8004718:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800471a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800471c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800471e:	d10d      	bne.n	800473c <vPortEnterCritical+0x38>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8004720:	4b08      	ldr	r3, [pc, #32]	; (8004744 <vPortEnterCritical+0x40>)
 8004722:	681b      	ldr	r3, [r3, #0]
 8004724:	f013 0fff 	tst.w	r3, #255	; 0xff
 8004728:	d008      	beq.n	800473c <vPortEnterCritical+0x38>
 800472a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800472e:	f383 8811 	msr	BASEPRI, r3
 8004732:	f3bf 8f6f 	isb	sy
 8004736:	f3bf 8f4f 	dsb	sy
 800473a:	e7fe      	b.n	800473a <vPortEnterCritical+0x36>
 800473c:	4770      	bx	lr
 800473e:	bf00      	nop
 8004740:	20000008 	.word	0x20000008
 8004744:	e000ed04 	.word	0xe000ed04

08004748 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8004748:	4a08      	ldr	r2, [pc, #32]	; (800476c <vPortExitCritical+0x24>)
 800474a:	6813      	ldr	r3, [r2, #0]
 800474c:	b943      	cbnz	r3, 8004760 <vPortExitCritical+0x18>
 800474e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004752:	f383 8811 	msr	BASEPRI, r3
 8004756:	f3bf 8f6f 	isb	sy
 800475a:	f3bf 8f4f 	dsb	sy
 800475e:	e7fe      	b.n	800475e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8004760:	3b01      	subs	r3, #1
 8004762:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004764:	b90b      	cbnz	r3, 800476a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8004766:	f383 8811 	msr	BASEPRI, r3
 800476a:	4770      	bx	lr
 800476c:	20000008 	.word	0x20000008

08004770 <PendSV_Handler>:
	__asm volatile
 8004770:	f3ef 8009 	mrs	r0, PSP
 8004774:	f3bf 8f6f 	isb	sy
 8004778:	4b15      	ldr	r3, [pc, #84]	; (80047d0 <pxCurrentTCBConst>)
 800477a:	681a      	ldr	r2, [r3, #0]
 800477c:	f01e 0f10 	tst.w	lr, #16
 8004780:	bf08      	it	eq
 8004782:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8004786:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800478a:	6010      	str	r0, [r2, #0]
 800478c:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8004790:	f04f 0050 	mov.w	r0, #80	; 0x50
 8004794:	f380 8811 	msr	BASEPRI, r0
 8004798:	f3bf 8f4f 	dsb	sy
 800479c:	f3bf 8f6f 	isb	sy
 80047a0:	f001 f8ba 	bl	8005918 <vTaskSwitchContext>
 80047a4:	f04f 0000 	mov.w	r0, #0
 80047a8:	f380 8811 	msr	BASEPRI, r0
 80047ac:	bc08      	pop	{r3}
 80047ae:	6819      	ldr	r1, [r3, #0]
 80047b0:	6808      	ldr	r0, [r1, #0]
 80047b2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80047b6:	f01e 0f10 	tst.w	lr, #16
 80047ba:	bf08      	it	eq
 80047bc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80047c0:	f380 8809 	msr	PSP, r0
 80047c4:	f3bf 8f6f 	isb	sy
 80047c8:	4770      	bx	lr
 80047ca:	bf00      	nop
 80047cc:	f3af 8000 	nop.w

080047d0 <pxCurrentTCBConst>:
 80047d0:	20003e44 	.word	0x20003e44

080047d4 <SysTick_Handler>:
{
 80047d4:	b508      	push	{r3, lr}
	__asm volatile
 80047d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80047da:	f383 8811 	msr	BASEPRI, r3
 80047de:	f3bf 8f6f 	isb	sy
 80047e2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80047e6:	f000 ff3f 	bl	8005668 <xTaskIncrementTick>
 80047ea:	b118      	cbz	r0, 80047f4 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80047ec:	4b03      	ldr	r3, [pc, #12]	; (80047fc <SysTick_Handler+0x28>)
 80047ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80047f2:	601a      	str	r2, [r3, #0]
	__asm volatile
 80047f4:	2300      	movs	r3, #0
 80047f6:	f383 8811 	msr	BASEPRI, r3
 80047fa:	bd08      	pop	{r3, pc}
 80047fc:	e000ed04 	.word	0xe000ed04

08004800 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004800:	4b06      	ldr	r3, [pc, #24]	; (800481c <vPortSetupTimerInterrupt+0x1c>)
 8004802:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8004806:	681b      	ldr	r3, [r3, #0]
 8004808:	fbb3 f3f2 	udiv	r3, r3, r2
 800480c:	4a04      	ldr	r2, [pc, #16]	; (8004820 <vPortSetupTimerInterrupt+0x20>)
 800480e:	3b01      	subs	r3, #1
 8004810:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004812:	4b04      	ldr	r3, [pc, #16]	; (8004824 <vPortSetupTimerInterrupt+0x24>)
 8004814:	2207      	movs	r2, #7
 8004816:	601a      	str	r2, [r3, #0]
 8004818:	4770      	bx	lr
 800481a:	bf00      	nop
 800481c:	20000000 	.word	0x20000000
 8004820:	e000e014 	.word	0xe000e014
 8004824:	e000e010 	.word	0xe000e010

08004828 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8004828:	4b31      	ldr	r3, [pc, #196]	; (80048f0 <xPortStartScheduler+0xc8>)
 800482a:	4a32      	ldr	r2, [pc, #200]	; (80048f4 <xPortStartScheduler+0xcc>)
{
 800482c:	b513      	push	{r0, r1, r4, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800482e:	6819      	ldr	r1, [r3, #0]
 8004830:	4291      	cmp	r1, r2
 8004832:	d108      	bne.n	8004846 <xPortStartScheduler+0x1e>
	__asm volatile
 8004834:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004838:	f383 8811 	msr	BASEPRI, r3
 800483c:	f3bf 8f6f 	isb	sy
 8004840:	f3bf 8f4f 	dsb	sy
 8004844:	e7fe      	b.n	8004844 <xPortStartScheduler+0x1c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8004846:	681a      	ldr	r2, [r3, #0]
 8004848:	4b2b      	ldr	r3, [pc, #172]	; (80048f8 <xPortStartScheduler+0xd0>)
 800484a:	429a      	cmp	r2, r3
 800484c:	d108      	bne.n	8004860 <xPortStartScheduler+0x38>
 800484e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004852:	f383 8811 	msr	BASEPRI, r3
 8004856:	f3bf 8f6f 	isb	sy
 800485a:	f3bf 8f4f 	dsb	sy
 800485e:	e7fe      	b.n	800485e <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004860:	4b26      	ldr	r3, [pc, #152]	; (80048fc <xPortStartScheduler+0xd4>)
 8004862:	781a      	ldrb	r2, [r3, #0]
 8004864:	b2d2      	uxtb	r2, r2
 8004866:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8004868:	22ff      	movs	r2, #255	; 0xff
 800486a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800486c:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800486e:	4a24      	ldr	r2, [pc, #144]	; (8004900 <xPortStartScheduler+0xd8>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004870:	b2db      	uxtb	r3, r3
 8004872:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004876:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800487a:	f003 0350 	and.w	r3, r3, #80	; 0x50
 800487e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8004880:	4b20      	ldr	r3, [pc, #128]	; (8004904 <xPortStartScheduler+0xdc>)
 8004882:	2207      	movs	r2, #7
 8004884:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004886:	2100      	movs	r1, #0
 8004888:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800488c:	0600      	lsls	r0, r0, #24
 800488e:	f102 34ff 	add.w	r4, r2, #4294967295
 8004892:	d423      	bmi.n	80048dc <xPortStartScheduler+0xb4>
 8004894:	b101      	cbz	r1, 8004898 <xPortStartScheduler+0x70>
 8004896:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8004898:	681a      	ldr	r2, [r3, #0]
 800489a:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800489c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80048a0:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80048a2:	9b01      	ldr	r3, [sp, #4]
 80048a4:	4a15      	ldr	r2, [pc, #84]	; (80048fc <xPortStartScheduler+0xd4>)
 80048a6:	b2db      	uxtb	r3, r3
 80048a8:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80048aa:	4b17      	ldr	r3, [pc, #92]	; (8004908 <xPortStartScheduler+0xe0>)
 80048ac:	681a      	ldr	r2, [r3, #0]
 80048ae:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80048b2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80048b4:	681a      	ldr	r2, [r3, #0]
 80048b6:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 80048ba:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 80048bc:	f7ff ffa0 	bl	8004800 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80048c0:	4b12      	ldr	r3, [pc, #72]	; (800490c <xPortStartScheduler+0xe4>)
 80048c2:	2200      	movs	r2, #0
 80048c4:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
 80048c6:	f7ff fee5 	bl	8004694 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80048ca:	4a11      	ldr	r2, [pc, #68]	; (8004910 <xPortStartScheduler+0xe8>)
 80048cc:	6813      	ldr	r3, [r2, #0]
 80048ce:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80048d2:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 80048d4:	f7ff fece 	bl	8004674 <prvPortStartFirstTask>
	prvTaskExitError();
 80048d8:	f7ff feb4 	bl	8004644 <prvTaskExitError>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80048dc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80048e0:	0052      	lsls	r2, r2, #1
 80048e2:	b2d2      	uxtb	r2, r2
 80048e4:	f88d 2003 	strb.w	r2, [sp, #3]
 80048e8:	2101      	movs	r1, #1
 80048ea:	4622      	mov	r2, r4
 80048ec:	e7cc      	b.n	8004888 <xPortStartScheduler+0x60>
 80048ee:	bf00      	nop
 80048f0:	e000ed00 	.word	0xe000ed00
 80048f4:	410fc271 	.word	0x410fc271
 80048f8:	410fc270 	.word	0x410fc270
 80048fc:	e000e400 	.word	0xe000e400
 8004900:	20000224 	.word	0x20000224
 8004904:	20000228 	.word	0x20000228
 8004908:	e000ed20 	.word	0xe000ed20
 800490c:	20000008 	.word	0x20000008
 8004910:	e000ef34 	.word	0xe000ef34

08004914 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004914:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004918:	2b0f      	cmp	r3, #15
 800491a:	d90e      	bls.n	800493a <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800491c:	4a10      	ldr	r2, [pc, #64]	; (8004960 <vPortValidateInterruptPriority+0x4c>)
 800491e:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004920:	4a10      	ldr	r2, [pc, #64]	; (8004964 <vPortValidateInterruptPriority+0x50>)
 8004922:	7812      	ldrb	r2, [r2, #0]
 8004924:	429a      	cmp	r2, r3
 8004926:	d908      	bls.n	800493a <vPortValidateInterruptPriority+0x26>
 8004928:	f04f 0350 	mov.w	r3, #80	; 0x50
 800492c:	f383 8811 	msr	BASEPRI, r3
 8004930:	f3bf 8f6f 	isb	sy
 8004934:	f3bf 8f4f 	dsb	sy
 8004938:	e7fe      	b.n	8004938 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800493a:	4b0b      	ldr	r3, [pc, #44]	; (8004968 <vPortValidateInterruptPriority+0x54>)
 800493c:	4a0b      	ldr	r2, [pc, #44]	; (800496c <vPortValidateInterruptPriority+0x58>)
 800493e:	681b      	ldr	r3, [r3, #0]
 8004940:	6812      	ldr	r2, [r2, #0]
 8004942:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004946:	4293      	cmp	r3, r2
 8004948:	d908      	bls.n	800495c <vPortValidateInterruptPriority+0x48>
 800494a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800494e:	f383 8811 	msr	BASEPRI, r3
 8004952:	f3bf 8f6f 	isb	sy
 8004956:	f3bf 8f4f 	dsb	sy
 800495a:	e7fe      	b.n	800495a <vPortValidateInterruptPriority+0x46>
 800495c:	4770      	bx	lr
 800495e:	bf00      	nop
 8004960:	e000e3f0 	.word	0xe000e3f0
 8004964:	20000224 	.word	0x20000224
 8004968:	e000ed0c 	.word	0xe000ed0c
 800496c:	20000228 	.word	0x20000228

08004970 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8004970:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8004972:	4b0f      	ldr	r3, [pc, #60]	; (80049b0 <prvInsertBlockIntoFreeList+0x40>)
 8004974:	681a      	ldr	r2, [r3, #0]
 8004976:	4282      	cmp	r2, r0
 8004978:	d318      	bcc.n	80049ac <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800497a:	685c      	ldr	r4, [r3, #4]
 800497c:	1919      	adds	r1, r3, r4
 800497e:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8004980:	bf01      	itttt	eq
 8004982:	6841      	ldreq	r1, [r0, #4]
 8004984:	4618      	moveq	r0, r3
 8004986:	1909      	addeq	r1, r1, r4
 8004988:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800498a:	6844      	ldr	r4, [r0, #4]
 800498c:	1901      	adds	r1, r0, r4
 800498e:	428a      	cmp	r2, r1
 8004990:	d107      	bne.n	80049a2 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8004992:	4908      	ldr	r1, [pc, #32]	; (80049b4 <prvInsertBlockIntoFreeList+0x44>)
 8004994:	6809      	ldr	r1, [r1, #0]
 8004996:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004998:	bf1f      	itttt	ne
 800499a:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800499c:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800499e:	1909      	addne	r1, r1, r4
 80049a0:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80049a2:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80049a4:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80049a6:	bf18      	it	ne
 80049a8:	6018      	strne	r0, [r3, #0]
 80049aa:	bd10      	pop	{r4, pc}
 80049ac:	4613      	mov	r3, r2
 80049ae:	e7e1      	b.n	8004974 <prvInsertBlockIntoFreeList+0x4>
 80049b0:	20003e3c 	.word	0x20003e3c
 80049b4:	2000022c 	.word	0x2000022c

080049b8 <pvPortMalloc>:
{
 80049b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80049bc:	4604      	mov	r4, r0
	vTaskSuspendAll();
 80049be:	f000 fe3d 	bl	800563c <vTaskSuspendAll>
		if( pxEnd == NULL )
 80049c2:	493e      	ldr	r1, [pc, #248]	; (8004abc <pvPortMalloc+0x104>)
 80049c4:	4d3e      	ldr	r5, [pc, #248]	; (8004ac0 <pvPortMalloc+0x108>)
 80049c6:	680b      	ldr	r3, [r1, #0]
 80049c8:	bb0b      	cbnz	r3, 8004a0e <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 80049ca:	4a3e      	ldr	r2, [pc, #248]	; (8004ac4 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80049cc:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80049ce:	bf1f      	itttt	ne
 80049d0:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80049d2:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80049d6:	f502 5370 	addne.w	r3, r2, #15360	; 0x3c00
 80049da:	1a1b      	subne	r3, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80049dc:	bf14      	ite	ne
 80049de:	4602      	movne	r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80049e0:	f44f 5370 	moveq.w	r3, #15360	; 0x3c00
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80049e4:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 80049e6:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80049e8:	f023 0307 	bic.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80049ec:	4e36      	ldr	r6, [pc, #216]	; (8004ac8 <pvPortMalloc+0x110>)
	pxEnd = ( void * ) uxAddress;
 80049ee:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80049f0:	2000      	movs	r0, #0
 80049f2:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80049f4:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 80049f6:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 80049f8:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80049fa:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80049fc:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80049fe:	4b33      	ldr	r3, [pc, #204]	; (8004acc <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8004a00:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004a02:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004a04:	4b32      	ldr	r3, [pc, #200]	; (8004ad0 <pvPortMalloc+0x118>)
 8004a06:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004a08:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8004a0c:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8004a0e:	682f      	ldr	r7, [r5, #0]
 8004a10:	4227      	tst	r7, r4
 8004a12:	d116      	bne.n	8004a42 <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8004a14:	2c00      	cmp	r4, #0
 8004a16:	d041      	beq.n	8004a9c <pvPortMalloc+0xe4>
				xWantedSize += xHeapStructSize;
 8004a18:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8004a1c:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8004a1e:	bf1c      	itt	ne
 8004a20:	f023 0307 	bicne.w	r3, r3, #7
 8004a24:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8004a26:	b163      	cbz	r3, 8004a42 <pvPortMalloc+0x8a>
 8004a28:	4a29      	ldr	r2, [pc, #164]	; (8004ad0 <pvPortMalloc+0x118>)
 8004a2a:	6816      	ldr	r6, [r2, #0]
 8004a2c:	42b3      	cmp	r3, r6
 8004a2e:	4690      	mov	r8, r2
 8004a30:	d807      	bhi.n	8004a42 <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8004a32:	4a25      	ldr	r2, [pc, #148]	; (8004ac8 <pvPortMalloc+0x110>)
 8004a34:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004a36:	6868      	ldr	r0, [r5, #4]
 8004a38:	4283      	cmp	r3, r0
 8004a3a:	d804      	bhi.n	8004a46 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 8004a3c:	6809      	ldr	r1, [r1, #0]
 8004a3e:	428d      	cmp	r5, r1
 8004a40:	d107      	bne.n	8004a52 <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8004a42:	2400      	movs	r4, #0
 8004a44:	e02a      	b.n	8004a9c <pvPortMalloc+0xe4>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004a46:	682c      	ldr	r4, [r5, #0]
 8004a48:	2c00      	cmp	r4, #0
 8004a4a:	d0f7      	beq.n	8004a3c <pvPortMalloc+0x84>
 8004a4c:	462a      	mov	r2, r5
 8004a4e:	4625      	mov	r5, r4
 8004a50:	e7f1      	b.n	8004a36 <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004a52:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004a54:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004a56:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8004a58:	1ac2      	subs	r2, r0, r3
 8004a5a:	2a10      	cmp	r2, #16
 8004a5c:	d90f      	bls.n	8004a7e <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8004a5e:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004a60:	0741      	lsls	r1, r0, #29
 8004a62:	d008      	beq.n	8004a76 <pvPortMalloc+0xbe>
 8004a64:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a68:	f383 8811 	msr	BASEPRI, r3
 8004a6c:	f3bf 8f6f 	isb	sy
 8004a70:	f3bf 8f4f 	dsb	sy
 8004a74:	e7fe      	b.n	8004a74 <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8004a76:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8004a78:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8004a7a:	f7ff ff79 	bl	8004970 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004a7e:	4913      	ldr	r1, [pc, #76]	; (8004acc <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004a80:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004a82:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004a84:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004a86:	431f      	orrs	r7, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004a88:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 8004a8a:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004a8e:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8004a92:	bf38      	it	cc
 8004a94:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004a96:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004a98:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8004a9a:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8004a9c:	f000 fe76 	bl	800578c <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8004aa0:	0763      	lsls	r3, r4, #29
 8004aa2:	d008      	beq.n	8004ab6 <pvPortMalloc+0xfe>
 8004aa4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004aa8:	f383 8811 	msr	BASEPRI, r3
 8004aac:	f3bf 8f6f 	isb	sy
 8004ab0:	f3bf 8f4f 	dsb	sy
 8004ab4:	e7fe      	b.n	8004ab4 <pvPortMalloc+0xfc>
}
 8004ab6:	4620      	mov	r0, r4
 8004ab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004abc:	2000022c 	.word	0x2000022c
 8004ac0:	20003e30 	.word	0x20003e30
 8004ac4:	20000230 	.word	0x20000230
 8004ac8:	20003e3c 	.word	0x20003e3c
 8004acc:	20003e38 	.word	0x20003e38
 8004ad0:	20003e34 	.word	0x20003e34

08004ad4 <vPortFree>:
{
 8004ad4:	b510      	push	{r4, lr}
	if( pv != NULL )
 8004ad6:	4604      	mov	r4, r0
 8004ad8:	b370      	cbz	r0, 8004b38 <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8004ada:	4a18      	ldr	r2, [pc, #96]	; (8004b3c <vPortFree+0x68>)
 8004adc:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8004ae0:	6812      	ldr	r2, [r2, #0]
 8004ae2:	4213      	tst	r3, r2
 8004ae4:	d108      	bne.n	8004af8 <vPortFree+0x24>
 8004ae6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004aea:	f383 8811 	msr	BASEPRI, r3
 8004aee:	f3bf 8f6f 	isb	sy
 8004af2:	f3bf 8f4f 	dsb	sy
 8004af6:	e7fe      	b.n	8004af6 <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004af8:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8004afc:	b141      	cbz	r1, 8004b10 <vPortFree+0x3c>
 8004afe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b02:	f383 8811 	msr	BASEPRI, r3
 8004b06:	f3bf 8f6f 	isb	sy
 8004b0a:	f3bf 8f4f 	dsb	sy
 8004b0e:	e7fe      	b.n	8004b0e <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004b10:	ea23 0302 	bic.w	r3, r3, r2
 8004b14:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8004b18:	f000 fd90 	bl	800563c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004b1c:	4a08      	ldr	r2, [pc, #32]	; (8004b40 <vPortFree+0x6c>)
 8004b1e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004b22:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004b24:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004b28:	440b      	add	r3, r1
 8004b2a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004b2c:	f7ff ff20 	bl	8004970 <prvInsertBlockIntoFreeList>
}
 8004b30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8004b34:	f000 be2a 	b.w	800578c <xTaskResumeAll>
 8004b38:	bd10      	pop	{r4, pc}
 8004b3a:	bf00      	nop
 8004b3c:	20003e30 	.word	0x20003e30
 8004b40:	20003e34 	.word	0x20003e34

08004b44 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8004b44:	b570      	push	{r4, r5, r6, lr}
 8004b46:	4615      	mov	r5, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8004b48:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004b4a:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
 8004b4c:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8004b4e:	b942      	cbnz	r2, 8004b62 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004b50:	6805      	ldr	r5, [r0, #0]
 8004b52:	b99d      	cbnz	r5, 8004b7c <prvCopyDataToQueue+0x38>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8004b54:	6840      	ldr	r0, [r0, #4]
 8004b56:	f001 f887 	bl	8005c68 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8004b5a:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8004b5c:	3601      	adds	r6, #1
 8004b5e:	63a6      	str	r6, [r4, #56]	; 0x38

	return xReturn;
}
 8004b60:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8004b62:	b96d      	cbnz	r5, 8004b80 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8004b64:	6880      	ldr	r0, [r0, #8]
 8004b66:	f001 fd7b 	bl	8006660 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8004b6a:	68a3      	ldr	r3, [r4, #8]
 8004b6c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8004b6e:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004b70:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8004b72:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004b74:	4293      	cmp	r3, r2
 8004b76:	d301      	bcc.n	8004b7c <prvCopyDataToQueue+0x38>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8004b78:	6823      	ldr	r3, [r4, #0]
 8004b7a:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8004b7c:	2000      	movs	r0, #0
 8004b7e:	e7ed      	b.n	8004b5c <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004b80:	68c0      	ldr	r0, [r0, #12]
 8004b82:	f001 fd6d 	bl	8006660 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8004b86:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004b88:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004b8a:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8004b8c:	425b      	negs	r3, r3
 8004b8e:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004b90:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8004b92:	60e2      	str	r2, [r4, #12]
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8004b94:	bf3e      	ittt	cc
 8004b96:	6862      	ldrcc	r2, [r4, #4]
 8004b98:	189b      	addcc	r3, r3, r2
 8004b9a:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8004b9c:	2d02      	cmp	r5, #2
 8004b9e:	d1ed      	bne.n	8004b7c <prvCopyDataToQueue+0x38>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004ba0:	b10e      	cbz	r6, 8004ba6 <prvCopyDataToQueue+0x62>
				--uxMessagesWaiting;
 8004ba2:	3e01      	subs	r6, #1
 8004ba4:	e7ea      	b.n	8004b7c <prvCopyDataToQueue+0x38>
BaseType_t xReturn = pdFALSE;
 8004ba6:	4630      	mov	r0, r6
 8004ba8:	e7d8      	b.n	8004b5c <prvCopyDataToQueue+0x18>

08004baa <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8004baa:	4603      	mov	r3, r0
 8004bac:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8004bae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8004bb0:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8004bb2:	b162      	cbz	r2, 8004bce <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8004bb4:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8004bb6:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8004bb8:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8004bba:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8004bbc:	60d9      	str	r1, [r3, #12]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8004bbe:	bf24      	itt	cs
 8004bc0:	6819      	ldrcs	r1, [r3, #0]
 8004bc2:	60d9      	strcs	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8004bc4:	68d9      	ldr	r1, [r3, #12]
	}
}
 8004bc6:	f85d 4b04 	ldr.w	r4, [sp], #4
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8004bca:	f001 bd49 	b.w	8006660 <memcpy>
}
 8004bce:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004bd2:	4770      	bx	lr

08004bd4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8004bd4:	b570      	push	{r4, r5, r6, lr}
 8004bd6:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8004bd8:	f7ff fd94 	bl	8004704 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8004bdc:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004be0:	f104 0624 	add.w	r6, r4, #36	; 0x24
		int8_t cTxLock = pxQueue->cTxLock;
 8004be4:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004be6:	2d00      	cmp	r5, #0
 8004be8:	dc14      	bgt.n	8004c14 <prvUnlockQueue+0x40>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8004bea:	23ff      	movs	r3, #255	; 0xff
 8004bec:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8004bf0:	f7ff fdaa 	bl	8004748 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8004bf4:	f7ff fd86 	bl	8004704 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8004bf8:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004bfc:	f104 0610 	add.w	r6, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
 8004c00:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004c02:	2d00      	cmp	r5, #0
 8004c04:	dc12      	bgt.n	8004c2c <prvUnlockQueue+0x58>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8004c06:	23ff      	movs	r3, #255	; 0xff
 8004c08:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8004c0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8004c10:	f7ff bd9a 	b.w	8004748 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004c14:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004c16:	2b00      	cmp	r3, #0
 8004c18:	d0e7      	beq.n	8004bea <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004c1a:	4630      	mov	r0, r6
 8004c1c:	f000 ff36 	bl	8005a8c <xTaskRemoveFromEventList>
 8004c20:	b108      	cbz	r0, 8004c26 <prvUnlockQueue+0x52>
						vTaskMissedYield();
 8004c22:	f000 ffbf 	bl	8005ba4 <vTaskMissedYield>
 8004c26:	3d01      	subs	r5, #1
 8004c28:	b26d      	sxtb	r5, r5
 8004c2a:	e7dc      	b.n	8004be6 <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004c2c:	6923      	ldr	r3, [r4, #16]
 8004c2e:	2b00      	cmp	r3, #0
 8004c30:	d0e9      	beq.n	8004c06 <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004c32:	4630      	mov	r0, r6
 8004c34:	f000 ff2a 	bl	8005a8c <xTaskRemoveFromEventList>
 8004c38:	b108      	cbz	r0, 8004c3e <prvUnlockQueue+0x6a>
					vTaskMissedYield();
 8004c3a:	f000 ffb3 	bl	8005ba4 <vTaskMissedYield>
 8004c3e:	3d01      	subs	r5, #1
 8004c40:	b26d      	sxtb	r5, r5
 8004c42:	e7de      	b.n	8004c02 <prvUnlockQueue+0x2e>

08004c44 <xQueueGenericReset>:
{
 8004c44:	b538      	push	{r3, r4, r5, lr}
 8004c46:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8004c48:	4604      	mov	r4, r0
 8004c4a:	b940      	cbnz	r0, 8004c5e <xQueueGenericReset+0x1a>
 8004c4c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c50:	f383 8811 	msr	BASEPRI, r3
 8004c54:	f3bf 8f6f 	isb	sy
 8004c58:	f3bf 8f4f 	dsb	sy
 8004c5c:	e7fe      	b.n	8004c5c <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
 8004c5e:	f7ff fd51 	bl	8004704 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8004c62:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8004c64:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004c66:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8004c68:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8004c6a:	4343      	muls	r3, r0
 8004c6c:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8004c6e:	1a1b      	subs	r3, r3, r0
 8004c70:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8004c72:	6061      	str	r1, [r4, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8004c74:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8004c76:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 8004c78:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8004c7a:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 8004c7c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8004c80:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 8004c84:	b995      	cbnz	r5, 8004cac <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004c86:	6923      	ldr	r3, [r4, #16]
 8004c88:	b163      	cbz	r3, 8004ca4 <xQueueGenericReset+0x60>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004c8a:	f104 0010 	add.w	r0, r4, #16
 8004c8e:	f000 fefd 	bl	8005a8c <xTaskRemoveFromEventList>
 8004c92:	b138      	cbz	r0, 8004ca4 <xQueueGenericReset+0x60>
					queueYIELD_IF_USING_PREEMPTION();
 8004c94:	4b0a      	ldr	r3, [pc, #40]	; (8004cc0 <xQueueGenericReset+0x7c>)
 8004c96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004c9a:	601a      	str	r2, [r3, #0]
 8004c9c:	f3bf 8f4f 	dsb	sy
 8004ca0:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 8004ca4:	f7ff fd50 	bl	8004748 <vPortExitCritical>
}
 8004ca8:	2001      	movs	r0, #1
 8004caa:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8004cac:	f104 0010 	add.w	r0, r4, #16
 8004cb0:	f7ff fc86 	bl	80045c0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8004cb4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004cb8:	f7ff fc82 	bl	80045c0 <vListInitialise>
 8004cbc:	e7f2      	b.n	8004ca4 <xQueueGenericReset+0x60>
 8004cbe:	bf00      	nop
 8004cc0:	e000ed04 	.word	0xe000ed04

08004cc4 <xQueueGenericCreate>:
	{
 8004cc4:	b570      	push	{r4, r5, r6, lr}
 8004cc6:	460d      	mov	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8004cc8:	4606      	mov	r6, r0
 8004cca:	b940      	cbnz	r0, 8004cde <xQueueGenericCreate+0x1a>
 8004ccc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004cd0:	f383 8811 	msr	BASEPRI, r3
 8004cd4:	f3bf 8f6f 	isb	sy
 8004cd8:	f3bf 8f4f 	dsb	sy
 8004cdc:	e7fe      	b.n	8004cdc <xQueueGenericCreate+0x18>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cde:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8004ce0:	3048      	adds	r0, #72	; 0x48
 8004ce2:	f7ff fe69 	bl	80049b8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8004ce6:	4604      	mov	r4, r0
 8004ce8:	b138      	cbz	r0, 8004cfa <xQueueGenericCreate+0x36>
	if( uxItemSize == ( UBaseType_t ) 0 )
 8004cea:	b945      	cbnz	r5, 8004cfe <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8004cec:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8004cee:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8004cf0:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8004cf2:	2101      	movs	r1, #1
 8004cf4:	4620      	mov	r0, r4
 8004cf6:	f7ff ffa5 	bl	8004c44 <xQueueGenericReset>
	}
 8004cfa:	4620      	mov	r0, r4
 8004cfc:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8004cfe:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8004d02:	6003      	str	r3, [r0, #0]
 8004d04:	e7f3      	b.n	8004cee <xQueueGenericCreate+0x2a>
	...

08004d08 <xQueueGenericSend>:
{
 8004d08:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004d0c:	4689      	mov	r9, r1
 8004d0e:	9201      	str	r2, [sp, #4]
 8004d10:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 8004d12:	4604      	mov	r4, r0
 8004d14:	b940      	cbnz	r0, 8004d28 <xQueueGenericSend+0x20>
 8004d16:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d1a:	f383 8811 	msr	BASEPRI, r3
 8004d1e:	f3bf 8f6f 	isb	sy
 8004d22:	f3bf 8f4f 	dsb	sy
 8004d26:	e7fe      	b.n	8004d26 <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004d28:	2900      	cmp	r1, #0
 8004d2a:	f040 8088 	bne.w	8004e3e <xQueueGenericSend+0x136>
 8004d2e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	f000 8084 	beq.w	8004e3e <xQueueGenericSend+0x136>
 8004d36:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d3a:	f383 8811 	msr	BASEPRI, r3
 8004d3e:	f3bf 8f6f 	isb	sy
 8004d42:	f3bf 8f4f 	dsb	sy
 8004d46:	e7fe      	b.n	8004d46 <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004d48:	9e01      	ldr	r6, [sp, #4]
 8004d4a:	2e00      	cmp	r6, #0
 8004d4c:	f000 8082 	beq.w	8004e54 <xQueueGenericSend+0x14c>
 8004d50:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d54:	f383 8811 	msr	BASEPRI, r3
 8004d58:	f3bf 8f6f 	isb	sy
 8004d5c:	f3bf 8f4f 	dsb	sy
 8004d60:	e7fe      	b.n	8004d60 <xQueueGenericSend+0x58>
				if( xTicksToWait == ( TickType_t ) 0 )
 8004d62:	9d01      	ldr	r5, [sp, #4]
 8004d64:	b91d      	cbnz	r5, 8004d6e <xQueueGenericSend+0x66>
					taskEXIT_CRITICAL();
 8004d66:	f7ff fcef 	bl	8004748 <vPortExitCritical>
			return errQUEUE_FULL;
 8004d6a:	2000      	movs	r0, #0
 8004d6c:	e058      	b.n	8004e20 <xQueueGenericSend+0x118>
				else if( xEntryTimeSet == pdFALSE )
 8004d6e:	b916      	cbnz	r6, 8004d76 <xQueueGenericSend+0x6e>
					vTaskSetTimeOutState( &xTimeOut );
 8004d70:	a802      	add	r0, sp, #8
 8004d72:	f000 fecd 	bl	8005b10 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8004d76:	f7ff fce7 	bl	8004748 <vPortExitCritical>
		vTaskSuspendAll();
 8004d7a:	f000 fc5f 	bl	800563c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004d7e:	f7ff fcc1 	bl	8004704 <vPortEnterCritical>
 8004d82:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004d86:	2bff      	cmp	r3, #255	; 0xff
 8004d88:	bf08      	it	eq
 8004d8a:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 8004d8e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004d92:	2bff      	cmp	r3, #255	; 0xff
 8004d94:	bf08      	it	eq
 8004d96:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8004d9a:	f7ff fcd5 	bl	8004748 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8004d9e:	a901      	add	r1, sp, #4
 8004da0:	a802      	add	r0, sp, #8
 8004da2:	f000 fec5 	bl	8005b30 <xTaskCheckForTimeOut>
 8004da6:	2800      	cmp	r0, #0
 8004da8:	d143      	bne.n	8004e32 <xQueueGenericSend+0x12a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8004daa:	f7ff fcab 	bl	8004704 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8004dae:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8004db0:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8004db2:	f7ff fcc9 	bl	8004748 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8004db6:	42ae      	cmp	r6, r5
 8004db8:	d135      	bne.n	8004e26 <xQueueGenericSend+0x11e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8004dba:	9901      	ldr	r1, [sp, #4]
 8004dbc:	f104 0010 	add.w	r0, r4, #16
 8004dc0:	f000 fe4a 	bl	8005a58 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004dc4:	4620      	mov	r0, r4
 8004dc6:	f7ff ff05 	bl	8004bd4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004dca:	f000 fcdf 	bl	800578c <xTaskResumeAll>
 8004dce:	b938      	cbnz	r0, 8004de0 <xQueueGenericSend+0xd8>
					portYIELD_WITHIN_API();
 8004dd0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004dd4:	f8ca 3000 	str.w	r3, [sl]
 8004dd8:	f3bf 8f4f 	dsb	sy
 8004ddc:	f3bf 8f6f 	isb	sy
 8004de0:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8004de2:	f7ff fc8f 	bl	8004704 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8004de6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8004de8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004dea:	429a      	cmp	r2, r3
 8004dec:	d301      	bcc.n	8004df2 <xQueueGenericSend+0xea>
 8004dee:	2f02      	cmp	r7, #2
 8004df0:	d1b7      	bne.n	8004d62 <xQueueGenericSend+0x5a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004df2:	463a      	mov	r2, r7
 8004df4:	4649      	mov	r1, r9
 8004df6:	4620      	mov	r0, r4
 8004df8:	f7ff fea4 	bl	8004b44 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004dfc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004dfe:	b11b      	cbz	r3, 8004e08 <xQueueGenericSend+0x100>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004e00:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004e04:	f000 fe42 	bl	8005a8c <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
 8004e08:	b138      	cbz	r0, 8004e1a <xQueueGenericSend+0x112>
						queueYIELD_IF_USING_PREEMPTION();
 8004e0a:	4b19      	ldr	r3, [pc, #100]	; (8004e70 <xQueueGenericSend+0x168>)
 8004e0c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004e10:	601a      	str	r2, [r3, #0]
 8004e12:	f3bf 8f4f 	dsb	sy
 8004e16:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8004e1a:	f7ff fc95 	bl	8004748 <vPortExitCritical>
				return pdPASS;
 8004e1e:	2001      	movs	r0, #1
}
 8004e20:	b004      	add	sp, #16
 8004e22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 8004e26:	4620      	mov	r0, r4
 8004e28:	f7ff fed4 	bl	8004bd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8004e2c:	f000 fcae 	bl	800578c <xTaskResumeAll>
 8004e30:	e7d6      	b.n	8004de0 <xQueueGenericSend+0xd8>
			prvUnlockQueue( pxQueue );
 8004e32:	4620      	mov	r0, r4
 8004e34:	f7ff fece 	bl	8004bd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004e38:	f000 fca8 	bl	800578c <xTaskResumeAll>
 8004e3c:	e795      	b.n	8004d6a <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004e3e:	2f02      	cmp	r7, #2
 8004e40:	d102      	bne.n	8004e48 <xQueueGenericSend+0x140>
 8004e42:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004e44:	2b01      	cmp	r3, #1
 8004e46:	d10a      	bne.n	8004e5e <xQueueGenericSend+0x156>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004e48:	f000 feb8 	bl	8005bbc <xTaskGetSchedulerState>
 8004e4c:	2800      	cmp	r0, #0
 8004e4e:	f43f af7b 	beq.w	8004d48 <xQueueGenericSend+0x40>
 8004e52:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8004e54:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 8004e58:	f8df a014 	ldr.w	sl, [pc, #20]	; 8004e70 <xQueueGenericSend+0x168>
 8004e5c:	e7c1      	b.n	8004de2 <xQueueGenericSend+0xda>
 8004e5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004e62:	f383 8811 	msr	BASEPRI, r3
 8004e66:	f3bf 8f6f 	isb	sy
 8004e6a:	f3bf 8f4f 	dsb	sy
 8004e6e:	e7fe      	b.n	8004e6e <xQueueGenericSend+0x166>
 8004e70:	e000ed04 	.word	0xe000ed04

08004e74 <xQueueGiveFromISR>:
{
 8004e74:	b570      	push	{r4, r5, r6, lr}
 8004e76:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8004e78:	4604      	mov	r4, r0
 8004e7a:	b940      	cbnz	r0, 8004e8e <xQueueGiveFromISR+0x1a>
 8004e7c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004e80:	f383 8811 	msr	BASEPRI, r3
 8004e84:	f3bf 8f6f 	isb	sy
 8004e88:	f3bf 8f4f 	dsb	sy
 8004e8c:	e7fe      	b.n	8004e8c <xQueueGiveFromISR+0x18>
	configASSERT( pxQueue->uxItemSize == 0 );
 8004e8e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004e90:	b143      	cbz	r3, 8004ea4 <xQueueGiveFromISR+0x30>
 8004e92:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004e96:	f383 8811 	msr	BASEPRI, r3
 8004e9a:	f3bf 8f6f 	isb	sy
 8004e9e:	f3bf 8f4f 	dsb	sy
 8004ea2:	e7fe      	b.n	8004ea2 <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8004ea4:	6803      	ldr	r3, [r0, #0]
 8004ea6:	b90b      	cbnz	r3, 8004eac <xQueueGiveFromISR+0x38>
 8004ea8:	6843      	ldr	r3, [r0, #4]
 8004eaa:	bb73      	cbnz	r3, 8004f0a <xQueueGiveFromISR+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004eac:	f7ff fd32 	bl	8004914 <vPortValidateInterruptPriority>
	__asm volatile
 8004eb0:	f3ef 8611 	mrs	r6, BASEPRI
 8004eb4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004eb8:	f383 8811 	msr	BASEPRI, r3
 8004ebc:	f3bf 8f6f 	isb	sy
 8004ec0:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004ec4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8004ec6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004ec8:	429a      	cmp	r2, r3
 8004eca:	d301      	bcc.n	8004ed0 <xQueueGiveFromISR+0x5c>
			xReturn = errQUEUE_FULL;
 8004ecc:	2000      	movs	r0, #0
 8004ece:	e014      	b.n	8004efa <xQueueGiveFromISR+0x86>
			const int8_t cTxLock = pxQueue->cTxLock;
 8004ed0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8004ed4:	3201      	adds	r2, #1
			const int8_t cTxLock = pxQueue->cTxLock;
 8004ed6:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8004ed8:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8004eda:	1c5a      	adds	r2, r3, #1
 8004edc:	d110      	bne.n	8004f00 <xQueueGiveFromISR+0x8c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004ede:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004ee0:	b90b      	cbnz	r3, 8004ee6 <xQueueGiveFromISR+0x72>
			xReturn = pdPASS;
 8004ee2:	2001      	movs	r0, #1
 8004ee4:	e009      	b.n	8004efa <xQueueGiveFromISR+0x86>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004ee6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004eea:	f000 fdcf 	bl	8005a8c <xTaskRemoveFromEventList>
 8004eee:	2800      	cmp	r0, #0
 8004ef0:	d0f7      	beq.n	8004ee2 <xQueueGiveFromISR+0x6e>
							if( pxHigherPriorityTaskWoken != NULL )
 8004ef2:	2d00      	cmp	r5, #0
 8004ef4:	d0f5      	beq.n	8004ee2 <xQueueGiveFromISR+0x6e>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8004ef6:	2001      	movs	r0, #1
 8004ef8:	6028      	str	r0, [r5, #0]
	__asm volatile
 8004efa:	f386 8811 	msr	BASEPRI, r6
}
 8004efe:	bd70      	pop	{r4, r5, r6, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8004f00:	3301      	adds	r3, #1
 8004f02:	b25b      	sxtb	r3, r3
 8004f04:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8004f08:	e7eb      	b.n	8004ee2 <xQueueGiveFromISR+0x6e>
	__asm volatile
 8004f0a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f0e:	f383 8811 	msr	BASEPRI, r3
 8004f12:	f3bf 8f6f 	isb	sy
 8004f16:	f3bf 8f4f 	dsb	sy
 8004f1a:	e7fe      	b.n	8004f1a <xQueueGiveFromISR+0xa6>

08004f1c <xQueueGenericReceive>:
{
 8004f1c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004f20:	4688      	mov	r8, r1
 8004f22:	9201      	str	r2, [sp, #4]
 8004f24:	4699      	mov	r9, r3
	configASSERT( pxQueue );
 8004f26:	4604      	mov	r4, r0
 8004f28:	b940      	cbnz	r0, 8004f3c <xQueueGenericReceive+0x20>
 8004f2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f2e:	f383 8811 	msr	BASEPRI, r3
 8004f32:	f3bf 8f6f 	isb	sy
 8004f36:	f3bf 8f4f 	dsb	sy
 8004f3a:	e7fe      	b.n	8004f3a <xQueueGenericReceive+0x1e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004f3c:	2900      	cmp	r1, #0
 8004f3e:	f040 80a5 	bne.w	800508c <xQueueGenericReceive+0x170>
 8004f42:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004f44:	2b00      	cmp	r3, #0
 8004f46:	f000 80a1 	beq.w	800508c <xQueueGenericReceive+0x170>
 8004f4a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f4e:	f383 8811 	msr	BASEPRI, r3
 8004f52:	f3bf 8f6f 	isb	sy
 8004f56:	f3bf 8f4f 	dsb	sy
 8004f5a:	e7fe      	b.n	8004f5a <xQueueGenericReceive+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004f5c:	9e01      	ldr	r6, [sp, #4]
 8004f5e:	2e00      	cmp	r6, #0
 8004f60:	f000 809a 	beq.w	8005098 <xQueueGenericReceive+0x17c>
 8004f64:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f68:	f383 8811 	msr	BASEPRI, r3
 8004f6c:	f3bf 8f6f 	isb	sy
 8004f70:	f3bf 8f4f 	dsb	sy
 8004f74:	e7fe      	b.n	8004f74 <xQueueGenericReceive+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004f76:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8004f78:	60e6      	str	r6, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004f7a:	2b00      	cmp	r3, #0
 8004f7c:	d06d      	beq.n	800505a <xQueueGenericReceive+0x13e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004f7e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004f82:	e05f      	b.n	8005044 <xQueueGenericReceive+0x128>
				if( xTicksToWait == ( TickType_t ) 0 )
 8004f84:	9d01      	ldr	r5, [sp, #4]
 8004f86:	b91d      	cbnz	r5, 8004f90 <xQueueGenericReceive+0x74>
					taskEXIT_CRITICAL();
 8004f88:	f7ff fbde 	bl	8004748 <vPortExitCritical>
				return errQUEUE_EMPTY;
 8004f8c:	4628      	mov	r0, r5
 8004f8e:	e067      	b.n	8005060 <xQueueGenericReceive+0x144>
				else if( xEntryTimeSet == pdFALSE )
 8004f90:	b916      	cbnz	r6, 8004f98 <xQueueGenericReceive+0x7c>
					vTaskSetTimeOutState( &xTimeOut );
 8004f92:	a802      	add	r0, sp, #8
 8004f94:	f000 fdbc 	bl	8005b10 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8004f98:	f7ff fbd6 	bl	8004748 <vPortExitCritical>
		vTaskSuspendAll();
 8004f9c:	f000 fb4e 	bl	800563c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004fa0:	f7ff fbb0 	bl	8004704 <vPortEnterCritical>
 8004fa4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004fa8:	2bff      	cmp	r3, #255	; 0xff
 8004faa:	bf08      	it	eq
 8004fac:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 8004fb0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004fb4:	2bff      	cmp	r3, #255	; 0xff
 8004fb6:	bf08      	it	eq
 8004fb8:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 8004fbc:	f7ff fbc4 	bl	8004748 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8004fc0:	a901      	add	r1, sp, #4
 8004fc2:	a802      	add	r0, sp, #8
 8004fc4:	f000 fdb4 	bl	8005b30 <xTaskCheckForTimeOut>
 8004fc8:	2800      	cmp	r0, #0
 8004fca:	d152      	bne.n	8005072 <xQueueGenericReceive+0x156>
	taskENTER_CRITICAL();
 8004fcc:	f7ff fb9a 	bl	8004704 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8004fd0:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8004fd2:	f7ff fbb9 	bl	8004748 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004fd6:	2d00      	cmp	r5, #0
 8004fd8:	d145      	bne.n	8005066 <xQueueGenericReceive+0x14a>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004fda:	6823      	ldr	r3, [r4, #0]
 8004fdc:	b933      	cbnz	r3, 8004fec <xQueueGenericReceive+0xd0>
						taskENTER_CRITICAL();
 8004fde:	f7ff fb91 	bl	8004704 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8004fe2:	6860      	ldr	r0, [r4, #4]
 8004fe4:	f000 fdfa 	bl	8005bdc <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8004fe8:	f7ff fbae 	bl	8004748 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8004fec:	9901      	ldr	r1, [sp, #4]
 8004fee:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004ff2:	f000 fd31 	bl	8005a58 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004ff6:	4620      	mov	r0, r4
 8004ff8:	f7ff fdec 	bl	8004bd4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004ffc:	f000 fbc6 	bl	800578c <xTaskResumeAll>
 8005000:	b938      	cbnz	r0, 8005012 <xQueueGenericReceive+0xf6>
					portYIELD_WITHIN_API();
 8005002:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8005006:	f8ca 3000 	str.w	r3, [sl]
 800500a:	f3bf 8f4f 	dsb	sy
 800500e:	f3bf 8f6f 	isb	sy
 8005012:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8005014:	f7ff fb76 	bl	8004704 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8005018:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800501a:	2d00      	cmp	r5, #0
 800501c:	d0b2      	beq.n	8004f84 <xQueueGenericReceive+0x68>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800501e:	4641      	mov	r1, r8
 8005020:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8005022:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8005024:	f7ff fdc1 	bl	8004baa <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8005028:	f1b9 0f00 	cmp.w	r9, #0
 800502c:	d1a3      	bne.n	8004f76 <xQueueGenericReceive+0x5a>
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800502e:	6823      	ldr	r3, [r4, #0]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8005030:	3d01      	subs	r5, #1
 8005032:	63a5      	str	r5, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005034:	b913      	cbnz	r3, 800503c <xQueueGenericReceive+0x120>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8005036:	f000 fe67 	bl	8005d08 <pvTaskIncrementMutexHeldCount>
 800503a:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800503c:	6923      	ldr	r3, [r4, #16]
 800503e:	b163      	cbz	r3, 800505a <xQueueGenericReceive+0x13e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005040:	f104 0010 	add.w	r0, r4, #16
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005044:	f000 fd22 	bl	8005a8c <xTaskRemoveFromEventList>
 8005048:	b138      	cbz	r0, 800505a <xQueueGenericReceive+0x13e>
							queueYIELD_IF_USING_PREEMPTION();
 800504a:	4b15      	ldr	r3, [pc, #84]	; (80050a0 <xQueueGenericReceive+0x184>)
 800504c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005050:	601a      	str	r2, [r3, #0]
 8005052:	f3bf 8f4f 	dsb	sy
 8005056:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 800505a:	f7ff fb75 	bl	8004748 <vPortExitCritical>
				return pdPASS;
 800505e:	2001      	movs	r0, #1
}
 8005060:	b004      	add	sp, #16
 8005062:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 8005066:	4620      	mov	r0, r4
 8005068:	f7ff fdb4 	bl	8004bd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800506c:	f000 fb8e 	bl	800578c <xTaskResumeAll>
 8005070:	e7cf      	b.n	8005012 <xQueueGenericReceive+0xf6>
			prvUnlockQueue( pxQueue );
 8005072:	4620      	mov	r0, r4
 8005074:	f7ff fdae 	bl	8004bd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8005078:	f000 fb88 	bl	800578c <xTaskResumeAll>
	taskENTER_CRITICAL();
 800507c:	f7ff fb42 	bl	8004704 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8005080:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8005082:	f7ff fb61 	bl	8004748 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8005086:	2d00      	cmp	r5, #0
 8005088:	d1c3      	bne.n	8005012 <xQueueGenericReceive+0xf6>
 800508a:	e77f      	b.n	8004f8c <xQueueGenericReceive+0x70>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800508c:	f000 fd96 	bl	8005bbc <xTaskGetSchedulerState>
 8005090:	2800      	cmp	r0, #0
 8005092:	f43f af63 	beq.w	8004f5c <xQueueGenericReceive+0x40>
 8005096:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8005098:	2700      	movs	r7, #0
					portYIELD_WITHIN_API();
 800509a:	f8df a004 	ldr.w	sl, [pc, #4]	; 80050a0 <xQueueGenericReceive+0x184>
 800509e:	e7b9      	b.n	8005014 <xQueueGenericReceive+0xf8>
 80050a0:	e000ed04 	.word	0xe000ed04

080050a4 <xQueueReceiveFromISR>:
{
 80050a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80050a8:	4689      	mov	r9, r1
 80050aa:	4690      	mov	r8, r2
	configASSERT( pxQueue );
 80050ac:	4605      	mov	r5, r0
 80050ae:	b940      	cbnz	r0, 80050c2 <xQueueReceiveFromISR+0x1e>
 80050b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80050b4:	f383 8811 	msr	BASEPRI, r3
 80050b8:	f3bf 8f6f 	isb	sy
 80050bc:	f3bf 8f4f 	dsb	sy
 80050c0:	e7fe      	b.n	80050c0 <xQueueReceiveFromISR+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80050c2:	bb71      	cbnz	r1, 8005122 <xQueueReceiveFromISR+0x7e>
 80050c4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80050c6:	b363      	cbz	r3, 8005122 <xQueueReceiveFromISR+0x7e>
 80050c8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80050cc:	f383 8811 	msr	BASEPRI, r3
 80050d0:	f3bf 8f6f 	isb	sy
 80050d4:	f3bf 8f4f 	dsb	sy
 80050d8:	e7fe      	b.n	80050d8 <xQueueReceiveFromISR+0x34>
			const int8_t cRxLock = pxQueue->cRxLock;
 80050da:	f895 6044 	ldrb.w	r6, [r5, #68]	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80050de:	4649      	mov	r1, r9
			const int8_t cRxLock = pxQueue->cRxLock;
 80050e0:	b276      	sxtb	r6, r6
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80050e2:	4628      	mov	r0, r5
 80050e4:	f7ff fd61 	bl	8004baa <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 80050e8:	3c01      	subs	r4, #1
			if( cRxLock == queueUNLOCKED )
 80050ea:	1c73      	adds	r3, r6, #1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 80050ec:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 80050ee:	d113      	bne.n	8005118 <xQueueReceiveFromISR+0x74>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80050f0:	692b      	ldr	r3, [r5, #16]
 80050f2:	b90b      	cbnz	r3, 80050f8 <xQueueReceiveFromISR+0x54>
			xReturn = pdPASS;
 80050f4:	2001      	movs	r0, #1
 80050f6:	e00b      	b.n	8005110 <xQueueReceiveFromISR+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80050f8:	f105 0010 	add.w	r0, r5, #16
 80050fc:	f000 fcc6 	bl	8005a8c <xTaskRemoveFromEventList>
 8005100:	2800      	cmp	r0, #0
 8005102:	d0f7      	beq.n	80050f4 <xQueueReceiveFromISR+0x50>
						if( pxHigherPriorityTaskWoken != NULL )
 8005104:	f1b8 0f00 	cmp.w	r8, #0
 8005108:	d0f4      	beq.n	80050f4 <xQueueReceiveFromISR+0x50>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800510a:	2001      	movs	r0, #1
 800510c:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile
 8005110:	f387 8811 	msr	BASEPRI, r7
}
 8005114:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8005118:	3601      	adds	r6, #1
 800511a:	b276      	sxtb	r6, r6
 800511c:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
 8005120:	e7e8      	b.n	80050f4 <xQueueReceiveFromISR+0x50>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8005122:	f7ff fbf7 	bl	8004914 <vPortValidateInterruptPriority>
	__asm volatile
 8005126:	f3ef 8711 	mrs	r7, BASEPRI
 800512a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800512e:	f383 8811 	msr	BASEPRI, r3
 8005132:	f3bf 8f6f 	isb	sy
 8005136:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800513a:	6bac      	ldr	r4, [r5, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800513c:	2c00      	cmp	r4, #0
 800513e:	d1cc      	bne.n	80050da <xQueueReceiveFromISR+0x36>
			xReturn = pdFAIL;
 8005140:	4620      	mov	r0, r4
 8005142:	e7e5      	b.n	8005110 <xQueueReceiveFromISR+0x6c>

08005144 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8005144:	4a06      	ldr	r2, [pc, #24]	; (8005160 <prvResetNextTaskUnblockTime+0x1c>)
 8005146:	6813      	ldr	r3, [r2, #0]
 8005148:	6819      	ldr	r1, [r3, #0]
 800514a:	4b06      	ldr	r3, [pc, #24]	; (8005164 <prvResetNextTaskUnblockTime+0x20>)
 800514c:	b919      	cbnz	r1, 8005156 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800514e:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8005152:	601a      	str	r2, [r3, #0]
 8005154:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8005156:	6812      	ldr	r2, [r2, #0]
 8005158:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800515a:	68d2      	ldr	r2, [r2, #12]
 800515c:	6852      	ldr	r2, [r2, #4]
 800515e:	e7f8      	b.n	8005152 <prvResetNextTaskUnblockTime+0xe>
 8005160:	20003e48 	.word	0x20003e48
 8005164:	20003f20 	.word	0x20003f20

08005168 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8005168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800516a:	4b1b      	ldr	r3, [pc, #108]	; (80051d8 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800516c:	4e1b      	ldr	r6, [pc, #108]	; (80051dc <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 800516e:	681d      	ldr	r5, [r3, #0]
{
 8005170:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005172:	6830      	ldr	r0, [r6, #0]
 8005174:	3004      	adds	r0, #4
{
 8005176:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005178:	f7ff fa53 	bl	8004622 <uxListRemove>
 800517c:	4633      	mov	r3, r6
 800517e:	b940      	cbnz	r0, 8005192 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8005180:	6831      	ldr	r1, [r6, #0]
 8005182:	4e17      	ldr	r6, [pc, #92]	; (80051e0 <prvAddCurrentTaskToDelayedList+0x78>)
 8005184:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8005186:	6832      	ldr	r2, [r6, #0]
 8005188:	2001      	movs	r0, #1
 800518a:	4088      	lsls	r0, r1
 800518c:	ea22 0200 	bic.w	r2, r2, r0
 8005190:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8005192:	1c62      	adds	r2, r4, #1
 8005194:	d107      	bne.n	80051a6 <prvAddCurrentTaskToDelayedList+0x3e>
 8005196:	b137      	cbz	r7, 80051a6 <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8005198:	6819      	ldr	r1, [r3, #0]
 800519a:	4812      	ldr	r0, [pc, #72]	; (80051e4 <prvAddCurrentTaskToDelayedList+0x7c>)
 800519c:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800519e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051a2:	f7ff ba1b 	b.w	80045dc <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 80051a6:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80051a8:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 80051aa:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80051ac:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 80051ae:	d907      	bls.n	80051c0 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051b0:	4a0d      	ldr	r2, [pc, #52]	; (80051e8 <prvAddCurrentTaskToDelayedList+0x80>)
 80051b2:	6810      	ldr	r0, [r2, #0]
 80051b4:	6819      	ldr	r1, [r3, #0]
}
 80051b6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051ba:	3104      	adds	r1, #4
 80051bc:	f7ff ba1a 	b.w	80045f4 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051c0:	4a0a      	ldr	r2, [pc, #40]	; (80051ec <prvAddCurrentTaskToDelayedList+0x84>)
 80051c2:	6810      	ldr	r0, [r2, #0]
 80051c4:	6819      	ldr	r1, [r3, #0]
 80051c6:	3104      	adds	r1, #4
 80051c8:	f7ff fa14 	bl	80045f4 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 80051cc:	4b08      	ldr	r3, [pc, #32]	; (80051f0 <prvAddCurrentTaskToDelayedList+0x88>)
 80051ce:	681a      	ldr	r2, [r3, #0]
 80051d0:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 80051d2:	bf38      	it	cc
 80051d4:	601c      	strcc	r4, [r3, #0]
 80051d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80051d8:	20003f68 	.word	0x20003f68
 80051dc:	20003e44 	.word	0x20003e44
 80051e0:	20003ef0 	.word	0x20003ef0
 80051e4:	20003f40 	.word	0x20003f40
 80051e8:	20003e4c 	.word	0x20003e4c
 80051ec:	20003e48 	.word	0x20003e48
 80051f0:	20003f20 	.word	0x20003f20

080051f4 <prvTaskIsTaskSuspended.part.0>:
	__asm volatile
 80051f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80051f8:	f383 8811 	msr	BASEPRI, r3
 80051fc:	f3bf 8f6f 	isb	sy
 8005200:	f3bf 8f4f 	dsb	sy
 8005204:	e7fe      	b.n	8005204 <prvTaskIsTaskSuspended.part.0+0x10>
	...

08005208 <prvTaskIsTaskSuspended>:
	{
 8005208:	b508      	push	{r3, lr}
		configASSERT( xTask );
 800520a:	b908      	cbnz	r0, 8005210 <prvTaskIsTaskSuspended+0x8>
 800520c:	f7ff fff2 	bl	80051f4 <prvTaskIsTaskSuspended.part.0>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005210:	6942      	ldr	r2, [r0, #20]
 8005212:	4b06      	ldr	r3, [pc, #24]	; (800522c <prvTaskIsTaskSuspended+0x24>)
 8005214:	429a      	cmp	r2, r3
 8005216:	d001      	beq.n	800521c <prvTaskIsTaskSuspended+0x14>
	BaseType_t xReturn = pdFALSE;
 8005218:	2000      	movs	r0, #0
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 800521a:	bd08      	pop	{r3, pc}
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 800521c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800521e:	4b04      	ldr	r3, [pc, #16]	; (8005230 <prvTaskIsTaskSuspended+0x28>)
 8005220:	4298      	cmp	r0, r3
 8005222:	d0f9      	beq.n	8005218 <prvTaskIsTaskSuspended+0x10>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 8005224:	fab0 f080 	clz	r0, r0
 8005228:	0940      	lsrs	r0, r0, #5
		return xReturn;
 800522a:	bd08      	pop	{r3, pc}
 800522c:	20003f40 	.word	0x20003f40
 8005230:	20003f28 	.word	0x20003f28

08005234 <xTaskCreate>:
	{
 8005234:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005238:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 800523c:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800523e:	4650      	mov	r0, sl
	{
 8005240:	460f      	mov	r7, r1
 8005242:	4699      	mov	r9, r3
 8005244:	9e09      	ldr	r6, [sp, #36]	; 0x24
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005246:	f7ff fbb7 	bl	80049b8 <pvPortMalloc>
			if( pxStack != NULL )
 800524a:	4605      	mov	r5, r0
 800524c:	2800      	cmp	r0, #0
 800524e:	f000 8090 	beq.w	8005372 <xTaskCreate+0x13e>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8005252:	204c      	movs	r0, #76	; 0x4c
 8005254:	f7ff fbb0 	bl	80049b8 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8005258:	4604      	mov	r4, r0
 800525a:	2800      	cmp	r0, #0
 800525c:	f000 8086 	beq.w	800536c <xTaskCreate+0x138>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8005260:	f1aa 0a04 	sub.w	sl, sl, #4
					pxNewTCB->pxStack = pxStack;
 8005264:	6305      	str	r5, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8005266:	4455      	add	r5, sl
 8005268:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800526a:	f025 0a07 	bic.w	sl, r5, #7
 800526e:	f100 0234 	add.w	r2, r0, #52	; 0x34
 8005272:	370f      	adds	r7, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8005274:	7859      	ldrb	r1, [r3, #1]
 8005276:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 800527a:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 800527e:	b109      	cbz	r1, 8005284 <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8005280:	42bb      	cmp	r3, r7
 8005282:	d1f7      	bne.n	8005274 <xTaskCreate+0x40>
 8005284:	9d08      	ldr	r5, [sp, #32]
 8005286:	2d06      	cmp	r5, #6
 8005288:	bf28      	it	cs
 800528a:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800528c:	2300      	movs	r3, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800528e:	1d27      	adds	r7, r4, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8005290:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8005294:	64a3      	str	r3, [r4, #72]	; 0x48
	pxNewTCB->uxPriority = uxPriority;
 8005296:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8005298:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800529a:	4638      	mov	r0, r7
 800529c:	f7ff f99b 	bl	80045d6 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80052a0:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80052a4:	f104 0018 	add.w	r0, r4, #24
 80052a8:	f7ff f995 	bl	80045d6 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80052ac:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80052ae:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80052b0:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80052b2:	464a      	mov	r2, r9
 80052b4:	4641      	mov	r1, r8
 80052b6:	4650      	mov	r0, sl
 80052b8:	f7ff f9f6 	bl	80046a8 <pxPortInitialiseStack>
 80052bc:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 80052be:	b106      	cbz	r6, 80052c2 <xTaskCreate+0x8e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80052c0:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 80052c2:	f7ff fa1f 	bl	8004704 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 80052c6:	4b32      	ldr	r3, [pc, #200]	; (8005390 <xTaskCreate+0x15c>)
		if( pxCurrentTCB == NULL )
 80052c8:	4e32      	ldr	r6, [pc, #200]	; (8005394 <xTaskCreate+0x160>)
		uxCurrentNumberOfTasks++;
 80052ca:	681a      	ldr	r2, [r3, #0]
 80052cc:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 80053c0 <xTaskCreate+0x18c>
 80052d0:	3201      	adds	r2, #1
 80052d2:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 80052d4:	6835      	ldr	r5, [r6, #0]
 80052d6:	2d00      	cmp	r5, #0
 80052d8:	d14e      	bne.n	8005378 <xTaskCreate+0x144>
			pxCurrentTCB = pxNewTCB;
 80052da:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80052dc:	681b      	ldr	r3, [r3, #0]
 80052de:	2b01      	cmp	r3, #1
 80052e0:	d11d      	bne.n	800531e <xTaskCreate+0xea>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80052e2:	eb08 0005 	add.w	r0, r8, r5
 80052e6:	3514      	adds	r5, #20
 80052e8:	f7ff f96a 	bl	80045c0 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80052ec:	2d8c      	cmp	r5, #140	; 0x8c
 80052ee:	d1f8      	bne.n	80052e2 <xTaskCreate+0xae>
	vListInitialise( &xDelayedTaskList1 );
 80052f0:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 80053c4 <xTaskCreate+0x190>
	vListInitialise( &xDelayedTaskList2 );
 80052f4:	4d28      	ldr	r5, [pc, #160]	; (8005398 <xTaskCreate+0x164>)
	vListInitialise( &xDelayedTaskList1 );
 80052f6:	4648      	mov	r0, r9
 80052f8:	f7ff f962 	bl	80045c0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80052fc:	4628      	mov	r0, r5
 80052fe:	f7ff f95f 	bl	80045c0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8005302:	4826      	ldr	r0, [pc, #152]	; (800539c <xTaskCreate+0x168>)
 8005304:	f7ff f95c 	bl	80045c0 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8005308:	4825      	ldr	r0, [pc, #148]	; (80053a0 <xTaskCreate+0x16c>)
 800530a:	f7ff f959 	bl	80045c0 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800530e:	4825      	ldr	r0, [pc, #148]	; (80053a4 <xTaskCreate+0x170>)
 8005310:	f7ff f956 	bl	80045c0 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8005314:	4b24      	ldr	r3, [pc, #144]	; (80053a8 <xTaskCreate+0x174>)
 8005316:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800531a:	4b24      	ldr	r3, [pc, #144]	; (80053ac <xTaskCreate+0x178>)
 800531c:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 800531e:	4a24      	ldr	r2, [pc, #144]	; (80053b0 <xTaskCreate+0x17c>)
		prvAddTaskToReadyList( pxNewTCB );
 8005320:	4924      	ldr	r1, [pc, #144]	; (80053b4 <xTaskCreate+0x180>)
		uxTaskNumber++;
 8005322:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8005324:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8005326:	3301      	adds	r3, #1
 8005328:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800532a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800532c:	2501      	movs	r5, #1
 800532e:	fa05 f302 	lsl.w	r3, r5, r2
 8005332:	4303      	orrs	r3, r0
 8005334:	2014      	movs	r0, #20
 8005336:	600b      	str	r3, [r1, #0]
 8005338:	fb00 8002 	mla	r0, r0, r2, r8
 800533c:	4639      	mov	r1, r7
 800533e:	f7ff f94d 	bl	80045dc <vListInsertEnd>
	taskEXIT_CRITICAL();
 8005342:	f7ff fa01 	bl	8004748 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8005346:	4b1c      	ldr	r3, [pc, #112]	; (80053b8 <xTaskCreate+0x184>)
 8005348:	681b      	ldr	r3, [r3, #0]
 800534a:	b163      	cbz	r3, 8005366 <xTaskCreate+0x132>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800534c:	6833      	ldr	r3, [r6, #0]
 800534e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005350:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005352:	429a      	cmp	r2, r3
 8005354:	d207      	bcs.n	8005366 <xTaskCreate+0x132>
			taskYIELD_IF_USING_PREEMPTION();
 8005356:	4b19      	ldr	r3, [pc, #100]	; (80053bc <xTaskCreate+0x188>)
 8005358:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800535c:	601a      	str	r2, [r3, #0]
 800535e:	f3bf 8f4f 	dsb	sy
 8005362:	f3bf 8f6f 	isb	sy
	}
 8005366:	4628      	mov	r0, r5
 8005368:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					vPortFree( pxStack );
 800536c:	4628      	mov	r0, r5
 800536e:	f7ff fbb1 	bl	8004ad4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8005372:	f04f 35ff 	mov.w	r5, #4294967295
 8005376:	e7f6      	b.n	8005366 <xTaskCreate+0x132>
			if( xSchedulerRunning == pdFALSE )
 8005378:	4b0f      	ldr	r3, [pc, #60]	; (80053b8 <xTaskCreate+0x184>)
 800537a:	681b      	ldr	r3, [r3, #0]
 800537c:	2b00      	cmp	r3, #0
 800537e:	d1ce      	bne.n	800531e <xTaskCreate+0xea>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8005380:	6833      	ldr	r3, [r6, #0]
 8005382:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005384:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005386:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8005388:	bf98      	it	ls
 800538a:	6034      	strls	r4, [r6, #0]
 800538c:	e7c7      	b.n	800531e <xTaskCreate+0xea>
 800538e:	bf00      	nop
 8005390:	20003edc 	.word	0x20003edc
 8005394:	20003e44 	.word	0x20003e44
 8005398:	20003f08 	.word	0x20003f08
 800539c:	20003f28 	.word	0x20003f28
 80053a0:	20003f54 	.word	0x20003f54
 80053a4:	20003f40 	.word	0x20003f40
 80053a8:	20003e48 	.word	0x20003e48
 80053ac:	20003e4c 	.word	0x20003e4c
 80053b0:	20003eec 	.word	0x20003eec
 80053b4:	20003ef0 	.word	0x20003ef0
 80053b8:	20003f3c 	.word	0x20003f3c
 80053bc:	e000ed04 	.word	0xe000ed04
 80053c0:	20003e50 	.word	0x20003e50
 80053c4:	20003ef4 	.word	0x20003ef4

080053c8 <vTaskPrioritySet>:
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 80053c8:	2906      	cmp	r1, #6
	{
 80053ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80053ce:	4604      	mov	r4, r0
 80053d0:	460d      	mov	r5, r1
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 80053d2:	d908      	bls.n	80053e6 <vTaskPrioritySet+0x1e>
 80053d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80053d8:	f383 8811 	msr	BASEPRI, r3
 80053dc:	f3bf 8f6f 	isb	sy
 80053e0:	f3bf 8f4f 	dsb	sy
 80053e4:	e7fe      	b.n	80053e4 <vTaskPrioritySet+0x1c>
		taskENTER_CRITICAL();
 80053e6:	f7ff f98d 	bl	8004704 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 80053ea:	b90c      	cbnz	r4, 80053f0 <vTaskPrioritySet+0x28>
 80053ec:	4b28      	ldr	r3, [pc, #160]	; (8005490 <vTaskPrioritySet+0xc8>)
 80053ee:	681c      	ldr	r4, [r3, #0]
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 80053f0:	6c62      	ldr	r2, [r4, #68]	; 0x44
			if( uxCurrentBasePriority != uxNewPriority )
 80053f2:	4295      	cmp	r5, r2
 80053f4:	d040      	beq.n	8005478 <vTaskPrioritySet+0xb0>
 80053f6:	4b26      	ldr	r3, [pc, #152]	; (8005490 <vTaskPrioritySet+0xc8>)
				if( uxNewPriority > uxCurrentBasePriority )
 80053f8:	d942      	bls.n	8005480 <vTaskPrioritySet+0xb8>
					if( pxTCB != pxCurrentTCB )
 80053fa:	6819      	ldr	r1, [r3, #0]
 80053fc:	428c      	cmp	r4, r1
 80053fe:	d044      	beq.n	800548a <vTaskPrioritySet+0xc2>
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8005400:	681b      	ldr	r3, [r3, #0]
 8005402:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 8005404:	42b5      	cmp	r5, r6
 8005406:	bf34      	ite	cc
 8005408:	2600      	movcc	r6, #0
 800540a:	2601      	movcs	r6, #1
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 800540c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800540e:	69a3      	ldr	r3, [r4, #24]
					pxTCB->uxBasePriority = uxNewPriority;
 8005410:	6465      	str	r5, [r4, #68]	; 0x44
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8005412:	42ba      	cmp	r2, r7
						pxTCB->uxPriority = uxNewPriority;
 8005414:	bf08      	it	eq
 8005416:	62e5      	streq	r5, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005418:	2b00      	cmp	r3, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800541a:	bfa4      	itt	ge
 800541c:	f1c5 0507 	rsbge	r5, r5, #7
 8005420:	61a5      	strge	r5, [r4, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005422:	4d1c      	ldr	r5, [pc, #112]	; (8005494 <vTaskPrioritySet+0xcc>)
 8005424:	6962      	ldr	r2, [r4, #20]
 8005426:	2314      	movs	r3, #20
 8005428:	fb03 5307 	mla	r3, r3, r7, r5
 800542c:	429a      	cmp	r2, r3
 800542e:	d11a      	bne.n	8005466 <vTaskPrioritySet+0x9e>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005430:	f104 0804 	add.w	r8, r4, #4
 8005434:	4640      	mov	r0, r8
 8005436:	f7ff f8f4 	bl	8004622 <uxListRemove>
 800543a:	b938      	cbnz	r0, 800544c <vTaskPrioritySet+0x84>
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 800543c:	4916      	ldr	r1, [pc, #88]	; (8005498 <vTaskPrioritySet+0xd0>)
 800543e:	2201      	movs	r2, #1
 8005440:	680b      	ldr	r3, [r1, #0]
 8005442:	fa02 f707 	lsl.w	r7, r2, r7
 8005446:	ea23 0707 	bic.w	r7, r3, r7
 800544a:	600f      	str	r7, [r1, #0]
					prvAddTaskToReadyList( pxTCB );
 800544c:	4912      	ldr	r1, [pc, #72]	; (8005498 <vTaskPrioritySet+0xd0>)
 800544e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005450:	6808      	ldr	r0, [r1, #0]
 8005452:	2301      	movs	r3, #1
 8005454:	4093      	lsls	r3, r2
 8005456:	4303      	orrs	r3, r0
 8005458:	2014      	movs	r0, #20
 800545a:	600b      	str	r3, [r1, #0]
 800545c:	fb00 5002 	mla	r0, r0, r2, r5
 8005460:	4641      	mov	r1, r8
 8005462:	f7ff f8bb 	bl	80045dc <vListInsertEnd>
				if( xYieldRequired != pdFALSE )
 8005466:	b13e      	cbz	r6, 8005478 <vTaskPrioritySet+0xb0>
					taskYIELD_IF_USING_PREEMPTION();
 8005468:	4b0c      	ldr	r3, [pc, #48]	; (800549c <vTaskPrioritySet+0xd4>)
 800546a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800546e:	601a      	str	r2, [r3, #0]
 8005470:	f3bf 8f4f 	dsb	sy
 8005474:	f3bf 8f6f 	isb	sy
	}
 8005478:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		taskEXIT_CRITICAL();
 800547c:	f7ff b964 	b.w	8004748 <vPortExitCritical>
				else if( pxTCB == pxCurrentTCB )
 8005480:	681e      	ldr	r6, [r3, #0]
 8005482:	1ba3      	subs	r3, r4, r6
 8005484:	425e      	negs	r6, r3
 8005486:	415e      	adcs	r6, r3
 8005488:	e7c0      	b.n	800540c <vTaskPrioritySet+0x44>
	BaseType_t xYieldRequired = pdFALSE;
 800548a:	2600      	movs	r6, #0
 800548c:	e7be      	b.n	800540c <vTaskPrioritySet+0x44>
 800548e:	bf00      	nop
 8005490:	20003e44 	.word	0x20003e44
 8005494:	20003e50 	.word	0x20003e50
 8005498:	20003ef0 	.word	0x20003ef0
 800549c:	e000ed04 	.word	0xe000ed04

080054a0 <vTaskResume>:
	{
 80054a0:	b570      	push	{r4, r5, r6, lr}
		configASSERT( xTaskToResume );
 80054a2:	4604      	mov	r4, r0
 80054a4:	b940      	cbnz	r0, 80054b8 <vTaskResume+0x18>
 80054a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80054aa:	f383 8811 	msr	BASEPRI, r3
 80054ae:	f3bf 8f6f 	isb	sy
 80054b2:	f3bf 8f4f 	dsb	sy
 80054b6:	e7fe      	b.n	80054b6 <vTaskResume+0x16>
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 80054b8:	4d16      	ldr	r5, [pc, #88]	; (8005514 <vTaskResume+0x74>)
 80054ba:	682b      	ldr	r3, [r5, #0]
 80054bc:	4298      	cmp	r0, r3
 80054be:	d028      	beq.n	8005512 <vTaskResume+0x72>
			taskENTER_CRITICAL();
 80054c0:	f7ff f920 	bl	8004704 <vPortEnterCritical>
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 80054c4:	4620      	mov	r0, r4
 80054c6:	f7ff fe9f 	bl	8005208 <prvTaskIsTaskSuspended>
 80054ca:	b1f0      	cbz	r0, 800550a <vTaskResume+0x6a>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 80054cc:	1d26      	adds	r6, r4, #4
 80054ce:	4630      	mov	r0, r6
 80054d0:	f7ff f8a7 	bl	8004622 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80054d4:	4910      	ldr	r1, [pc, #64]	; (8005518 <vTaskResume+0x78>)
 80054d6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80054d8:	6808      	ldr	r0, [r1, #0]
 80054da:	2301      	movs	r3, #1
 80054dc:	4093      	lsls	r3, r2
 80054de:	4303      	orrs	r3, r0
 80054e0:	600b      	str	r3, [r1, #0]
 80054e2:	4b0e      	ldr	r3, [pc, #56]	; (800551c <vTaskResume+0x7c>)
 80054e4:	2014      	movs	r0, #20
 80054e6:	fb00 3002 	mla	r0, r0, r2, r3
 80054ea:	4631      	mov	r1, r6
 80054ec:	f7ff f876 	bl	80045dc <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80054f0:	682b      	ldr	r3, [r5, #0]
 80054f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80054f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80054f6:	429a      	cmp	r2, r3
 80054f8:	d307      	bcc.n	800550a <vTaskResume+0x6a>
						taskYIELD_IF_USING_PREEMPTION();
 80054fa:	4b09      	ldr	r3, [pc, #36]	; (8005520 <vTaskResume+0x80>)
 80054fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005500:	601a      	str	r2, [r3, #0]
 8005502:	f3bf 8f4f 	dsb	sy
 8005506:	f3bf 8f6f 	isb	sy
	}
 800550a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			taskEXIT_CRITICAL();
 800550e:	f7ff b91b 	b.w	8004748 <vPortExitCritical>
 8005512:	bd70      	pop	{r4, r5, r6, pc}
 8005514:	20003e44 	.word	0x20003e44
 8005518:	20003ef0 	.word	0x20003ef0
 800551c:	20003e50 	.word	0x20003e50
 8005520:	e000ed04 	.word	0xe000ed04

08005524 <xTaskResumeFromISR>:
	{
 8005524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( xTaskToResume );
 8005526:	4605      	mov	r5, r0
 8005528:	b940      	cbnz	r0, 800553c <xTaskResumeFromISR+0x18>
 800552a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800552e:	f383 8811 	msr	BASEPRI, r3
 8005532:	f3bf 8f6f 	isb	sy
 8005536:	f3bf 8f4f 	dsb	sy
 800553a:	e7fe      	b.n	800553a <xTaskResumeFromISR+0x16>
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800553c:	f7ff f9ea 	bl	8004914 <vPortValidateInterruptPriority>
	__asm volatile
 8005540:	f3ef 8611 	mrs	r6, BASEPRI
 8005544:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005548:	f383 8811 	msr	BASEPRI, r3
 800554c:	f3bf 8f6f 	isb	sy
 8005550:	f3bf 8f4f 	dsb	sy
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 8005554:	4628      	mov	r0, r5
 8005556:	f7ff fe57 	bl	8005208 <prvTaskIsTaskSuspended>
 800555a:	b338      	cbz	r0, 80055ac <xTaskResumeFromISR+0x88>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800555c:	4b14      	ldr	r3, [pc, #80]	; (80055b0 <xTaskResumeFromISR+0x8c>)
 800555e:	681b      	ldr	r3, [r3, #0]
 8005560:	b9eb      	cbnz	r3, 800559e <xTaskResumeFromISR+0x7a>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005562:	4b14      	ldr	r3, [pc, #80]	; (80055b4 <xTaskResumeFromISR+0x90>)
 8005564:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 8005566:	681b      	ldr	r3, [r3, #0]
 8005568:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800556a:	1d2f      	adds	r7, r5, #4
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800556c:	4284      	cmp	r4, r0
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800556e:	4638      	mov	r0, r7
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005570:	bf34      	ite	cc
 8005572:	2400      	movcc	r4, #0
 8005574:	2401      	movcs	r4, #1
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005576:	f7ff f854 	bl	8004622 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800557a:	490f      	ldr	r1, [pc, #60]	; (80055b8 <xTaskResumeFromISR+0x94>)
 800557c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800557e:	6808      	ldr	r0, [r1, #0]
 8005580:	2301      	movs	r3, #1
 8005582:	4093      	lsls	r3, r2
 8005584:	4303      	orrs	r3, r0
 8005586:	600b      	str	r3, [r1, #0]
 8005588:	4b0c      	ldr	r3, [pc, #48]	; (80055bc <xTaskResumeFromISR+0x98>)
 800558a:	2014      	movs	r0, #20
 800558c:	4639      	mov	r1, r7
 800558e:	fb00 3002 	mla	r0, r0, r2, r3
 8005592:	f7ff f823 	bl	80045dc <vListInsertEnd>
	__asm volatile
 8005596:	f386 8811 	msr	BASEPRI, r6
	}
 800559a:	4620      	mov	r0, r4
 800559c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800559e:	f105 0118 	add.w	r1, r5, #24
 80055a2:	4807      	ldr	r0, [pc, #28]	; (80055c0 <xTaskResumeFromISR+0x9c>)
 80055a4:	f7ff f81a 	bl	80045dc <vListInsertEnd>
	BaseType_t xYieldRequired = pdFALSE;
 80055a8:	2400      	movs	r4, #0
 80055aa:	e7f4      	b.n	8005596 <xTaskResumeFromISR+0x72>
 80055ac:	4604      	mov	r4, r0
 80055ae:	e7f2      	b.n	8005596 <xTaskResumeFromISR+0x72>
 80055b0:	20003ee8 	.word	0x20003ee8
 80055b4:	20003e44 	.word	0x20003e44
 80055b8:	20003ef0 	.word	0x20003ef0
 80055bc:	20003e50 	.word	0x20003e50
 80055c0:	20003f28 	.word	0x20003f28

080055c4 <vTaskStartScheduler>:
{
 80055c4:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 80055c6:	4b17      	ldr	r3, [pc, #92]	; (8005624 <vTaskStartScheduler+0x60>)
 80055c8:	9301      	str	r3, [sp, #4]
 80055ca:	2400      	movs	r4, #0
 80055cc:	9400      	str	r4, [sp, #0]
 80055ce:	4623      	mov	r3, r4
 80055d0:	2280      	movs	r2, #128	; 0x80
 80055d2:	4915      	ldr	r1, [pc, #84]	; (8005628 <vTaskStartScheduler+0x64>)
 80055d4:	4815      	ldr	r0, [pc, #84]	; (800562c <vTaskStartScheduler+0x68>)
 80055d6:	f7ff fe2d 	bl	8005234 <xTaskCreate>
	if( xReturn == pdPASS )
 80055da:	2801      	cmp	r0, #1
 80055dc:	d114      	bne.n	8005608 <vTaskStartScheduler+0x44>
	__asm volatile
 80055de:	f04f 0350 	mov.w	r3, #80	; 0x50
 80055e2:	f383 8811 	msr	BASEPRI, r3
 80055e6:	f3bf 8f6f 	isb	sy
 80055ea:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 80055ee:	4b10      	ldr	r3, [pc, #64]	; (8005630 <vTaskStartScheduler+0x6c>)
 80055f0:	f04f 32ff 	mov.w	r2, #4294967295
 80055f4:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 80055f6:	4b0f      	ldr	r3, [pc, #60]	; (8005634 <vTaskStartScheduler+0x70>)
 80055f8:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 80055fa:	4b0f      	ldr	r3, [pc, #60]	; (8005638 <vTaskStartScheduler+0x74>)
 80055fc:	601c      	str	r4, [r3, #0]
}
 80055fe:	b002      	add	sp, #8
 8005600:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 8005604:	f7ff b910 	b.w	8004828 <xPortStartScheduler>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8005608:	3001      	adds	r0, #1
 800560a:	d108      	bne.n	800561e <vTaskStartScheduler+0x5a>
 800560c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005610:	f383 8811 	msr	BASEPRI, r3
 8005614:	f3bf 8f6f 	isb	sy
 8005618:	f3bf 8f4f 	dsb	sy
 800561c:	e7fe      	b.n	800561c <vTaskStartScheduler+0x58>
}
 800561e:	b002      	add	sp, #8
 8005620:	bd10      	pop	{r4, pc}
 8005622:	bf00      	nop
 8005624:	20003f1c 	.word	0x20003f1c
 8005628:	080066ee 	.word	0x080066ee
 800562c:	080058c5 	.word	0x080058c5
 8005630:	20003f20 	.word	0x20003f20
 8005634:	20003f3c 	.word	0x20003f3c
 8005638:	20003f68 	.word	0x20003f68

0800563c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800563c:	4a02      	ldr	r2, [pc, #8]	; (8005648 <vTaskSuspendAll+0xc>)
 800563e:	6813      	ldr	r3, [r2, #0]
 8005640:	3301      	adds	r3, #1
 8005642:	6013      	str	r3, [r2, #0]
 8005644:	4770      	bx	lr
 8005646:	bf00      	nop
 8005648:	20003ee8 	.word	0x20003ee8

0800564c <xTaskGetTickCount>:
		xTicks = xTickCount;
 800564c:	4b01      	ldr	r3, [pc, #4]	; (8005654 <xTaskGetTickCount+0x8>)
 800564e:	6818      	ldr	r0, [r3, #0]
}
 8005650:	4770      	bx	lr
 8005652:	bf00      	nop
 8005654:	20003f68 	.word	0x20003f68

08005658 <xTaskGetTickCountFromISR>:
{
 8005658:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800565a:	f7ff f95b 	bl	8004914 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800565e:	4b01      	ldr	r3, [pc, #4]	; (8005664 <xTaskGetTickCountFromISR+0xc>)
 8005660:	6818      	ldr	r0, [r3, #0]
}
 8005662:	bd08      	pop	{r3, pc}
 8005664:	20003f68 	.word	0x20003f68

08005668 <xTaskIncrementTick>:
{
 8005668:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800566c:	4b3c      	ldr	r3, [pc, #240]	; (8005760 <xTaskIncrementTick+0xf8>)
 800566e:	681b      	ldr	r3, [r3, #0]
 8005670:	2b00      	cmp	r3, #0
 8005672:	d153      	bne.n	800571c <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + 1;
 8005674:	4b3b      	ldr	r3, [pc, #236]	; (8005764 <xTaskIncrementTick+0xfc>)
 8005676:	681c      	ldr	r4, [r3, #0]
 8005678:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 800567a:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 800567c:	b9bc      	cbnz	r4, 80056ae <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 800567e:	4b3a      	ldr	r3, [pc, #232]	; (8005768 <xTaskIncrementTick+0x100>)
 8005680:	681a      	ldr	r2, [r3, #0]
 8005682:	6812      	ldr	r2, [r2, #0]
 8005684:	b142      	cbz	r2, 8005698 <xTaskIncrementTick+0x30>
 8005686:	f04f 0350 	mov.w	r3, #80	; 0x50
 800568a:	f383 8811 	msr	BASEPRI, r3
 800568e:	f3bf 8f6f 	isb	sy
 8005692:	f3bf 8f4f 	dsb	sy
 8005696:	e7fe      	b.n	8005696 <xTaskIncrementTick+0x2e>
 8005698:	4a34      	ldr	r2, [pc, #208]	; (800576c <xTaskIncrementTick+0x104>)
 800569a:	6819      	ldr	r1, [r3, #0]
 800569c:	6810      	ldr	r0, [r2, #0]
 800569e:	6018      	str	r0, [r3, #0]
 80056a0:	6011      	str	r1, [r2, #0]
 80056a2:	4a33      	ldr	r2, [pc, #204]	; (8005770 <xTaskIncrementTick+0x108>)
 80056a4:	6813      	ldr	r3, [r2, #0]
 80056a6:	3301      	adds	r3, #1
 80056a8:	6013      	str	r3, [r2, #0]
 80056aa:	f7ff fd4b 	bl	8005144 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80056ae:	4d31      	ldr	r5, [pc, #196]	; (8005774 <xTaskIncrementTick+0x10c>)
 80056b0:	4f31      	ldr	r7, [pc, #196]	; (8005778 <xTaskIncrementTick+0x110>)
 80056b2:	682b      	ldr	r3, [r5, #0]
 80056b4:	429c      	cmp	r4, r3
 80056b6:	f04f 0b00 	mov.w	fp, #0
 80056ba:	d33e      	bcc.n	800573a <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80056bc:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8005768 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 80056c0:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8005788 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80056c4:	f8d8 2000 	ldr.w	r2, [r8]
 80056c8:	6812      	ldr	r2, [r2, #0]
 80056ca:	bb72      	cbnz	r2, 800572a <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80056cc:	f04f 32ff 	mov.w	r2, #4294967295
 80056d0:	602a      	str	r2, [r5, #0]
					break;
 80056d2:	e032      	b.n	800573a <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80056d4:	f106 0a04 	add.w	sl, r6, #4
 80056d8:	4650      	mov	r0, sl
 80056da:	f7fe ffa2 	bl	8004622 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80056de:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 80056e0:	b119      	cbz	r1, 80056ea <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80056e2:	f106 0018 	add.w	r0, r6, #24
 80056e6:	f7fe ff9c 	bl	8004622 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80056ea:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80056ec:	f8d9 3000 	ldr.w	r3, [r9]
 80056f0:	2201      	movs	r2, #1
 80056f2:	fa02 f100 	lsl.w	r1, r2, r0
 80056f6:	4319      	orrs	r1, r3
 80056f8:	4b20      	ldr	r3, [pc, #128]	; (800577c <xTaskIncrementTick+0x114>)
 80056fa:	f8c9 1000 	str.w	r1, [r9]
 80056fe:	f04f 0e14 	mov.w	lr, #20
 8005702:	4651      	mov	r1, sl
 8005704:	fb0e 3000 	mla	r0, lr, r0, r3
 8005708:	f7fe ff68 	bl	80045dc <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800570c:	6838      	ldr	r0, [r7, #0]
 800570e:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8005710:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8005712:	4291      	cmp	r1, r2
 8005714:	bf28      	it	cs
 8005716:	f04f 0b01 	movcs.w	fp, #1
 800571a:	e7d3      	b.n	80056c4 <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 800571c:	4a18      	ldr	r2, [pc, #96]	; (8005780 <xTaskIncrementTick+0x118>)
 800571e:	6813      	ldr	r3, [r2, #0]
 8005720:	3301      	adds	r3, #1
 8005722:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8005724:	f04f 0b00 	mov.w	fp, #0
 8005728:	e011      	b.n	800574e <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800572a:	f8d8 2000 	ldr.w	r2, [r8]
 800572e:	68d2      	ldr	r2, [r2, #12]
 8005730:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8005732:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 8005734:	428c      	cmp	r4, r1
 8005736:	d2cd      	bcs.n	80056d4 <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 8005738:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800573a:	683a      	ldr	r2, [r7, #0]
 800573c:	4b0f      	ldr	r3, [pc, #60]	; (800577c <xTaskIncrementTick+0x114>)
 800573e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8005740:	2214      	movs	r2, #20
 8005742:	434a      	muls	r2, r1
 8005744:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 8005746:	2a02      	cmp	r2, #2
 8005748:	bf28      	it	cs
 800574a:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 800574e:	4a0d      	ldr	r2, [pc, #52]	; (8005784 <xTaskIncrementTick+0x11c>)
 8005750:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 8005752:	2a00      	cmp	r2, #0
 8005754:	bf18      	it	ne
 8005756:	f04f 0b01 	movne.w	fp, #1
}
 800575a:	4658      	mov	r0, fp
 800575c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005760:	20003ee8 	.word	0x20003ee8
 8005764:	20003f68 	.word	0x20003f68
 8005768:	20003e48 	.word	0x20003e48
 800576c:	20003e4c 	.word	0x20003e4c
 8005770:	20003f24 	.word	0x20003f24
 8005774:	20003f20 	.word	0x20003f20
 8005778:	20003e44 	.word	0x20003e44
 800577c:	20003e50 	.word	0x20003e50
 8005780:	20003ee4 	.word	0x20003ee4
 8005784:	20003f6c 	.word	0x20003f6c
 8005788:	20003ef0 	.word	0x20003ef0

0800578c <xTaskResumeAll>:
{
 800578c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8005790:	4c31      	ldr	r4, [pc, #196]	; (8005858 <xTaskResumeAll+0xcc>)
 8005792:	6823      	ldr	r3, [r4, #0]
 8005794:	b943      	cbnz	r3, 80057a8 <xTaskResumeAll+0x1c>
 8005796:	f04f 0350 	mov.w	r3, #80	; 0x50
 800579a:	f383 8811 	msr	BASEPRI, r3
 800579e:	f3bf 8f6f 	isb	sy
 80057a2:	f3bf 8f4f 	dsb	sy
 80057a6:	e7fe      	b.n	80057a6 <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 80057a8:	f7fe ffac 	bl	8004704 <vPortEnterCritical>
		--uxSchedulerSuspended;
 80057ac:	6823      	ldr	r3, [r4, #0]
 80057ae:	3b01      	subs	r3, #1
 80057b0:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80057b2:	6824      	ldr	r4, [r4, #0]
 80057b4:	b12c      	cbz	r4, 80057c2 <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 80057b6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80057b8:	f7fe ffc6 	bl	8004748 <vPortExitCritical>
}
 80057bc:	4620      	mov	r0, r4
 80057be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80057c2:	4b26      	ldr	r3, [pc, #152]	; (800585c <xTaskResumeAll+0xd0>)
 80057c4:	681b      	ldr	r3, [r3, #0]
 80057c6:	2b00      	cmp	r3, #0
 80057c8:	d0f5      	beq.n	80057b6 <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80057ca:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 8005874 <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 80057ce:	4f24      	ldr	r7, [pc, #144]	; (8005860 <xTaskResumeAll+0xd4>)
 80057d0:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8005878 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80057d4:	f8d9 3000 	ldr.w	r3, [r9]
 80057d8:	b9e3      	cbnz	r3, 8005814 <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 80057da:	b10c      	cbz	r4, 80057e0 <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 80057dc:	f7ff fcb2 	bl	8005144 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80057e0:	4d20      	ldr	r5, [pc, #128]	; (8005864 <xTaskResumeAll+0xd8>)
 80057e2:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80057e4:	b144      	cbz	r4, 80057f8 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 80057e6:	4e20      	ldr	r6, [pc, #128]	; (8005868 <xTaskResumeAll+0xdc>)
 80057e8:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 80057ea:	f7ff ff3d 	bl	8005668 <xTaskIncrementTick>
 80057ee:	b100      	cbz	r0, 80057f2 <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 80057f0:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80057f2:	3c01      	subs	r4, #1
 80057f4:	d1f9      	bne.n	80057ea <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 80057f6:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 80057f8:	4b1b      	ldr	r3, [pc, #108]	; (8005868 <xTaskResumeAll+0xdc>)
 80057fa:	681b      	ldr	r3, [r3, #0]
 80057fc:	2b00      	cmp	r3, #0
 80057fe:	d0da      	beq.n	80057b6 <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 8005800:	4b1a      	ldr	r3, [pc, #104]	; (800586c <xTaskResumeAll+0xe0>)
 8005802:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005806:	601a      	str	r2, [r3, #0]
 8005808:	f3bf 8f4f 	dsb	sy
 800580c:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8005810:	2401      	movs	r4, #1
 8005812:	e7d1      	b.n	80057b8 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8005814:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8005818:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800581a:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800581c:	f104 0018 	add.w	r0, r4, #24
 8005820:	f7fe feff 	bl	8004622 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005824:	4630      	mov	r0, r6
 8005826:	f7fe fefc 	bl	8004622 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800582a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800582c:	6839      	ldr	r1, [r7, #0]
 800582e:	2501      	movs	r5, #1
 8005830:	fa05 f302 	lsl.w	r3, r5, r2
 8005834:	2014      	movs	r0, #20
 8005836:	430b      	orrs	r3, r1
 8005838:	fb00 8002 	mla	r0, r0, r2, r8
 800583c:	4631      	mov	r1, r6
 800583e:	603b      	str	r3, [r7, #0]
 8005840:	f7fe fecc 	bl	80045dc <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005844:	4b0a      	ldr	r3, [pc, #40]	; (8005870 <xTaskResumeAll+0xe4>)
 8005846:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005848:	681b      	ldr	r3, [r3, #0]
 800584a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800584c:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 800584e:	bf24      	itt	cs
 8005850:	4b05      	ldrcs	r3, [pc, #20]	; (8005868 <xTaskResumeAll+0xdc>)
 8005852:	601d      	strcs	r5, [r3, #0]
 8005854:	e7be      	b.n	80057d4 <xTaskResumeAll+0x48>
 8005856:	bf00      	nop
 8005858:	20003ee8 	.word	0x20003ee8
 800585c:	20003edc 	.word	0x20003edc
 8005860:	20003ef0 	.word	0x20003ef0
 8005864:	20003ee4 	.word	0x20003ee4
 8005868:	20003f6c 	.word	0x20003f6c
 800586c:	e000ed04 	.word	0xe000ed04
 8005870:	20003e44 	.word	0x20003e44
 8005874:	20003f28 	.word	0x20003f28
 8005878:	20003e50 	.word	0x20003e50

0800587c <vTaskDelay>:
	{
 800587c:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800587e:	b940      	cbnz	r0, 8005892 <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 8005880:	4b0e      	ldr	r3, [pc, #56]	; (80058bc <vTaskDelay+0x40>)
 8005882:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005886:	601a      	str	r2, [r3, #0]
 8005888:	f3bf 8f4f 	dsb	sy
 800588c:	f3bf 8f6f 	isb	sy
 8005890:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8005892:	4b0b      	ldr	r3, [pc, #44]	; (80058c0 <vTaskDelay+0x44>)
 8005894:	6819      	ldr	r1, [r3, #0]
 8005896:	b141      	cbz	r1, 80058aa <vTaskDelay+0x2e>
 8005898:	f04f 0350 	mov.w	r3, #80	; 0x50
 800589c:	f383 8811 	msr	BASEPRI, r3
 80058a0:	f3bf 8f6f 	isb	sy
 80058a4:	f3bf 8f4f 	dsb	sy
 80058a8:	e7fe      	b.n	80058a8 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 80058aa:	f7ff fec7 	bl	800563c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80058ae:	f7ff fc5b 	bl	8005168 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80058b2:	f7ff ff6b 	bl	800578c <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80058b6:	2800      	cmp	r0, #0
 80058b8:	d0e2      	beq.n	8005880 <vTaskDelay+0x4>
 80058ba:	bd08      	pop	{r3, pc}
 80058bc:	e000ed04 	.word	0xe000ed04
 80058c0:	20003ee8 	.word	0x20003ee8

080058c4 <prvIdleTask>:
{
 80058c4:	b508      	push	{r3, lr}
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80058c6:	4e11      	ldr	r6, [pc, #68]	; (800590c <prvIdleTask+0x48>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80058c8:	4c11      	ldr	r4, [pc, #68]	; (8005910 <prvIdleTask+0x4c>)
 80058ca:	6823      	ldr	r3, [r4, #0]
 80058cc:	2b00      	cmp	r3, #0
 80058ce:	d0fb      	beq.n	80058c8 <prvIdleTask+0x4>
			vTaskSuspendAll();
 80058d0:	f7ff feb4 	bl	800563c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80058d4:	6835      	ldr	r5, [r6, #0]
			( void ) xTaskResumeAll();
 80058d6:	f7ff ff59 	bl	800578c <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 80058da:	2d00      	cmp	r5, #0
 80058dc:	d0f5      	beq.n	80058ca <prvIdleTask+0x6>
				taskENTER_CRITICAL();
 80058de:	f7fe ff11 	bl	8004704 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 80058e2:	68f3      	ldr	r3, [r6, #12]
 80058e4:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80058e6:	1d28      	adds	r0, r5, #4
 80058e8:	f7fe fe9b 	bl	8004622 <uxListRemove>
					--uxCurrentNumberOfTasks;
 80058ec:	4a09      	ldr	r2, [pc, #36]	; (8005914 <prvIdleTask+0x50>)
 80058ee:	6813      	ldr	r3, [r2, #0]
 80058f0:	3b01      	subs	r3, #1
 80058f2:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 80058f4:	6823      	ldr	r3, [r4, #0]
 80058f6:	3b01      	subs	r3, #1
 80058f8:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 80058fa:	f7fe ff25 	bl	8004748 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 80058fe:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8005900:	f7ff f8e8 	bl	8004ad4 <vPortFree>
			vPortFree( pxTCB );
 8005904:	4628      	mov	r0, r5
 8005906:	f7ff f8e5 	bl	8004ad4 <vPortFree>
 800590a:	e7de      	b.n	80058ca <prvIdleTask+0x6>
 800590c:	20003f54 	.word	0x20003f54
 8005910:	20003ee0 	.word	0x20003ee0
 8005914:	20003edc 	.word	0x20003edc

08005918 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8005918:	4b17      	ldr	r3, [pc, #92]	; (8005978 <vTaskSwitchContext+0x60>)
 800591a:	681a      	ldr	r2, [r3, #0]
 800591c:	4b17      	ldr	r3, [pc, #92]	; (800597c <vTaskSwitchContext+0x64>)
{
 800591e:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8005920:	b112      	cbz	r2, 8005928 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 8005922:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8005924:	601a      	str	r2, [r3, #0]
 8005926:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 8005928:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800592a:	4b15      	ldr	r3, [pc, #84]	; (8005980 <vTaskSwitchContext+0x68>)
 800592c:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 800592e:	fab3 f383 	clz	r3, r3
 8005932:	b2db      	uxtb	r3, r3
 8005934:	f1c3 031f 	rsb	r3, r3, #31
 8005938:	2214      	movs	r2, #20
 800593a:	4912      	ldr	r1, [pc, #72]	; (8005984 <vTaskSwitchContext+0x6c>)
 800593c:	435a      	muls	r2, r3
 800593e:	1888      	adds	r0, r1, r2
 8005940:	588c      	ldr	r4, [r1, r2]
 8005942:	b944      	cbnz	r4, 8005956 <vTaskSwitchContext+0x3e>
	__asm volatile
 8005944:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005948:	f383 8811 	msr	BASEPRI, r3
 800594c:	f3bf 8f6f 	isb	sy
 8005950:	f3bf 8f4f 	dsb	sy
 8005954:	e7fe      	b.n	8005954 <vTaskSwitchContext+0x3c>
 8005956:	6844      	ldr	r4, [r0, #4]
 8005958:	3208      	adds	r2, #8
 800595a:	6864      	ldr	r4, [r4, #4]
 800595c:	6044      	str	r4, [r0, #4]
 800595e:	440a      	add	r2, r1
 8005960:	4294      	cmp	r4, r2
 8005962:	bf04      	itt	eq
 8005964:	6862      	ldreq	r2, [r4, #4]
 8005966:	6042      	streq	r2, [r0, #4]
 8005968:	2214      	movs	r2, #20
 800596a:	fb02 1303 	mla	r3, r2, r3, r1
 800596e:	685b      	ldr	r3, [r3, #4]
 8005970:	68da      	ldr	r2, [r3, #12]
 8005972:	4b05      	ldr	r3, [pc, #20]	; (8005988 <vTaskSwitchContext+0x70>)
 8005974:	e7d6      	b.n	8005924 <vTaskSwitchContext+0xc>
 8005976:	bf00      	nop
 8005978:	20003ee8 	.word	0x20003ee8
 800597c:	20003f6c 	.word	0x20003f6c
 8005980:	20003ef0 	.word	0x20003ef0
 8005984:	20003e50 	.word	0x20003e50
 8005988:	20003e44 	.word	0x20003e44

0800598c <vTaskSuspend>:
	{
 800598c:	b570      	push	{r4, r5, r6, lr}
 800598e:	4604      	mov	r4, r0
 8005990:	4e29      	ldr	r6, [pc, #164]	; (8005a38 <vTaskSuspend+0xac>)
		taskENTER_CRITICAL();
 8005992:	f7fe feb7 	bl	8004704 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8005996:	b904      	cbnz	r4, 800599a <vTaskSuspend+0xe>
 8005998:	6834      	ldr	r4, [r6, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800599a:	1d25      	adds	r5, r4, #4
 800599c:	4628      	mov	r0, r5
 800599e:	f7fe fe40 	bl	8004622 <uxListRemove>
 80059a2:	b960      	cbnz	r0, 80059be <vTaskSuspend+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80059a4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80059a6:	4b25      	ldr	r3, [pc, #148]	; (8005a3c <vTaskSuspend+0xb0>)
 80059a8:	2114      	movs	r1, #20
 80059aa:	4341      	muls	r1, r0
 80059ac:	585b      	ldr	r3, [r3, r1]
 80059ae:	b933      	cbnz	r3, 80059be <vTaskSuspend+0x32>
 80059b0:	4923      	ldr	r1, [pc, #140]	; (8005a40 <vTaskSuspend+0xb4>)
 80059b2:	2201      	movs	r2, #1
 80059b4:	680b      	ldr	r3, [r1, #0]
 80059b6:	4082      	lsls	r2, r0
 80059b8:	ea23 0302 	bic.w	r3, r3, r2
 80059bc:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80059be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80059c0:	b11b      	cbz	r3, 80059ca <vTaskSuspend+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80059c2:	f104 0018 	add.w	r0, r4, #24
 80059c6:	f7fe fe2c 	bl	8004622 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 80059ca:	4629      	mov	r1, r5
		if( xSchedulerRunning != pdFALSE )
 80059cc:	4d1d      	ldr	r5, [pc, #116]	; (8005a44 <vTaskSuspend+0xb8>)
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 80059ce:	481e      	ldr	r0, [pc, #120]	; (8005a48 <vTaskSuspend+0xbc>)
 80059d0:	f7fe fe04 	bl	80045dc <vListInsertEnd>
		taskEXIT_CRITICAL();
 80059d4:	f7fe feb8 	bl	8004748 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 80059d8:	682a      	ldr	r2, [r5, #0]
 80059da:	b12a      	cbz	r2, 80059e8 <vTaskSuspend+0x5c>
			taskENTER_CRITICAL();
 80059dc:	f7fe fe92 	bl	8004704 <vPortEnterCritical>
				prvResetNextTaskUnblockTime();
 80059e0:	f7ff fbb0 	bl	8005144 <prvResetNextTaskUnblockTime>
			taskEXIT_CRITICAL();
 80059e4:	f7fe feb0 	bl	8004748 <vPortExitCritical>
		if( pxTCB == pxCurrentTCB )
 80059e8:	6833      	ldr	r3, [r6, #0]
 80059ea:	429c      	cmp	r4, r3
 80059ec:	d122      	bne.n	8005a34 <vTaskSuspend+0xa8>
			if( xSchedulerRunning != pdFALSE )
 80059ee:	682b      	ldr	r3, [r5, #0]
 80059f0:	b1a3      	cbz	r3, 8005a1c <vTaskSuspend+0x90>
				configASSERT( uxSchedulerSuspended == 0 );
 80059f2:	4b16      	ldr	r3, [pc, #88]	; (8005a4c <vTaskSuspend+0xc0>)
 80059f4:	681b      	ldr	r3, [r3, #0]
 80059f6:	b143      	cbz	r3, 8005a0a <vTaskSuspend+0x7e>
 80059f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80059fc:	f383 8811 	msr	BASEPRI, r3
 8005a00:	f3bf 8f6f 	isb	sy
 8005a04:	f3bf 8f4f 	dsb	sy
 8005a08:	e7fe      	b.n	8005a08 <vTaskSuspend+0x7c>
				portYIELD_WITHIN_API();
 8005a0a:	4b11      	ldr	r3, [pc, #68]	; (8005a50 <vTaskSuspend+0xc4>)
 8005a0c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005a10:	601a      	str	r2, [r3, #0]
 8005a12:	f3bf 8f4f 	dsb	sy
 8005a16:	f3bf 8f6f 	isb	sy
 8005a1a:	bd70      	pop	{r4, r5, r6, pc}
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8005a1c:	4a0d      	ldr	r2, [pc, #52]	; (8005a54 <vTaskSuspend+0xc8>)
 8005a1e:	490a      	ldr	r1, [pc, #40]	; (8005a48 <vTaskSuspend+0xbc>)
 8005a20:	6812      	ldr	r2, [r2, #0]
 8005a22:	6809      	ldr	r1, [r1, #0]
 8005a24:	4291      	cmp	r1, r2
 8005a26:	d101      	bne.n	8005a2c <vTaskSuspend+0xa0>
					pxCurrentTCB = NULL;
 8005a28:	6033      	str	r3, [r6, #0]
 8005a2a:	bd70      	pop	{r4, r5, r6, pc}
	}
 8005a2c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					vTaskSwitchContext();
 8005a30:	f7ff bf72 	b.w	8005918 <vTaskSwitchContext>
 8005a34:	bd70      	pop	{r4, r5, r6, pc}
 8005a36:	bf00      	nop
 8005a38:	20003e44 	.word	0x20003e44
 8005a3c:	20003e50 	.word	0x20003e50
 8005a40:	20003ef0 	.word	0x20003ef0
 8005a44:	20003f3c 	.word	0x20003f3c
 8005a48:	20003f40 	.word	0x20003f40
 8005a4c:	20003ee8 	.word	0x20003ee8
 8005a50:	e000ed04 	.word	0xe000ed04
 8005a54:	20003edc 	.word	0x20003edc

08005a58 <vTaskPlaceOnEventList>:
{
 8005a58:	b510      	push	{r4, lr}
 8005a5a:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 8005a5c:	b940      	cbnz	r0, 8005a70 <vTaskPlaceOnEventList+0x18>
 8005a5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005a62:	f383 8811 	msr	BASEPRI, r3
 8005a66:	f3bf 8f6f 	isb	sy
 8005a6a:	f3bf 8f4f 	dsb	sy
 8005a6e:	e7fe      	b.n	8005a6e <vTaskPlaceOnEventList+0x16>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8005a70:	4b05      	ldr	r3, [pc, #20]	; (8005a88 <vTaskPlaceOnEventList+0x30>)
 8005a72:	6819      	ldr	r1, [r3, #0]
 8005a74:	3118      	adds	r1, #24
 8005a76:	f7fe fdbd 	bl	80045f4 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8005a7a:	4620      	mov	r0, r4
 8005a7c:	2101      	movs	r1, #1
}
 8005a7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8005a82:	f7ff bb71 	b.w	8005168 <prvAddCurrentTaskToDelayedList>
 8005a86:	bf00      	nop
 8005a88:	20003e44 	.word	0x20003e44

08005a8c <xTaskRemoveFromEventList>:
{
 8005a8c:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005a8e:	68c3      	ldr	r3, [r0, #12]
 8005a90:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8005a92:	b944      	cbnz	r4, 8005aa6 <xTaskRemoveFromEventList+0x1a>
 8005a94:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005a98:	f383 8811 	msr	BASEPRI, r3
 8005a9c:	f3bf 8f6f 	isb	sy
 8005aa0:	f3bf 8f4f 	dsb	sy
 8005aa4:	e7fe      	b.n	8005aa4 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8005aa6:	f104 0518 	add.w	r5, r4, #24
 8005aaa:	4628      	mov	r0, r5
 8005aac:	f7fe fdb9 	bl	8004622 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005ab0:	4b11      	ldr	r3, [pc, #68]	; (8005af8 <xTaskRemoveFromEventList+0x6c>)
 8005ab2:	681b      	ldr	r3, [r3, #0]
 8005ab4:	b9e3      	cbnz	r3, 8005af0 <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8005ab6:	1d25      	adds	r5, r4, #4
 8005ab8:	4628      	mov	r0, r5
 8005aba:	f7fe fdb2 	bl	8004622 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8005abe:	490f      	ldr	r1, [pc, #60]	; (8005afc <xTaskRemoveFromEventList+0x70>)
 8005ac0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005ac2:	6808      	ldr	r0, [r1, #0]
 8005ac4:	2301      	movs	r3, #1
 8005ac6:	4093      	lsls	r3, r2
 8005ac8:	4303      	orrs	r3, r0
 8005aca:	600b      	str	r3, [r1, #0]
 8005acc:	4b0c      	ldr	r3, [pc, #48]	; (8005b00 <xTaskRemoveFromEventList+0x74>)
 8005ace:	2014      	movs	r0, #20
 8005ad0:	4629      	mov	r1, r5
 8005ad2:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8005ad6:	f7fe fd81 	bl	80045dc <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8005ada:	4b0a      	ldr	r3, [pc, #40]	; (8005b04 <xTaskRemoveFromEventList+0x78>)
 8005adc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005ade:	681b      	ldr	r3, [r3, #0]
 8005ae0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005ae2:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8005ae4:	bf83      	ittte	hi
 8005ae6:	4b08      	ldrhi	r3, [pc, #32]	; (8005b08 <xTaskRemoveFromEventList+0x7c>)
 8005ae8:	2001      	movhi	r0, #1
 8005aea:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 8005aec:	2000      	movls	r0, #0
}
 8005aee:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8005af0:	4629      	mov	r1, r5
 8005af2:	4806      	ldr	r0, [pc, #24]	; (8005b0c <xTaskRemoveFromEventList+0x80>)
 8005af4:	e7ef      	b.n	8005ad6 <xTaskRemoveFromEventList+0x4a>
 8005af6:	bf00      	nop
 8005af8:	20003ee8 	.word	0x20003ee8
 8005afc:	20003ef0 	.word	0x20003ef0
 8005b00:	20003e50 	.word	0x20003e50
 8005b04:	20003e44 	.word	0x20003e44
 8005b08:	20003f6c 	.word	0x20003f6c
 8005b0c:	20003f28 	.word	0x20003f28

08005b10 <vTaskSetTimeOutState>:
{
 8005b10:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 8005b12:	b908      	cbnz	r0, 8005b18 <vTaskSetTimeOutState+0x8>
 8005b14:	f7ff fb6e 	bl	80051f4 <prvTaskIsTaskSuspended.part.0>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005b18:	4b03      	ldr	r3, [pc, #12]	; (8005b28 <vTaskSetTimeOutState+0x18>)
 8005b1a:	681b      	ldr	r3, [r3, #0]
 8005b1c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8005b1e:	4b03      	ldr	r3, [pc, #12]	; (8005b2c <vTaskSetTimeOutState+0x1c>)
 8005b20:	681b      	ldr	r3, [r3, #0]
 8005b22:	6043      	str	r3, [r0, #4]
 8005b24:	bd08      	pop	{r3, pc}
 8005b26:	bf00      	nop
 8005b28:	20003f24 	.word	0x20003f24
 8005b2c:	20003f68 	.word	0x20003f68

08005b30 <xTaskCheckForTimeOut>:
{
 8005b30:	b538      	push	{r3, r4, r5, lr}
 8005b32:	460d      	mov	r5, r1
	configASSERT( pxTimeOut );
 8005b34:	4604      	mov	r4, r0
 8005b36:	b940      	cbnz	r0, 8005b4a <xTaskCheckForTimeOut+0x1a>
 8005b38:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b3c:	f383 8811 	msr	BASEPRI, r3
 8005b40:	f3bf 8f6f 	isb	sy
 8005b44:	f3bf 8f4f 	dsb	sy
 8005b48:	e7fe      	b.n	8005b48 <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
 8005b4a:	b941      	cbnz	r1, 8005b5e <xTaskCheckForTimeOut+0x2e>
 8005b4c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b50:	f383 8811 	msr	BASEPRI, r3
 8005b54:	f3bf 8f6f 	isb	sy
 8005b58:	f3bf 8f4f 	dsb	sy
 8005b5c:	e7fe      	b.n	8005b5c <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
 8005b5e:	f7fe fdd1 	bl	8004704 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8005b62:	4b0e      	ldr	r3, [pc, #56]	; (8005b9c <xTaskCheckForTimeOut+0x6c>)
 8005b64:	6819      	ldr	r1, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8005b66:	682b      	ldr	r3, [r5, #0]
 8005b68:	1c5a      	adds	r2, r3, #1
 8005b6a:	d010      	beq.n	8005b8e <xTaskCheckForTimeOut+0x5e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005b6c:	4a0c      	ldr	r2, [pc, #48]	; (8005ba0 <xTaskCheckForTimeOut+0x70>)
 8005b6e:	6820      	ldr	r0, [r4, #0]
 8005b70:	6812      	ldr	r2, [r2, #0]
 8005b72:	4290      	cmp	r0, r2
 8005b74:	6862      	ldr	r2, [r4, #4]
 8005b76:	d001      	beq.n	8005b7c <xTaskCheckForTimeOut+0x4c>
 8005b78:	4291      	cmp	r1, r2
 8005b7a:	d20d      	bcs.n	8005b98 <xTaskCheckForTimeOut+0x68>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005b7c:	1a88      	subs	r0, r1, r2
 8005b7e:	4283      	cmp	r3, r0
 8005b80:	d90a      	bls.n	8005b98 <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8005b82:	1a5b      	subs	r3, r3, r1
 8005b84:	4413      	add	r3, r2
 8005b86:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8005b88:	4620      	mov	r0, r4
 8005b8a:	f7ff ffc1 	bl	8005b10 <vTaskSetTimeOutState>
				xReturn = pdFALSE;
 8005b8e:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8005b90:	f7fe fdda 	bl	8004748 <vPortExitCritical>
}
 8005b94:	4620      	mov	r0, r4
 8005b96:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdTRUE;
 8005b98:	2401      	movs	r4, #1
 8005b9a:	e7f9      	b.n	8005b90 <xTaskCheckForTimeOut+0x60>
 8005b9c:	20003f68 	.word	0x20003f68
 8005ba0:	20003f24 	.word	0x20003f24

08005ba4 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8005ba4:	4b01      	ldr	r3, [pc, #4]	; (8005bac <vTaskMissedYield+0x8>)
 8005ba6:	2201      	movs	r2, #1
 8005ba8:	601a      	str	r2, [r3, #0]
 8005baa:	4770      	bx	lr
 8005bac:	20003f6c 	.word	0x20003f6c

08005bb0 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 8005bb0:	4b01      	ldr	r3, [pc, #4]	; (8005bb8 <xTaskGetCurrentTaskHandle+0x8>)
 8005bb2:	6818      	ldr	r0, [r3, #0]
	}
 8005bb4:	4770      	bx	lr
 8005bb6:	bf00      	nop
 8005bb8:	20003e44 	.word	0x20003e44

08005bbc <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8005bbc:	4b05      	ldr	r3, [pc, #20]	; (8005bd4 <xTaskGetSchedulerState+0x18>)
 8005bbe:	681b      	ldr	r3, [r3, #0]
 8005bc0:	b133      	cbz	r3, 8005bd0 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005bc2:	4b05      	ldr	r3, [pc, #20]	; (8005bd8 <xTaskGetSchedulerState+0x1c>)
 8005bc4:	681b      	ldr	r3, [r3, #0]
 8005bc6:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8005bc8:	bf0c      	ite	eq
 8005bca:	2002      	moveq	r0, #2
 8005bcc:	2000      	movne	r0, #0
 8005bce:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8005bd0:	2001      	movs	r0, #1
	}
 8005bd2:	4770      	bx	lr
 8005bd4:	20003f3c 	.word	0x20003f3c
 8005bd8:	20003ee8 	.word	0x20003ee8

08005bdc <vTaskPriorityInherit>:
	{
 8005bdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 8005be0:	4604      	mov	r4, r0
 8005be2:	2800      	cmp	r0, #0
 8005be4:	d038      	beq.n	8005c58 <vTaskPriorityInherit+0x7c>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8005be6:	4d1d      	ldr	r5, [pc, #116]	; (8005c5c <vTaskPriorityInherit+0x80>)
 8005be8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8005bea:	682a      	ldr	r2, [r5, #0]
 8005bec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005bee:	4293      	cmp	r3, r2
 8005bf0:	d232      	bcs.n	8005c58 <vTaskPriorityInherit+0x7c>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005bf2:	6982      	ldr	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005bf4:	4e1a      	ldr	r6, [pc, #104]	; (8005c60 <vTaskPriorityInherit+0x84>)
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005bf6:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005bf8:	bfa1      	itttt	ge
 8005bfa:	682a      	ldrge	r2, [r5, #0]
 8005bfc:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 8005bfe:	f1c2 0207 	rsbge	r2, r2, #7
 8005c02:	6182      	strge	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005c04:	2714      	movs	r7, #20
 8005c06:	6942      	ldr	r2, [r0, #20]
 8005c08:	fb07 6303 	mla	r3, r7, r3, r6
 8005c0c:	429a      	cmp	r2, r3
 8005c0e:	d120      	bne.n	8005c52 <vTaskPriorityInherit+0x76>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005c10:	f100 0804 	add.w	r8, r0, #4
 8005c14:	4640      	mov	r0, r8
 8005c16:	f7fe fd04 	bl	8004622 <uxListRemove>
 8005c1a:	4a12      	ldr	r2, [pc, #72]	; (8005c64 <vTaskPriorityInherit+0x88>)
 8005c1c:	b948      	cbnz	r0, 8005c32 <vTaskPriorityInherit+0x56>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005c1e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005c20:	4347      	muls	r7, r0
 8005c22:	59f3      	ldr	r3, [r6, r7]
 8005c24:	b92b      	cbnz	r3, 8005c32 <vTaskPriorityInherit+0x56>
 8005c26:	6813      	ldr	r3, [r2, #0]
 8005c28:	2101      	movs	r1, #1
 8005c2a:	4081      	lsls	r1, r0
 8005c2c:	ea23 0301 	bic.w	r3, r3, r1
 8005c30:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005c32:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 8005c34:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005c36:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8005c38:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8005c3a:	2301      	movs	r3, #1
 8005c3c:	4083      	lsls	r3, r0
 8005c3e:	430b      	orrs	r3, r1
 8005c40:	6013      	str	r3, [r2, #0]
 8005c42:	2314      	movs	r3, #20
 8005c44:	4641      	mov	r1, r8
 8005c46:	fb03 6000 	mla	r0, r3, r0, r6
	}
 8005c4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					prvAddTaskToReadyList( pxTCB );
 8005c4e:	f7fe bcc5 	b.w	80045dc <vListInsertEnd>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005c52:	682b      	ldr	r3, [r5, #0]
 8005c54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005c56:	62c3      	str	r3, [r0, #44]	; 0x2c
 8005c58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005c5c:	20003e44 	.word	0x20003e44
 8005c60:	20003e50 	.word	0x20003e50
 8005c64:	20003ef0 	.word	0x20003ef0

08005c68 <xTaskPriorityDisinherit>:
	{
 8005c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 8005c6a:	4604      	mov	r4, r0
 8005c6c:	b908      	cbnz	r0, 8005c72 <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8005c6e:	2000      	movs	r0, #0
 8005c70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 8005c72:	4b22      	ldr	r3, [pc, #136]	; (8005cfc <xTaskPriorityDisinherit+0x94>)
 8005c74:	681b      	ldr	r3, [r3, #0]
 8005c76:	4298      	cmp	r0, r3
 8005c78:	d008      	beq.n	8005c8c <xTaskPriorityDisinherit+0x24>
 8005c7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005c7e:	f383 8811 	msr	BASEPRI, r3
 8005c82:	f3bf 8f6f 	isb	sy
 8005c86:	f3bf 8f4f 	dsb	sy
 8005c8a:	e7fe      	b.n	8005c8a <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 8005c8c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8005c8e:	b943      	cbnz	r3, 8005ca2 <xTaskPriorityDisinherit+0x3a>
 8005c90:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005c94:	f383 8811 	msr	BASEPRI, r3
 8005c98:	f3bf 8f6f 	isb	sy
 8005c9c:	f3bf 8f4f 	dsb	sy
 8005ca0:	e7fe      	b.n	8005ca0 <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005ca2:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8005ca4:	6c42      	ldr	r2, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 8005ca6:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005ca8:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8005caa:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005cac:	d0df      	beq.n	8005c6e <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8005cae:	2b00      	cmp	r3, #0
 8005cb0:	d1dd      	bne.n	8005c6e <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005cb2:	1d05      	adds	r5, r0, #4
 8005cb4:	4628      	mov	r0, r5
 8005cb6:	f7fe fcb4 	bl	8004622 <uxListRemove>
 8005cba:	4e11      	ldr	r6, [pc, #68]	; (8005d00 <xTaskPriorityDisinherit+0x98>)
 8005cbc:	4a11      	ldr	r2, [pc, #68]	; (8005d04 <xTaskPriorityDisinherit+0x9c>)
 8005cbe:	b950      	cbnz	r0, 8005cd6 <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005cc0:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8005cc2:	2114      	movs	r1, #20
 8005cc4:	4379      	muls	r1, r7
 8005cc6:	5873      	ldr	r3, [r6, r1]
 8005cc8:	b92b      	cbnz	r3, 8005cd6 <xTaskPriorityDisinherit+0x6e>
 8005cca:	6813      	ldr	r3, [r2, #0]
 8005ccc:	2001      	movs	r0, #1
 8005cce:	40b8      	lsls	r0, r7
 8005cd0:	ea23 0300 	bic.w	r3, r3, r0
 8005cd4:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8005cd6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005cd8:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005cda:	f1c3 0107 	rsb	r1, r3, #7
 8005cde:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8005ce0:	6811      	ldr	r1, [r2, #0]
 8005ce2:	2401      	movs	r4, #1
 8005ce4:	fa04 f003 	lsl.w	r0, r4, r3
 8005ce8:	4308      	orrs	r0, r1
 8005cea:	6010      	str	r0, [r2, #0]
 8005cec:	2014      	movs	r0, #20
 8005cee:	fb00 6003 	mla	r0, r0, r3, r6
 8005cf2:	4629      	mov	r1, r5
 8005cf4:	f7fe fc72 	bl	80045dc <vListInsertEnd>
					xReturn = pdTRUE;
 8005cf8:	4620      	mov	r0, r4
	}
 8005cfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005cfc:	20003e44 	.word	0x20003e44
 8005d00:	20003e50 	.word	0x20003e50
 8005d04:	20003ef0 	.word	0x20003ef0

08005d08 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8005d08:	4b04      	ldr	r3, [pc, #16]	; (8005d1c <pvTaskIncrementMutexHeldCount+0x14>)
 8005d0a:	681a      	ldr	r2, [r3, #0]
 8005d0c:	b11a      	cbz	r2, 8005d16 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 8005d0e:	6819      	ldr	r1, [r3, #0]
 8005d10:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 8005d12:	3201      	adds	r2, #1
 8005d14:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 8005d16:	6818      	ldr	r0, [r3, #0]
	}
 8005d18:	4770      	bx	lr
 8005d1a:	bf00      	nop
 8005d1c:	20003e44 	.word	0x20003e44

08005d20 <appInit>:
#define HTU_SOFT_RESET 0xfe

extern I2C_HandleTypeDef hi2c2;

void appInit(void)
{
 8005d20:	b508      	push	{r3, lr}
	boardInit();
 8005d22:	f000 f81f 	bl	8005d64 <boardInit>
	msgIOInit();
 8005d26:	f000 fadb 	bl	80062e0 <msgIOInit>
	paramsInit();
 8005d2a:	f000 fbd5 	bl	80064d8 <paramsInit>
//	adcTasksInit();
	motionTasksInit();
//	rangingTasksInit();
}
 8005d2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	motionTasksInit();
 8005d32:	f000 b9ed 	b.w	8006110 <motionTasksInit>
	...

08005d38 <loopTaskEntry>:

void loopTaskEntry(void const * arg)
{
 8005d38:	b508      	push	{r3, lr}
//		msgSend(MSG_TOPIC_AIR, &air, sizeof(air));
//
//		ledToggle(LED_DEVS[0]);
//	}

	osThreadSetPriority(osThreadGetId(), osPriorityLow);
 8005d3a:	f7fe fbb1 	bl	80044a0 <osThreadGetId>
 8005d3e:	f06f 0101 	mvn.w	r1, #1
 8005d42:	f7fe fbaf 	bl	80044a4 <osThreadSetPriority>

	for (;;)
	{
		osDelay(500);
		ledToggle(LED_DEVS[0]);
 8005d46:	4c06      	ldr	r4, [pc, #24]	; (8005d60 <loopTaskEntry+0x28>)
		osDelay(500);
 8005d48:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8005d4c:	f7fe fbb3 	bl	80044b6 <osDelay>
 8005d50:	6823      	ldr	r3, [r4, #0]
 8005d52:	681b      	ldr	r3, [r3, #0]
{
}

static inline void gpioToggle(const GPIODev * dev)
{
	HAL_GPIO_TogglePin(dev->port, dev->pin);
 8005d54:	8899      	ldrh	r1, [r3, #4]
 8005d56:	6818      	ldr	r0, [r3, #0]
 8005d58:	f7fc f9eb 	bl	8002132 <HAL_GPIO_TogglePin>
 8005d5c:	e7f4      	b.n	8005d48 <loopTaskEntry+0x10>
 8005d5e:	bf00      	nop
 8005d60:	20000038 	.word	0x20000038

08005d64 <boardInit>:

NRFDev * NRF_DEVS[] = { &nrf };

const size_t N_NRF_DEVS = ARR_LEN(NRF_DEVS);

void boardInit(void) {
 8005d64:	b538      	push	{r3, r4, r5, lr}
static inline void pwmInit(void)
{
	int i = 0;
	for(i = 0; i < N_PWM_DEVS; i++)
	{
		HAL_TIM_PWM_Start(PWM_DEVS[i]->tim, PWM_DEVS[i]->channel);
 8005d66:	4d0b      	ldr	r5, [pc, #44]	; (8005d94 <boardInit+0x30>)
	for(i = 0; i < N_PWM_DEVS; i++)
 8005d68:	2400      	movs	r4, #0
		HAL_TIM_PWM_Start(PWM_DEVS[i]->tim, PWM_DEVS[i]->channel);
 8005d6a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
	for(i = 0; i < N_PWM_DEVS; i++)
 8005d6e:	3401      	adds	r4, #1
		HAL_TIM_PWM_Start(PWM_DEVS[i]->tim, PWM_DEVS[i]->channel);
 8005d70:	e893 0003 	ldmia.w	r3, {r0, r1}
 8005d74:	f7fd fea8 	bl	8003ac8 <HAL_TIM_PWM_Start>
	for(i = 0; i < N_PWM_DEVS; i++)
 8005d78:	2c04      	cmp	r4, #4
 8005d7a:	d1f6      	bne.n	8005d6a <boardInit+0x6>
static inline void encoderInit(void)
{
	int i = 0;
	for (i = 0; i < N_ENCODERS_DEVS; i++)
	{
		HAL_TIM_Encoder_Start(ENCODER_DEVS[i]->tim, TIM_CHANNEL_ALL);
 8005d7c:	4d06      	ldr	r5, [pc, #24]	; (8005d98 <boardInit+0x34>)
 8005d7e:	2400      	movs	r4, #0
 8005d80:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8005d84:	2118      	movs	r1, #24
 8005d86:	6818      	ldr	r0, [r3, #0]
	for (i = 0; i < N_ENCODERS_DEVS; i++)
 8005d88:	3401      	adds	r4, #1
		HAL_TIM_Encoder_Start(ENCODER_DEVS[i]->tim, TIM_CHANNEL_ALL);
 8005d8a:	f7fd fb57 	bl	800343c <HAL_TIM_Encoder_Start>
	for (i = 0; i < N_ENCODERS_DEVS; i++)
 8005d8e:	2c04      	cmp	r4, #4
 8005d90:	d1f6      	bne.n	8005d80 <boardInit+0x1c>
//	inputCaptureInit();
	uartInit();
//	spiInit();
	wheelInit();
//	nrfInit();
}
 8005d92:	bd38      	pop	{r3, r4, r5, pc}
 8005d94:	20000040 	.word	0x20000040
 8005d98:	2000000c 	.word	0x2000000c

08005d9c <extiIRQHandler>:
#include "exti.h"

void extiIRQHandler(uint16_t gpio_pin)
{
 8005d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	size_t i = 0;
	for (i = 0; i < N_EXTI_DEVS; i++)
 8005d9e:	4b09      	ldr	r3, [pc, #36]	; (8005dc4 <extiIRQHandler+0x28>)
	{
		if (gpio_pin == EXTI_DEVS[i]->gpio->pin)
 8005da0:	4f09      	ldr	r7, [pc, #36]	; (8005dc8 <extiIRQHandler+0x2c>)
	for (i = 0; i < N_EXTI_DEVS; i++)
 8005da2:	681d      	ldr	r5, [r3, #0]
{
 8005da4:	4606      	mov	r6, r0
	for (i = 0; i < N_EXTI_DEVS; i++)
 8005da6:	2400      	movs	r4, #0
 8005da8:	42ac      	cmp	r4, r5
 8005daa:	d300      	bcc.n	8005dae <extiIRQHandler+0x12>
			{
				EXTI_DEVS[i]->callback(EXTI_DEVS[i]);
			}
		}
	}
}
 8005dac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (gpio_pin == EXTI_DEVS[i]->gpio->pin)
 8005dae:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 8005db2:	6803      	ldr	r3, [r0, #0]
 8005db4:	889b      	ldrh	r3, [r3, #4]
 8005db6:	42b3      	cmp	r3, r6
 8005db8:	d102      	bne.n	8005dc0 <extiIRQHandler+0x24>
			if (EXTI_DEVS[i]->callback != NULL)
 8005dba:	6843      	ldr	r3, [r0, #4]
 8005dbc:	b103      	cbz	r3, 8005dc0 <extiIRQHandler+0x24>
				EXTI_DEVS[i]->callback(EXTI_DEVS[i]);
 8005dbe:	4798      	blx	r3
	for (i = 0; i < N_EXTI_DEVS; i++)
 8005dc0:	3401      	adds	r4, #1
 8005dc2:	e7f1      	b.n	8005da8 <extiIRQHandler+0xc>
 8005dc4:	080066f4 	.word	0x080066f4
 8005dc8:	2000001c 	.word	0x2000001c

08005dcc <HAL_GPIO_EXTI_Callback>:

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	extiIRQHandler(GPIO_Pin);
 8005dcc:	f7ff bfe6 	b.w	8005d9c <extiIRQHandler>

08005dd0 <HAL_TIM_IC_CaptureCallback>:
#include "input_capture.h"

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8005dd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	size_t i = 0;
	uint32_t channel = 0, value = 0;

	for (i = 0; i < N_INPUT_CAPTURE_DEVS; i++)
 8005dd4:	4b38      	ldr	r3, [pc, #224]	; (8005eb8 <HAL_TIM_IC_CaptureCallback+0xe8>)
	{
		// Find out active channel.
		if ((INPUT_CAPTURE_DEVS[i]->tim == htim)
 8005dd6:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 8005ebc <HAL_TIM_IC_CaptureCallback+0xec>
	for (i = 0; i < N_INPUT_CAPTURE_DEVS; i++)
 8005dda:	681b      	ldr	r3, [r3, #0]
{
 8005ddc:	4605      	mov	r5, r0
	for (i = 0; i < N_INPUT_CAPTURE_DEVS; i++)
 8005dde:	2600      	movs	r6, #0
 8005de0:	429e      	cmp	r6, r3
 8005de2:	d101      	bne.n	8005de8 <HAL_TIM_IC_CaptureCallback+0x18>
 8005de4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if ((INPUT_CAPTURE_DEVS[i]->tim == htim)
 8005de8:	f859 7026 	ldr.w	r7, [r9, r6, lsl #2]
 8005dec:	f8d7 8000 	ldr.w	r8, [r7]
 8005df0:	45a8      	cmp	r8, r5
 8005df2:	d15f      	bne.n	8005eb4 <HAL_TIM_IC_CaptureCallback+0xe4>
				&& (INPUT_CAPTURE_DEVS[i]->active_channel == htim->Channel))
 8005df4:	7a39      	ldrb	r1, [r7, #8]
 8005df6:	7e2a      	ldrb	r2, [r5, #24]
 8005df8:	4291      	cmp	r1, r2
 8005dfa:	d15b      	bne.n	8005eb4 <HAL_TIM_IC_CaptureCallback+0xe4>
		{
			channel = INPUT_CAPTURE_DEVS[i]->channel;
 8005dfc:	687c      	ldr	r4, [r7, #4]
			if (INPUT_CAPTURE_DEVS[i]->start == 0)
 8005dfe:	68fb      	ldr	r3, [r7, #12]
			{
				// Capture started.
				INPUT_CAPTURE_DEVS[i]->start = HAL_TIM_ReadCapturedValue(htim,
 8005e00:	4621      	mov	r1, r4
 8005e02:	4628      	mov	r0, r5
			if (INPUT_CAPTURE_DEVS[i]->start == 0)
 8005e04:	bb7b      	cbnz	r3, 8005e66 <HAL_TIM_IC_CaptureCallback+0x96>
				INPUT_CAPTURE_DEVS[i]->start = HAL_TIM_ReadCapturedValue(htim,
 8005e06:	f7fd fb3b 	bl	8003480 <HAL_TIM_ReadCapturedValue>
 8005e0a:	682b      	ldr	r3, [r5, #0]
 8005e0c:	60f8      	str	r0, [r7, #12]
						channel);
				// Ready to capture falling edge.
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
 8005e0e:	6a1a      	ldr	r2, [r3, #32]
 8005e10:	b954      	cbnz	r4, 8005e28 <HAL_TIM_IC_CaptureCallback+0x58>
 8005e12:	f022 020a 	bic.w	r2, r2, #10
 8005e16:	0412      	lsls	r2, r2, #16
 8005e18:	0c12      	lsrs	r2, r2, #16
 8005e1a:	621a      	str	r2, [r3, #32]
				TIM_SET_CAPTUREPOLARITY(htim, channel, TIM_ICPOLARITY_FALLING);
 8005e1c:	6a1a      	ldr	r2, [r3, #32]
 8005e1e:	f042 0202 	orr.w	r2, r2, #2
							- INPUT_CAPTURE_DEVS[i]->start;
				}
				INPUT_CAPTURE_DEVS[i]->start = 0;
				// Prepare for next capture.
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
				TIM_SET_CAPTUREPOLARITY(htim, channel, TIM_ICPOLARITY_RISING);
 8005e22:	621a      	str	r2, [r3, #32]
 8005e24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
 8005e28:	2c04      	cmp	r4, #4
 8005e2a:	d108      	bne.n	8005e3e <HAL_TIM_IC_CaptureCallback+0x6e>
 8005e2c:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8005e30:	0412      	lsls	r2, r2, #16
 8005e32:	0c12      	lsrs	r2, r2, #16
 8005e34:	621a      	str	r2, [r3, #32]
				TIM_SET_CAPTUREPOLARITY(htim, channel, TIM_ICPOLARITY_FALLING);
 8005e36:	6a1a      	ldr	r2, [r3, #32]
 8005e38:	f042 0220 	orr.w	r2, r2, #32
 8005e3c:	e7f1      	b.n	8005e22 <HAL_TIM_IC_CaptureCallback+0x52>
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
 8005e3e:	2c08      	cmp	r4, #8
 8005e40:	d108      	bne.n	8005e54 <HAL_TIM_IC_CaptureCallback+0x84>
 8005e42:	f422 6220 	bic.w	r2, r2, #2560	; 0xa00
 8005e46:	0412      	lsls	r2, r2, #16
 8005e48:	0c12      	lsrs	r2, r2, #16
 8005e4a:	621a      	str	r2, [r3, #32]
				TIM_SET_CAPTUREPOLARITY(htim, channel, TIM_ICPOLARITY_FALLING);
 8005e4c:	6a1a      	ldr	r2, [r3, #32]
 8005e4e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8005e52:	e7e6      	b.n	8005e22 <HAL_TIM_IC_CaptureCallback+0x52>
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
 8005e54:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8005e58:	0412      	lsls	r2, r2, #16
 8005e5a:	0c12      	lsrs	r2, r2, #16
 8005e5c:	621a      	str	r2, [r3, #32]
				TIM_SET_CAPTUREPOLARITY(htim, channel, TIM_ICPOLARITY_FALLING);
 8005e5e:	6a1a      	ldr	r2, [r3, #32]
 8005e60:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8005e64:	e7dd      	b.n	8005e22 <HAL_TIM_IC_CaptureCallback+0x52>
				value = HAL_TIM_ReadCapturedValue(htim, channel);
 8005e66:	f7fd fb0b 	bl	8003480 <HAL_TIM_ReadCapturedValue>
				if (value < INPUT_CAPTURE_DEVS[i]->start)
 8005e6a:	f859 2026 	ldr.w	r2, [r9, r6, lsl #2]
 8005e6e:	68d1      	ldr	r1, [r2, #12]
 8005e70:	4288      	cmp	r0, r1
							- (INPUT_CAPTURE_DEVS[i]->start - value);
 8005e72:	bf3e      	ittt	cc
 8005e74:	68eb      	ldrcc	r3, [r5, #12]
 8005e76:	1a5b      	subcc	r3, r3, r1
 8005e78:	18c0      	addcc	r0, r0, r3
				INPUT_CAPTURE_DEVS[i]->start = 0;
 8005e7a:	f04f 0300 	mov.w	r3, #0
 8005e7e:	60d3      	str	r3, [r2, #12]
							- INPUT_CAPTURE_DEVS[i]->start;
 8005e80:	bf28      	it	cs
 8005e82:	1a40      	subcs	r0, r0, r1
 8005e84:	f8d8 3000 	ldr.w	r3, [r8]
					INPUT_CAPTURE_DEVS[i]->value = value
 8005e88:	6110      	str	r0, [r2, #16]
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
 8005e8a:	6a1a      	ldr	r2, [r3, #32]
 8005e8c:	b934      	cbnz	r4, 8005e9c <HAL_TIM_IC_CaptureCallback+0xcc>
 8005e8e:	f022 020a 	bic.w	r2, r2, #10
 8005e92:	0412      	lsls	r2, r2, #16
 8005e94:	0c12      	lsrs	r2, r2, #16
 8005e96:	621a      	str	r2, [r3, #32]
				TIM_SET_CAPTUREPOLARITY(htim, channel, TIM_ICPOLARITY_RISING);
 8005e98:	6a1a      	ldr	r2, [r3, #32]
 8005e9a:	e7c2      	b.n	8005e22 <HAL_TIM_IC_CaptureCallback+0x52>
				TIM_RESET_CAPTUREPOLARITY(htim, channel);
 8005e9c:	2c04      	cmp	r4, #4
 8005e9e:	d102      	bne.n	8005ea6 <HAL_TIM_IC_CaptureCallback+0xd6>
 8005ea0:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8005ea4:	e7f5      	b.n	8005e92 <HAL_TIM_IC_CaptureCallback+0xc2>
 8005ea6:	2c08      	cmp	r4, #8
 8005ea8:	bf0c      	ite	eq
 8005eaa:	f422 6220 	biceq.w	r2, r2, #2560	; 0xa00
 8005eae:	f422 5200 	bicne.w	r2, r2, #8192	; 0x2000
 8005eb2:	e7ee      	b.n	8005e92 <HAL_TIM_IC_CaptureCallback+0xc2>
	for (i = 0; i < N_INPUT_CAPTURE_DEVS; i++)
 8005eb4:	3601      	adds	r6, #1
 8005eb6:	e793      	b.n	8005de0 <HAL_TIM_IC_CaptureCallback+0x10>
 8005eb8:	080066f8 	.word	0x080066f8
 8005ebc:	20000028 	.word	0x20000028

08005ec0 <pwmSetDutyCycle>:
	}
}

static inline void pwmSetDutyCycle(const PWMDev * dev, float duty_cycle)
{
	uint16_t value = duty_cycle * __HAL_TIM_GET_AUTORELOAD(dev->tim);
 8005ec0:	6803      	ldr	r3, [r0, #0]
 8005ec2:	681a      	ldr	r2, [r3, #0]
 8005ec4:	edd2 7a0b 	vldr	s15, [r2, #44]	; 0x2c
	value = value > __HAL_TIM_GET_AUTORELOAD(dev->tim) ? __HAL_TIM_GET_AUTORELOAD(dev->tim) : value;
 8005ec8:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
	uint16_t value = duty_cycle * __HAL_TIM_GET_AUTORELOAD(dev->tim);
 8005eca:	eef8 7a67 	vcvt.f32.u32	s15, s15
{
 8005ece:	b082      	sub	sp, #8
	uint16_t value = duty_cycle * __HAL_TIM_GET_AUTORELOAD(dev->tim);
 8005ed0:	ee27 0a80 	vmul.f32	s0, s15, s0
	__HAL_TIM_SET_COMPARE(dev->tim, dev->channel, value);
 8005ed4:	3234      	adds	r2, #52	; 0x34
	uint16_t value = duty_cycle * __HAL_TIM_GET_AUTORELOAD(dev->tim);
 8005ed6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8005eda:	edcd 7a01 	vstr	s15, [sp, #4]
 8005ede:	f8bd 3004 	ldrh.w	r3, [sp, #4]
	value = value > __HAL_TIM_GET_AUTORELOAD(dev->tim) ? __HAL_TIM_GET_AUTORELOAD(dev->tim) : value;
 8005ee2:	428b      	cmp	r3, r1
	__HAL_TIM_SET_COMPARE(dev->tim, dev->channel, value);
 8005ee4:	6841      	ldr	r1, [r0, #4]
	value = value > __HAL_TIM_GET_AUTORELOAD(dev->tim) ? __HAL_TIM_GET_AUTORELOAD(dev->tim) : value;
 8005ee6:	bf88      	it	hi
 8005ee8:	f852 3c08 	ldrhi.w	r3, [r2, #-8]
	__HAL_TIM_SET_COMPARE(dev->tim, dev->channel, value);
 8005eec:	ea4f 0191 	mov.w	r1, r1, lsr #2
	value = value > __HAL_TIM_GET_AUTORELOAD(dev->tim) ? __HAL_TIM_GET_AUTORELOAD(dev->tim) : value;
 8005ef0:	bf88      	it	hi
 8005ef2:	b29b      	uxthhi	r3, r3
	__HAL_TIM_SET_COMPARE(dev->tim, dev->channel, value);
 8005ef4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8005ef8:	b002      	add	sp, #8
 8005efa:	4770      	bx	lr

08005efc <msgWheelCallback>:
	float limit;
} PID;

static inline void pidSetPoint(PID * pid, float setpoint)
{
	pid->setpoint = setpoint;
 8005efc:	4b04      	ldr	r3, [pc, #16]	; (8005f10 <msgWheelCallback+0x14>)
{
	MsgWheel * wheel = (MsgWheel*) payload;
	int i;
	for (i = 0; i < N_WHEELS; i++)
	{
		pidSetPoint(&wheels_pid[i], wheel->data[i]);
 8005efe:	6802      	ldr	r2, [r0, #0]
 8005f00:	601a      	str	r2, [r3, #0]
 8005f02:	6842      	ldr	r2, [r0, #4]
 8005f04:	629a      	str	r2, [r3, #40]	; 0x28
 8005f06:	6882      	ldr	r2, [r0, #8]
 8005f08:	651a      	str	r2, [r3, #80]	; 0x50
 8005f0a:	68c2      	ldr	r2, [r0, #12]
 8005f0c:	679a      	str	r2, [r3, #120]	; 0x78
 8005f0e:	4770      	bx	lr
 8005f10:	20003f94 	.word	0x20003f94

08005f14 <msgTwistCallback>:
	static float speed[4] =
	{ 0 };

	MsgTwist * twist = (MsgTwist*) payload;

	speed[0] = twist->linear_x - twist->linear_y - twist->angular_z * ab;
 8005f14:	6803      	ldr	r3, [r0, #0]
 8005f16:	ee07 3a90 	vmov	s15, r3
 8005f1a:	6843      	ldr	r3, [r0, #4]
 8005f1c:	ee05 3a90 	vmov	s11, r3
 8005f20:	6883      	ldr	r3, [r0, #8]
 8005f22:	ee37 7ae5 	vsub.f32	s14, s15, s11
 8005f26:	ee06 3a10 	vmov	s12, r3
	speed[1] = twist->linear_x + twist->linear_y + twist->angular_z * ab;
 8005f2a:	ee77 7aa5 	vadd.f32	s15, s15, s11
	speed[0] = twist->linear_x - twist->linear_y - twist->angular_z * ab;
 8005f2e:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 8005f32:	eef1 4a46 	vneg.f32	s9, s12
 8005f36:	eeb0 5a47 	vmov.f32	s10, s14
	speed[1] = twist->linear_x + twist->linear_y + twist->angular_z * ab;
 8005f3a:	eef0 5a67 	vmov.f32	s11, s15
	speed[0] = twist->linear_x - twist->linear_y - twist->angular_z * ab;
 8005f3e:	eea4 5aa6 	vfma.f32	s10, s9, s13
 8005f42:	4b0c      	ldr	r3, [pc, #48]	; (8005f74 <msgTwistCallback+0x60>)
	speed[1] = twist->linear_x + twist->linear_y + twist->angular_z * ab;
 8005f44:	eee6 5a26 	vfma.f32	s11, s12, s13
	speed[2] = twist->linear_x - twist->linear_y + twist->angular_z * ab;
 8005f48:	eea6 7a26 	vfma.f32	s14, s12, s13
	speed[3] = twist->linear_x + twist->linear_y - twist->angular_z * ab;
 8005f4c:	eee4 7aa6 	vfma.f32	s15, s9, s13
	speed[0] = twist->linear_x - twist->linear_y - twist->angular_z * ab;
 8005f50:	ed83 5a00 	vstr	s10, [r3]
	speed[1] = twist->linear_x + twist->linear_y + twist->angular_z * ab;
 8005f54:	edc3 5a01 	vstr	s11, [r3, #4]
	speed[2] = twist->linear_x - twist->linear_y + twist->angular_z * ab;
 8005f58:	ed83 7a02 	vstr	s14, [r3, #8]
	speed[3] = twist->linear_x + twist->linear_y - twist->angular_z * ab;
 8005f5c:	edc3 7a03 	vstr	s15, [r3, #12]
 8005f60:	4b05      	ldr	r3, [pc, #20]	; (8005f78 <msgTwistCallback+0x64>)
 8005f62:	ed83 5a00 	vstr	s10, [r3]
 8005f66:	edc3 5a0a 	vstr	s11, [r3, #40]	; 0x28
 8005f6a:	ed83 7a14 	vstr	s14, [r3, #80]	; 0x50
 8005f6e:	edc3 7a1e 	vstr	s15, [r3, #120]	; 0x78
 8005f72:	4770      	bx	lr
 8005f74:	20003f84 	.word	0x20003f84
 8005f78:	20003f94 	.word	0x20003f94

08005f7c <wheelsThread>:

	wheels_thread = osThreadCreate(osThread(wheels_thread), NULL);
}

void wheelsThread(void const * arg)
{
 8005f7c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f80:	ed2d 8b02 	vpush	{d8}

	int i = 0;
	uint32_t last_tick = 0, tick = 0;
	float delta_time;

	osThreadSetPriority(osThreadGetId(), osPriorityNormal);
 8005f84:	f7fe fa8c 	bl	80044a0 <osThreadGetId>
 8005f88:	2100      	movs	r1, #0
 8005f8a:	f7fe fa8b 	bl	80044a4 <osThreadSetPriority>

	while (true)
	{
		osDelay(25);
		tick = osKernelSysTick();
		delta_time = ((float) (tick - last_tick)) / osKernelSysTickFrequency;
 8005f8e:	eddf 8a5c 	vldr	s17, [pc, #368]	; 8006100 <wheelsThread+0x184>

		// Wheel control.
		for (i = 0; i < N_WHEELS; i++)
		{
			pidSetInput(&wheels_pid[i],
					wheelGetSpeed(WHEEL_DEVS[i], delta_time));
 8005f92:	f8df 8178 	ldr.w	r8, [pc, #376]	; 800610c <wheelsThread+0x190>
	uint32_t last_tick = 0, tick = 0;
 8005f96:	2400      	movs	r4, #0
			pidUpdate(&wheels_pid[i]);

			wheelSetOutput(WHEEL_DEVS[i], pidGetOutput(&wheels_pid[i]));

			// Suspend motor.
			if (pidGetPoint(&wheels_pid[i]) == 0.0
 8005f98:	f04f 0b00 	mov.w	fp, #0
		osDelay(25);
 8005f9c:	2019      	movs	r0, #25
 8005f9e:	f7fe fa8a 	bl	80044b6 <osDelay>
		tick = osKernelSysTick();
 8005fa2:	f7fe fa5e 	bl	8004462 <osKernelSysTick>
		delta_time = ((float) (tick - last_tick)) / osKernelSysTickFrequency;
 8005fa6:	1b04      	subs	r4, r0, r4
 8005fa8:	ee07 4a90 	vmov	s15, r4
 8005fac:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005fb0:	4c54      	ldr	r4, [pc, #336]	; (8006104 <wheelsThread+0x188>)
 8005fb2:	ee87 8aa8 	vdiv.f32	s16, s15, s17
		for (i = 0; i < N_WHEELS; i++)
 8005fb6:	2600      	movs	r6, #0
		tick = osKernelSysTick();
 8005fb8:	4607      	mov	r7, r0
 8005fba:	46a2      	mov	sl, r4

static inline int16_t encoderGetCounter(const EncoderDev * dev)
{
	int16_t ret = 0;
	ret = __HAL_TIM_GET_COUNTER(dev->tim);
	__HAL_TIM_SET_COUNTER(dev->tim, 0);
 8005fbc:	46b1      	mov	r9, r6
					wheelGetSpeed(WHEEL_DEVS[i], delta_time));
 8005fbe:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
	ret = __HAL_TIM_GET_COUNTER(dev->tim);
 8005fc2:	686b      	ldr	r3, [r5, #4]
 8005fc4:	681b      	ldr	r3, [r3, #0]
 8005fc6:	681a      	ldr	r2, [r3, #0]
 8005fc8:	6a53      	ldr	r3, [r2, #36]	; 0x24
		gpioWrite(dev->dire_n, true);
	}
}

static inline float wheelGetSpeed(const WheelDev * dev, float detla_time) {
	return (dev->circumference * encoderGetCounter(dev->encoder))
 8005fca:	ed95 7a04 	vldr	s14, [r5, #16]
			/ (dev->pulse_per_round * detla_time);
 8005fce:	edd5 6a05 	vldr	s13, [r5, #20]
	__HAL_TIM_SET_COUNTER(dev->tim, 0);
 8005fd2:	f8c2 9024 	str.w	r9, [r2, #36]	; 0x24
	return (dev->circumference * encoderGetCounter(dev->encoder))
 8005fd6:	b21b      	sxth	r3, r3
 8005fd8:	ee07 3a90 	vmov	s15, r3
 8005fdc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			/ (dev->pulse_per_round * detla_time);
 8005fe0:	ee68 6a26 	vmul.f32	s13, s16, s13
	return (dev->circumference * encoderGetCounter(dev->encoder))
 8005fe4:	ee67 7a87 	vmul.f32	s15, s15, s14

static inline void pidUpdate(PID * pid)
{
	pid->errors[2] = pid->errors[1];
	pid->errors[1] = pid->errors[0];
	pid->errors[0] = pid->setpoint - pid->input;
 8005fe8:	ed94 7a00 	vldr	s14, [r4]
	float p = pid->Kp * (pid->errors[0] - pid->errors[1]);
	float i = pid->Ki * pid->errors[0];
	float d = pid->Kd
			* (pid->errors[0] - (2 * pid->errors[1]) + pid->errors[2]);
	pid->output += p + i + d;
 8005fec:	ed94 5a03 	vldr	s10, [r4, #12]
	pid->errors[2] = pid->errors[1];
 8005ff0:	ed94 6a07 	vldr	s12, [r4, #28]

	pid->output = pid->output < -pid->limit ? -pid->limit : pid->output;
 8005ff4:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
	pid->errors[2] = pid->errors[1];
 8005ff8:	ed84 6a08 	vstr	s12, [r4, #32]
			/ (dev->pulse_per_round * detla_time);
 8005ffc:	eec7 5aa6 	vdiv.f32	s11, s15, s13
	pid->errors[1] = pid->errors[0];
 8006000:	edd4 6a06 	vldr	s13, [r4, #24]
	float i = pid->Ki * pid->errors[0];
 8006004:	edd4 7a04 	vldr	s15, [r4, #16]
	pid->input = input;
 8006008:	edc4 5a01 	vstr	s11, [r4, #4]
	pid->errors[0] = pid->setpoint - pid->input;
 800600c:	ee37 7a65 	vsub.f32	s14, s14, s11
	pid->errors[1] = pid->errors[0];
 8006010:	edc4 6a07 	vstr	s13, [r4, #28]
	float p = pid->Kp * (pid->errors[0] - pid->errors[1]);
 8006014:	ee77 5a66 	vsub.f32	s11, s14, s13
	float i = pid->Ki * pid->errors[0];
 8006018:	ee67 7a27 	vmul.f32	s15, s14, s15
	pid->errors[0] = pid->setpoint - pid->input;
 800601c:	ed84 7a06 	vstr	s14, [r4, #24]
	pid->output += p + i + d;
 8006020:	eee5 7a25 	vfma.f32	s15, s10, s11
			* (pid->errors[0] - (2 * pid->errors[1]) + pid->errors[2]);
 8006024:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 8006028:	eea6 7ae5 	vfms.f32	s14, s13, s11
	pid->output += p + i + d;
 800602c:	edd4 6a05 	vldr	s13, [r4, #20]
			* (pid->errors[0] - (2 * pid->errors[1]) + pid->errors[2]);
 8006030:	ee37 7a06 	vadd.f32	s14, s14, s12
	pid->output += p + i + d;
 8006034:	eee6 7a87 	vfma.f32	s15, s13, s14
 8006038:	ed94 7a02 	vldr	s14, [r4, #8]
 800603c:	ee77 7a87 	vadd.f32	s15, s15, s14
	pid->output = pid->output < -pid->limit ? -pid->limit : pid->output;
 8006040:	eeb1 7a40 	vneg.f32	s14, s0
 8006044:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006048:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800604c:	bf58      	it	pl
 800604e:	eeb0 7a67 	vmovpl.f32	s14, s15
	pid->output = pid->limit < pid->output ? pid->limit : pid->output;
 8006052:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8006056:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800605a:	bf58      	it	pl
 800605c:	eeb0 0a47 	vmovpl.f32	s0, s14
	if (output > 0.0) {
 8006060:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8006064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006068:	ed84 0a02 	vstr	s0, [r4, #8]
 800606c:	dd39      	ble.n	80060e2 <wheelsThread+0x166>
		pwmSetDutyCycle(dev->pwm, output);
 800606e:	6828      	ldr	r0, [r5, #0]
 8006070:	f7ff ff26 	bl	8005ec0 <pwmSetDutyCycle>
		gpioWrite(dev->dire_p, true);
 8006074:	68ab      	ldr	r3, [r5, #8]
}

static inline void gpioWrite(const GPIODev * dev, bool state)
{
	HAL_GPIO_WritePin(dev->port, dev->pin,
 8006076:	2201      	movs	r2, #1
 8006078:	8899      	ldrh	r1, [r3, #4]
 800607a:	6818      	ldr	r0, [r3, #0]
 800607c:	f7fc f854 	bl	8002128 <HAL_GPIO_WritePin>
		gpioWrite(dev->dire_n, false);
 8006080:	68eb      	ldr	r3, [r5, #12]
 8006082:	2200      	movs	r2, #0
 8006084:	8899      	ldrh	r1, [r3, #4]
 8006086:	6818      	ldr	r0, [r3, #0]
 8006088:	f7fc f84e 	bl	8002128 <HAL_GPIO_WritePin>
			if (pidGetPoint(&wheels_pid[i]) == 0.0
 800608c:	edd4 7a00 	vldr	s15, [r4]
 8006090:	eef5 7a40 	vcmp.f32	s15, #0.0
 8006094:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006098:	d108      	bne.n	80060ac <wheelsThread+0x130>
					&& pidGetInput(&wheels_pid[i]) == 0.0)
 800609a:	edd4 7a01 	vldr	s15, [r4, #4]
 800609e:	eef5 7a40 	vcmp.f32	s15, #0.0
 80060a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	pid->output = output;
 80060a6:	bf08      	it	eq
 80060a8:	f8c4 b008 	streq.w	fp, [r4, #8]
		for (i = 0; i < N_WHEELS; i++)
 80060ac:	3601      	adds	r6, #1
 80060ae:	2e04      	cmp	r6, #4
 80060b0:	f104 0428 	add.w	r4, r4, #40	; 0x28
 80060b4:	d183      	bne.n	8005fbe <wheelsThread+0x42>
				pidSetOutput(&wheels_pid[i], 0.0);
			}
		}

		// Speed feedback.
		encoder.duration = delta_time;
 80060b6:	4914      	ldr	r1, [pc, #80]	; (8006108 <wheelsThread+0x18c>)
 80060b8:	ee18 3a10 	vmov	r3, s16
 80060bc:	600b      	str	r3, [r1, #0]
		for (i = 0; i < N_WHEELS; i++)
		{
			encoder.data[i] = pidGetInput(&wheels_pid[i]);
 80060be:	f8da 3004 	ldr.w	r3, [sl, #4]
 80060c2:	604b      	str	r3, [r1, #4]
 80060c4:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
 80060c8:	608b      	str	r3, [r1, #8]
 80060ca:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
 80060ce:	60cb      	str	r3, [r1, #12]
		}
		msgSend(MSG_TOPIC_ENCODER, &encoder, sizeof(encoder));
 80060d0:	2214      	movs	r2, #20
			encoder.data[i] = pidGetInput(&wheels_pid[i]);
 80060d2:	f8da 307c 	ldr.w	r3, [sl, #124]	; 0x7c
 80060d6:	610b      	str	r3, [r1, #16]
		msgSend(MSG_TOPIC_ENCODER, &encoder, sizeof(encoder));
 80060d8:	4630      	mov	r0, r6
 80060da:	f000 f935 	bl	8006348 <msgSend>
		last_tick = tick;
 80060de:	463c      	mov	r4, r7
		osDelay(25);
 80060e0:	e75c      	b.n	8005f9c <wheelsThread+0x20>
		pwmSetDutyCycle(dev->pwm, -output);
 80060e2:	eeb1 0a40 	vneg.f32	s0, s0
 80060e6:	6828      	ldr	r0, [r5, #0]
 80060e8:	f7ff feea 	bl	8005ec0 <pwmSetDutyCycle>
		gpioWrite(dev->dire_p, false);
 80060ec:	68ab      	ldr	r3, [r5, #8]
 80060ee:	2200      	movs	r2, #0
 80060f0:	8899      	ldrh	r1, [r3, #4]
 80060f2:	6818      	ldr	r0, [r3, #0]
 80060f4:	f7fc f818 	bl	8002128 <HAL_GPIO_WritePin>
		gpioWrite(dev->dire_n, true);
 80060f8:	68eb      	ldr	r3, [r5, #12]
 80060fa:	2201      	movs	r2, #1
 80060fc:	e7c2      	b.n	8006084 <wheelsThread+0x108>
 80060fe:	bf00      	nop
 8006100:	447a0000 	.word	0x447a0000
 8006104:	20003f94 	.word	0x20003f94
 8006108:	20003f70 	.word	0x20003f70
 800610c:	20000058 	.word	0x20000058

08006110 <motionTasksInit>:
{
 8006110:	b508      	push	{r3, lr}
	msgSetCallback(MSG_TOPIC_WHEEL, msgWheelCallback);
 8006112:	4907      	ldr	r1, [pc, #28]	; (8006130 <motionTasksInit+0x20>)
 8006114:	2003      	movs	r0, #3
 8006116:	f000 f90f 	bl	8006338 <msgSetCallback>
	msgSetCallback(MSG_TOPIC_TWIST, msgTwistCallback);
 800611a:	4906      	ldr	r1, [pc, #24]	; (8006134 <motionTasksInit+0x24>)
 800611c:	2008      	movs	r0, #8
 800611e:	f000 f90b 	bl	8006338 <msgSetCallback>
	wheels_thread = osThreadCreate(osThread(wheels_thread), NULL);
 8006122:	2100      	movs	r1, #0
 8006124:	4804      	ldr	r0, [pc, #16]	; (8006138 <motionTasksInit+0x28>)
 8006126:	f7fe f9a3 	bl	8004470 <osThreadCreate>
 800612a:	4b04      	ldr	r3, [pc, #16]	; (800613c <motionTasksInit+0x2c>)
 800612c:	6018      	str	r0, [r3, #0]
 800612e:	bd08      	pop	{r3, pc}
 8006130:	08005efd 	.word	0x08005efd
 8006134:	08005f15 	.word	0x08005f15
 8006138:	08006b00 	.word	0x08006b00
 800613c:	20004e8c 	.word	0x20004e8c

08006140 <uartIDLECallback>:
	}
}

void uartIDLECallback(const UARTDev * dev)
{
	osSemaphoreRelease(uart_rx_semap);
 8006140:	4b01      	ldr	r3, [pc, #4]	; (8006148 <uartIDLECallback+0x8>)
 8006142:	6818      	ldr	r0, [r3, #0]
 8006144:	f7fe b9fa 	b.w	800453c <osSemaphoreRelease>
 8006148:	20004e94 	.word	0x20004e94

0800614c <uartTCCallback>:
}

void uartTCCallback(const UARTDev * dev)
{
	osSemaphoreRelease(uart_tx_semap);
 800614c:	4b01      	ldr	r3, [pc, #4]	; (8006154 <uartTCCallback+0x8>)
 800614e:	6818      	ldr	r0, [r3, #0]
 8006150:	f7fe b9f4 	b.w	800453c <osSemaphoreRelease>
 8006154:	20004e90 	.word	0x20004e90

08006158 <uartRecvThread>:
{
 8006158:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uart->idle_callback = uartIDLECallback;
 800615c:	4e58      	ldr	r6, [pc, #352]	; (80062c0 <uartRecvThread+0x168>)
 800615e:	4b59      	ldr	r3, [pc, #356]	; (80062c4 <uartRecvThread+0x16c>)
} RingBuffer;

static inline void ringBufferInit(RingBuffer * buffer, uint8_t * data,
                                  size_t total, size_t reserved)
{
    buffer->data = data;
 8006160:	4c59      	ldr	r4, [pc, #356]	; (80062c8 <uartRecvThread+0x170>)
 8006162:	60f3      	str	r3, [r6, #12]
	osThreadSetPriority(osThreadGetId(), osPriorityRealtime);
 8006164:	f7fe f99c 	bl	80044a0 <osThreadGetId>
 8006168:	2103      	movs	r1, #3
 800616a:	f7fe f99b 	bl	80044a4 <osThreadSetPriority>
    buffer->capacity = total - reserved;
    buffer->reserved = reserved;
 800616e:	2332      	movs	r3, #50	; 0x32
    buffer->data = data;
 8006170:	4956      	ldr	r1, [pc, #344]	; (80062cc <uartRecvThread+0x174>)
    buffer->reserved = reserved;
 8006172:	60a3      	str	r3, [r4, #8]
    buffer->capacity = total - reserved;
 8006174:	f44f 7200 	mov.w	r2, #512	; 0x200
    buffer->head_index = 0;
 8006178:	2300      	movs	r3, #0
	uartRecvStart(uart, ringBufferData(&buffer), ringBufferCapacity(&buffer));
 800617a:	4630      	mov	r0, r6
 800617c:	60e3      	str	r3, [r4, #12]
    buffer->data = data;
 800617e:	6021      	str	r1, [r4, #0]
    buffer->capacity = total - reserved;
 8006180:	6062      	str	r2, [r4, #4]
    buffer->tail_index = 0;
 8006182:	6123      	str	r3, [r4, #16]
 8006184:	f000 f9c8 	bl	8006518 <uartRecvStart>
				osSemaphoreWait(uart_rx_semap, 1);
 8006188:	4f51      	ldr	r7, [pc, #324]	; (80062d0 <uartRecvThread+0x178>)
	int index;

	while (len--)
	{
        index = ((crc >> 8) ^ *data) % 256;
		crc = CRC_CCITT_TABLE[index] ^ (crc << 8);
 800618a:	f8df 8150 	ldr.w	r8, [pc, #336]	; 80062dc <uartRecvThread+0x184>
 800618e:	6832      	ldr	r2, [r6, #0]

bool uartSendAsync(const UARTDev * dev, uint8_t * buffer, size_t len);

static inline size_t uartRecvIndex(const UARTDev * dev)
{
	return dev->uart->RxXferSize - __HAL_DMA_GET_COUNTER(dev->uart->hdmarx);
 8006190:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8006192:	681b      	ldr	r3, [r3, #0]
 8006194:	6859      	ldr	r1, [r3, #4]
 8006196:	8d93      	ldrh	r3, [r2, #44]	; 0x2c
 8006198:	1a5b      	subs	r3, r3, r1
    buffer->head_index = index;
}

static inline void ringBufferSetTailIndex(RingBuffer * buffer, size_t index)
{
    buffer->tail_index = index;
 800619a:	6123      	str	r3, [r4, #16]
    return (buffer->tail_index >= buffer->head_index) ?
 800619c:	6922      	ldr	r2, [r4, #16]
 800619e:	68e3      	ldr	r3, [r4, #12]
           (buffer->tail_index - buffer->head_index) :
 80061a0:	429a      	cmp	r2, r3
 80061a2:	bf38      	it	cc
 80061a4:	6861      	ldrcc	r1, [r4, #4]
 80061a6:	6923      	ldr	r3, [r4, #16]
 80061a8:	68e2      	ldr	r2, [r4, #12]
 80061aa:	bf38      	it	cc
 80061ac:	185b      	addcc	r3, r3, r1
 80061ae:	1a9b      	subs	r3, r3, r2
			if (ringBufferSize(&buffer) >= sizeof(MsgHeader))
 80061b0:	2b03      	cmp	r3, #3
 80061b2:	d804      	bhi.n	80061be <uartRecvThread+0x66>
				osSemaphoreWait(uart_rx_semap, 1);
 80061b4:	2101      	movs	r1, #1
 80061b6:	6838      	ldr	r0, [r7, #0]
 80061b8:	f7fe f998 	bl	80044ec <osSemaphoreWait>
			ringBufferSetTailIndex(&buffer, uartRecvIndex(uart));
 80061bc:	e7e7      	b.n	800618e <uartRecvThread+0x36>
    if ((buffer->head_index + len) > buffer->capacity)
 80061be:	68e3      	ldr	r3, [r4, #12]
 80061c0:	6860      	ldr	r0, [r4, #4]
 80061c2:	3304      	adds	r3, #4
 80061c4:	4283      	cmp	r3, r0
 80061c6:	d906      	bls.n	80061d6 <uartRecvThread+0x7e>
               (buffer->head_index + len) - buffer->capacity);
 80061c8:	68e2      	ldr	r2, [r4, #12]
        memcpy(buffer->data + buffer->capacity, buffer->data,
 80061ca:	6821      	ldr	r1, [r4, #0]
               (buffer->head_index + len) - buffer->capacity);
 80061cc:	3204      	adds	r2, #4
        memcpy(buffer->data + buffer->capacity, buffer->data,
 80061ce:	1a12      	subs	r2, r2, r0
 80061d0:	4408      	add	r0, r1
 80061d2:	f000 fa45 	bl	8006660 <memcpy>
    return buffer->data + buffer->head_index;
 80061d6:	68e3      	ldr	r3, [r4, #12]
 80061d8:	6821      	ldr	r1, [r4, #0]
 80061da:	18ca      	adds	r2, r1, r3
		if ((ptr->start != START_SIGN)
 80061dc:	5ccb      	ldrb	r3, [r1, r3]
 80061de:	2b0a      	cmp	r3, #10
 80061e0:	d107      	bne.n	80061f2 <uartRecvThread+0x9a>
				|| ((ptr->start ^ ptr->channel ^ ptr->length) != ptr->checksum))
 80061e2:	7895      	ldrb	r5, [r2, #2]
 80061e4:	7853      	ldrb	r3, [r2, #1]
 80061e6:	78d2      	ldrb	r2, [r2, #3]
 80061e8:	406b      	eors	r3, r5
 80061ea:	f083 030a 	eor.w	r3, r3, #10
 80061ee:	429a      	cmp	r2, r3
 80061f0:	d008      	beq.n	8006204 <uartRecvThread+0xac>
    buffer->head_index = (buffer->head_index + len) % buffer->capacity;
 80061f2:	68e3      	ldr	r3, [r4, #12]
 80061f4:	6861      	ldr	r1, [r4, #4]
 80061f6:	3301      	adds	r3, #1
 80061f8:	fbb3 f2f1 	udiv	r2, r3, r1
 80061fc:	fb01 3312 	mls	r3, r1, r2, r3
 8006200:	60e3      	str	r3, [r4, #12]
			continue;
 8006202:	e7c4      	b.n	800618e <uartRecvThread+0x36>
			if (ringBufferSize(&buffer) >= HEADER_SIZE + msg_size + CHECKSUM_SIZE)
 8006204:	f105 0906 	add.w	r9, r5, #6
 8006208:	6832      	ldr	r2, [r6, #0]
 800620a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800620c:	681b      	ldr	r3, [r3, #0]
 800620e:	6859      	ldr	r1, [r3, #4]
 8006210:	8d93      	ldrh	r3, [r2, #44]	; 0x2c
 8006212:	1a5b      	subs	r3, r3, r1
    buffer->tail_index = index;
 8006214:	6123      	str	r3, [r4, #16]
    return (buffer->tail_index >= buffer->head_index) ?
 8006216:	6922      	ldr	r2, [r4, #16]
 8006218:	68e3      	ldr	r3, [r4, #12]
           (buffer->tail_index - buffer->head_index) :
 800621a:	429a      	cmp	r2, r3
 800621c:	bf38      	it	cc
 800621e:	6862      	ldrcc	r2, [r4, #4]
 8006220:	6923      	ldr	r3, [r4, #16]
 8006222:	bf2d      	iteet	cs
 8006224:	68e2      	ldrcs	r2, [r4, #12]
           (buffer->capacity - (buffer->head_index - buffer->tail_index));
 8006226:	68e1      	ldrcc	r1, [r4, #12]
           (buffer->tail_index - buffer->head_index) :
 8006228:	189b      	addcc	r3, r3, r2
 800622a:	1a9b      	subcs	r3, r3, r2
 800622c:	bf38      	it	cc
 800622e:	1a5b      	subcc	r3, r3, r1
 8006230:	4599      	cmp	r9, r3
 8006232:	d904      	bls.n	800623e <uartRecvThread+0xe6>
				osSemaphoreWait(uart_rx_semap, 1);
 8006234:	2101      	movs	r1, #1
 8006236:	6838      	ldr	r0, [r7, #0]
 8006238:	f7fe f958 	bl	80044ec <osSemaphoreWait>
			ringBufferSetTailIndex(&buffer, uartRecvIndex(uart));
 800623c:	e7e4      	b.n	8006208 <uartRecvThread+0xb0>
    if ((buffer->head_index + len) > buffer->capacity)
 800623e:	68e3      	ldr	r3, [r4, #12]
 8006240:	6860      	ldr	r0, [r4, #4]
 8006242:	442b      	add	r3, r5
 8006244:	4283      	cmp	r3, r0
 8006246:	d906      	bls.n	8006256 <uartRecvThread+0xfe>
               (buffer->head_index + len) - buffer->capacity);
 8006248:	68e2      	ldr	r2, [r4, #12]
        memcpy(buffer->data + buffer->capacity, buffer->data,
 800624a:	6821      	ldr	r1, [r4, #0]
 800624c:	1a12      	subs	r2, r2, r0
 800624e:	442a      	add	r2, r5
 8006250:	4408      	add	r0, r1
 8006252:	f000 fa05 	bl	8006660 <memcpy>
    return buffer->data + buffer->head_index;
 8006256:	68e3      	ldr	r3, [r4, #12]
 8006258:	6822      	ldr	r2, [r4, #0]
 800625a:	441a      	add	r2, r3
		checksum = crcCCITT((uint8_t *) ptr->payload, ptr->length);
 800625c:	1d10      	adds	r0, r2, #4
 800625e:	f892 c002 	ldrb.w	ip, [r2, #2]
 8006262:	4681      	mov	r9, r0
 8006264:	46e6      	mov	lr, ip
	uint_fast16_t crc = 0x1d0f;
 8006266:	f641 530f 	movw	r3, #7439	; 0x1d0f
	while (len--)
 800626a:	f11e 3eff 	adds.w	lr, lr, #4294967295
 800626e:	d21c      	bcs.n	80062aa <uartRecvThread+0x152>
		msg_checksum = *((uint16_t *) BYTE_OFFSET(ptr->payload,
 8006270:	f830 100c 	ldrh.w	r1, [r0, ip]
		if ((msg_checksum != checksum) && (msg_checksum != 0))
 8006274:	b29b      	uxth	r3, r3
 8006276:	4299      	cmp	r1, r3
 8006278:	d001      	beq.n	800627e <uartRecvThread+0x126>
 800627a:	2900      	cmp	r1, #0
 800627c:	d1b9      	bne.n	80061f2 <uartRecvThread+0x9a>
		if (CALLBACKS[ptr->channel] != NULL)
 800627e:	7852      	ldrb	r2, [r2, #1]
 8006280:	4b14      	ldr	r3, [pc, #80]	; (80062d4 <uartRecvThread+0x17c>)
 8006282:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006286:	b103      	cbz	r3, 800628a <uartRecvThread+0x132>
			CALLBACKS[ptr->channel](ptr->payload);
 8006288:	4798      	blx	r3
    buffer->head_index = (buffer->head_index + len) % buffer->capacity;
 800628a:	68e3      	ldr	r3, [r4, #12]
 800628c:	6862      	ldr	r2, [r4, #4]
 800628e:	441d      	add	r5, r3
 8006290:	fbb5 f3f2 	udiv	r3, r5, r2
 8006294:	fb02 5513 	mls	r5, r2, r3, r5
		ledToggle(LED_DEVS[1]);
 8006298:	4b0f      	ldr	r3, [pc, #60]	; (80062d8 <uartRecvThread+0x180>)
 800629a:	60e5      	str	r5, [r4, #12]
 800629c:	685b      	ldr	r3, [r3, #4]
 800629e:	681b      	ldr	r3, [r3, #0]
	HAL_GPIO_TogglePin(dev->port, dev->pin);
 80062a0:	8899      	ldrh	r1, [r3, #4]
 80062a2:	6818      	ldr	r0, [r3, #0]
 80062a4:	f7fb ff45 	bl	8002132 <HAL_GPIO_TogglePin>
 80062a8:	e771      	b.n	800618e <uartRecvThread+0x36>
        index = ((crc >> 8) ^ *data) % 256;
 80062aa:	f819 1b01 	ldrb.w	r1, [r9], #1
 80062ae:	ea81 2113 	eor.w	r1, r1, r3, lsr #8
 80062b2:	b2c9      	uxtb	r1, r1
		crc = CRC_CCITT_TABLE[index] ^ (crc << 8);
 80062b4:	f858 1021 	ldr.w	r1, [r8, r1, lsl #2]
 80062b8:	ea81 2303 	eor.w	r3, r1, r3, lsl #8
 80062bc:	e7d5      	b.n	800626a <uartRecvThread+0x112>
 80062be:	bf00      	nop
 80062c0:	20000178 	.word	0x20000178
 80062c4:	08006141 	.word	0x08006141
 80062c8:	200040e8 	.word	0x200040e8
 80062cc:	200040fc 	.word	0x200040fc
 80062d0:	20004e94 	.word	0x20004e94
 80062d4:	20004034 	.word	0x20004034
 80062d8:	20000038 	.word	0x20000038
 80062dc:	08006700 	.word	0x08006700

080062e0 <msgIOInit>:
{
 80062e0:	b508      	push	{r3, lr}
	uart_rx_semap = osSemaphoreCreate(osSemaphore(uart_rx_semap), 1);
 80062e2:	2101      	movs	r1, #1
 80062e4:	480c      	ldr	r0, [pc, #48]	; (8006318 <msgIOInit+0x38>)
 80062e6:	f7fe f8ee 	bl	80044c6 <osSemaphoreCreate>
 80062ea:	4b0c      	ldr	r3, [pc, #48]	; (800631c <msgIOInit+0x3c>)
 80062ec:	6018      	str	r0, [r3, #0]
	osSemaphoreRelease(uart_rx_semap);
 80062ee:	f7fe f925 	bl	800453c <osSemaphoreRelease>
	uart_tx_semap = osSemaphoreCreate(osSemaphore(uart_tx_semap), 1);
 80062f2:	2101      	movs	r1, #1
 80062f4:	480a      	ldr	r0, [pc, #40]	; (8006320 <msgIOInit+0x40>)
 80062f6:	f7fe f8e6 	bl	80044c6 <osSemaphoreCreate>
 80062fa:	4b0a      	ldr	r3, [pc, #40]	; (8006324 <msgIOInit+0x44>)
 80062fc:	6018      	str	r0, [r3, #0]
	osSemaphoreRelease(uart_tx_semap);
 80062fe:	f7fe f91d 	bl	800453c <osSemaphoreRelease>
	uart->tc_callback = uartTCCallback;
 8006302:	4b09      	ldr	r3, [pc, #36]	; (8006328 <msgIOInit+0x48>)
 8006304:	4a09      	ldr	r2, [pc, #36]	; (800632c <msgIOInit+0x4c>)
	uart_recv_thread = osThreadCreate(osThread(uart_recv_thread), NULL);
 8006306:	480a      	ldr	r0, [pc, #40]	; (8006330 <msgIOInit+0x50>)
	uart->tc_callback = uartTCCallback;
 8006308:	611a      	str	r2, [r3, #16]
	uart_recv_thread = osThreadCreate(osThread(uart_recv_thread), NULL);
 800630a:	2100      	movs	r1, #0
 800630c:	f7fe f8b0 	bl	8004470 <osThreadCreate>
 8006310:	4b08      	ldr	r3, [pc, #32]	; (8006334 <msgIOInit+0x54>)
 8006312:	6018      	str	r0, [r3, #0]
 8006314:	bd08      	pop	{r3, pc}
 8006316:	bf00      	nop
 8006318:	08006d04 	.word	0x08006d04
 800631c:	20004e94 	.word	0x20004e94
 8006320:	08006d08 	.word	0x08006d08
 8006324:	20004e90 	.word	0x20004e90
 8006328:	20000178 	.word	0x20000178
 800632c:	0800614d 	.word	0x0800614d
 8006330:	08006d0c 	.word	0x08006d0c
 8006334:	20004e98 	.word	0x20004e98

08006338 <msgSetCallback>:
	if (topic_id < N_CALLBACKS)
 8006338:	281f      	cmp	r0, #31
		CALLBACKS[topic_id] = callback;
 800633a:	bf9c      	itt	ls
 800633c:	4b01      	ldrls	r3, [pc, #4]	; (8006344 <msgSetCallback+0xc>)
 800633e:	f843 1020 	strls.w	r1, [r3, r0, lsl #2]
 8006342:	4770      	bx	lr
 8006344:	20004034 	.word	0x20004034

08006348 <msgSend>:
	osSemaphoreWait(uart_tx_semap, osWaitForever);
 8006348:	4b19      	ldr	r3, [pc, #100]	; (80063b0 <msgSend+0x68>)
{
 800634a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ptr->start = START_SIGN;
 800634e:	4c19      	ldr	r4, [pc, #100]	; (80063b4 <msgSend+0x6c>)
{
 8006350:	4617      	mov	r7, r2
 8006352:	4605      	mov	r5, r0
 8006354:	4688      	mov	r8, r1
	osSemaphoreWait(uart_tx_semap, osWaitForever);
 8006356:	6818      	ldr	r0, [r3, #0]
 8006358:	f04f 31ff 	mov.w	r1, #4294967295
	ptr->length = len;
 800635c:	b2fe      	uxtb	r6, r7
	osSemaphoreWait(uart_tx_semap, osWaitForever);
 800635e:	f7fe f8c5 	bl	80044ec <osSemaphoreWait>
	ptr->start = START_SIGN;
 8006362:	230a      	movs	r3, #10
	ptr->channel = topic_id;
 8006364:	7065      	strb	r5, [r4, #1]
	ptr->checksum = ptr->start ^ ptr->channel ^ ptr->length;
 8006366:	4075      	eors	r5, r6
 8006368:	405d      	eors	r5, r3
 800636a:	70e5      	strb	r5, [r4, #3]
	memcpy(ptr->payload, payload, len);
 800636c:	463a      	mov	r2, r7
 800636e:	4641      	mov	r1, r8
	ptr->start = START_SIGN;
 8006370:	7023      	strb	r3, [r4, #0]
	ptr->length = len;
 8006372:	70a6      	strb	r6, [r4, #2]
	memcpy(ptr->payload, payload, len);
 8006374:	1d20      	adds	r0, r4, #4
 8006376:	4d10      	ldr	r5, [pc, #64]	; (80063b8 <msgSend+0x70>)
 8006378:	f000 f972 	bl	8006660 <memcpy>
 800637c:	4639      	mov	r1, r7
	uint_fast16_t crc = 0x1d0f;
 800637e:	f641 520f 	movw	r2, #7439	; 0x1d0f
 8006382:	1d20      	adds	r0, r4, #4
	while (len--)
 8006384:	f111 31ff 	adds.w	r1, r1, #4294967295
 8006388:	d208      	bcs.n	800639c <msgSend+0x54>
	*((uint16_t *) BYTE_OFFSET(ptr->payload, len)) = checksum;
 800638a:	443c      	add	r4, r7
	uartSendAsync(uart, buffer, HEADER_SIZE + ptr->length + CHECKSUM_SIZE);
 800638c:	4909      	ldr	r1, [pc, #36]	; (80063b4 <msgSend+0x6c>)
		data++;
	}
	return crc;
 800638e:	80a2      	strh	r2, [r4, #4]
 8006390:	480a      	ldr	r0, [pc, #40]	; (80063bc <msgSend+0x74>)
 8006392:	1db2      	adds	r2, r6, #6
}
 8006394:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	uartSendAsync(uart, buffer, HEADER_SIZE + ptr->length + CHECKSUM_SIZE);
 8006398:	f000 b8cc 	b.w	8006534 <uartSendAsync>
        index = ((crc >> 8) ^ *data) % 256;
 800639c:	f810 3b01 	ldrb.w	r3, [r0], #1
 80063a0:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 80063a4:	b2db      	uxtb	r3, r3
		crc = CRC_CCITT_TABLE[index] ^ (crc << 8);
 80063a6:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80063aa:	ea83 2202 	eor.w	r2, r3, r2, lsl #8
 80063ae:	e7e9      	b.n	8006384 <msgSend+0x3c>
 80063b0:	20004e90 	.word	0x20004e90
 80063b4:	200040b4 	.word	0x200040b4
 80063b8:	08006700 	.word	0x08006700
 80063bc:	20000178 	.word	0x20000178

080063c0 <paramSetCallback>:

osThreadDef(params_thread, paramsThread, osPriorityIdle, 0, 64);
osThreadId params_thread;

void paramSetCallback(void * payload)
{
 80063c0:	b538      	push	{r3, r4, r5, lr}
	static MsgParamInfo param_info;
	MsgParam * param = payload;
	int id;
	id = param->id;

	if (param->action == MSG_PARAM_ACTION_GET)
 80063c2:	8802      	ldrh	r2, [r0, #0]
	id = param->id;
 80063c4:	8845      	ldrh	r5, [r0, #2]
 80063c6:	b2ab      	uxth	r3, r5
	if (param->action == MSG_PARAM_ACTION_GET)
 80063c8:	bb0a      	cbnz	r2, 800640e <paramSetCallback+0x4e>
	{
		if (id < N_PARAMS)
 80063ca:	2b0f      	cmp	r3, #15
 80063cc:	d84b      	bhi.n	8006466 <paramSetCallback+0xa6>
		{
			param_info.id = id;
			param_info.type = paramGetType(PARAMS[id]);
 80063ce:	4926      	ldr	r1, [pc, #152]	; (8006468 <paramSetCallback+0xa8>)
			param_info.id = id;
 80063d0:	4a26      	ldr	r2, [pc, #152]	; (800646c <paramSetCallback+0xac>)
			param_info.type = paramGetType(PARAMS[id]);
 80063d2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
			param_info.id = id;
 80063d6:	8015      	strh	r5, [r2, #0]
 80063d8:	7819      	ldrb	r1, [r3, #0]
			param_info.type = paramGetType(PARAMS[id]);
 80063da:	8051      	strh	r1, [r2, #2]
			if (PARAMS[id]->type == PARAM_INT)
 80063dc:	b989      	cbnz	r1, 8006402 <paramSetCallback+0x42>
	return *(uint32_t *) param->ptr;
}

static inline int32_t paramGetInt(const Param * param)
{
	return *(int32_t *) param->ptr;
 80063de:	6899      	ldr	r1, [r3, #8]
 80063e0:	6809      	ldr	r1, [r1, #0]
			{
				param_info.i = paramGetInt(PARAMS[id]);
 80063e2:	6051      	str	r1, [r2, #4]
			}
			else if (PARAMS[id]->type == PARAM_FLOAT)
			{
				param_info.f = paramGetFloat(PARAMS[id]);
			}
			strcpy((char *) param_info.name, paramGetName(PARAMS[id]));
 80063e4:	6859      	ldr	r1, [r3, #4]
 80063e6:	4822      	ldr	r0, [pc, #136]	; (8006470 <paramSetCallback+0xb0>)
 80063e8:	f000 f94d 	bl	8006686 <strcpy>

			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
					sizeof(param_info) - sizeof(param_info.name)
							+ strlen((char *) param_info.name) + 1);
 80063ec:	4820      	ldr	r0, [pc, #128]	; (8006470 <paramSetCallback+0xb0>)
 80063ee:	f7f9 feef 	bl	80001d0 <strlen>
			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
 80063f2:	491e      	ldr	r1, [pc, #120]	; (800646c <paramSetCallback+0xac>)
 80063f4:	f100 020d 	add.w	r2, r0, #13
			param_info.type = paramGetType(PARAMS[id]);
			param_info.i = paramGetInt(PARAMS[id]);
			param_info.f = paramGetFloat(PARAMS[id]);
			strcpy((char *) param_info.name, paramGetName(PARAMS[id]));

			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
 80063f8:	2002      	movs	r0, #2
	}
	else if (param->action == MSG_PARAM_ACTION_PULL)
	{
		osThreadResume(params_thread);
	}
}
 80063fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
 80063fe:	f7ff bfa3 	b.w	8006348 <msgSend>
			else if (PARAMS[id]->type == PARAM_FLOAT)
 8006402:	2901      	cmp	r1, #1
}

static inline float paramGetFloat(const Param * param)
{
	return *(float *) param->ptr;
 8006404:	bf02      	ittt	eq
 8006406:	6899      	ldreq	r1, [r3, #8]
				param_info.f = paramGetFloat(PARAMS[id]);
 8006408:	6809      	ldreq	r1, [r1, #0]
 800640a:	6091      	streq	r1, [r2, #8]
 800640c:	e7ea      	b.n	80063e4 <paramSetCallback+0x24>
	else if (param->action == MSG_PARAM_ACTION_SET)
 800640e:	2a01      	cmp	r2, #1
 8006410:	d121      	bne.n	8006456 <paramSetCallback+0x96>
		if (id < N_PARAMS)
 8006412:	2b0f      	cmp	r3, #15
 8006414:	d827      	bhi.n	8006466 <paramSetCallback+0xa6>
			if (PARAMS[id]->type == PARAM_INT)
 8006416:	4a14      	ldr	r2, [pc, #80]	; (8006468 <paramSetCallback+0xa8>)
 8006418:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800641c:	7819      	ldrb	r1, [r3, #0]
 800641e:	689a      	ldr	r2, [r3, #8]
 8006420:	b9a1      	cbnz	r1, 800644c <paramSetCallback+0x8c>
				paramSetInt(PARAMS[id], param->i);
 8006422:	6840      	ldr	r0, [r0, #4]
	*(int32_t *) param->ptr = value;
 8006424:	6010      	str	r0, [r2, #0]
			param_info.id = id;
 8006426:	4c11      	ldr	r4, [pc, #68]	; (800646c <paramSetCallback+0xac>)
	return *(int32_t *) param->ptr;
 8006428:	6812      	ldr	r2, [r2, #0]
			param_info.type = paramGetType(PARAMS[id]);
 800642a:	8061      	strh	r1, [r4, #2]
			strcpy((char *) param_info.name, paramGetName(PARAMS[id]));
 800642c:	f104 000c 	add.w	r0, r4, #12
 8006430:	6859      	ldr	r1, [r3, #4]
			param_info.i = paramGetInt(PARAMS[id]);
 8006432:	6062      	str	r2, [r4, #4]
			param_info.f = paramGetFloat(PARAMS[id]);
 8006434:	60a2      	str	r2, [r4, #8]
			param_info.id = id;
 8006436:	8025      	strh	r5, [r4, #0]
			strcpy((char *) param_info.name, paramGetName(PARAMS[id]));
 8006438:	f000 f925 	bl	8006686 <strcpy>
							+ strlen((char *) param_info.name) + 1);
 800643c:	f104 000c 	add.w	r0, r4, #12
 8006440:	f7f9 fec6 	bl	80001d0 <strlen>
			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
 8006444:	4621      	mov	r1, r4
 8006446:	f100 020d 	add.w	r2, r0, #13
 800644a:	e7d5      	b.n	80063f8 <paramSetCallback+0x38>
			else if (PARAMS[id]->type == PARAM_FLOAT)
 800644c:	2901      	cmp	r1, #1
				paramSetFloat(PARAMS[id], param->f);
 800644e:	bf04      	itt	eq
 8006450:	6880      	ldreq	r0, [r0, #8]
	*(float *) param->ptr = value;
 8006452:	6010      	streq	r0, [r2, #0]
 8006454:	e7e7      	b.n	8006426 <paramSetCallback+0x66>
	else if (param->action == MSG_PARAM_ACTION_PULL)
 8006456:	2a02      	cmp	r2, #2
 8006458:	d105      	bne.n	8006466 <paramSetCallback+0xa6>
		osThreadResume(params_thread);
 800645a:	4b06      	ldr	r3, [pc, #24]	; (8006474 <paramSetCallback+0xb4>)
 800645c:	6818      	ldr	r0, [r3, #0]
}
 800645e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		osThreadResume(params_thread);
 8006462:	f7fe b895 	b.w	8004590 <osThreadResume>
 8006466:	bd38      	pop	{r3, r4, r5, pc}
 8006468:	08006d34 	.word	0x08006d34
 800646c:	2000432e 	.word	0x2000432e
 8006470:	2000433a 	.word	0x2000433a
 8006474:	20004e9c 	.word	0x20004e9c

08006478 <paramsThread>:
	params_thread = osThreadCreate(osThread(params_thread), NULL);
	msgSetCallback(MSG_TOPIC_PARAM, paramSetCallback);
}

void paramsThread(void const * arg)
{
 8006478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static MsgParamInfo param_info;
	int i;

	osThreadSetPriority(osThreadGetId(), osPriorityNormal);
 800647a:	f7fe f811 	bl	80044a0 <osThreadGetId>
 800647e:	2100      	movs	r1, #0

	while (true)
	{
		for (i = 0; i < N_PARAMS; i++)
		{
			param_info.id = i;
 8006480:	4c13      	ldr	r4, [pc, #76]	; (80064d0 <paramsThread+0x58>)
			param_info.type = paramGetType(PARAMS[i]);
 8006482:	4f14      	ldr	r7, [pc, #80]	; (80064d4 <paramsThread+0x5c>)
	osThreadSetPriority(osThreadGetId(), osPriorityNormal);
 8006484:	f7fe f80e 	bl	80044a4 <osThreadSetPriority>
			param_info.i = paramGetInt(PARAMS[i]);
			param_info.f = paramGetFloat(PARAMS[i]);
			strcpy((char *) param_info.name, paramGetName(PARAMS[i]));
 8006488:	f104 060c 	add.w	r6, r4, #12
		for (i = 0; i < N_PARAMS; i++)
 800648c:	2500      	movs	r5, #0
			param_info.type = paramGetType(PARAMS[i]);
 800648e:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
			param_info.id = i;
 8006492:	8025      	strh	r5, [r4, #0]
			param_info.type = paramGetType(PARAMS[i]);
 8006494:	781a      	ldrb	r2, [r3, #0]
 8006496:	8062      	strh	r2, [r4, #2]
	return *(int32_t *) param->ptr;
 8006498:	689a      	ldr	r2, [r3, #8]
			strcpy((char *) param_info.name, paramGetName(PARAMS[i]));
 800649a:	6859      	ldr	r1, [r3, #4]
 800649c:	6812      	ldr	r2, [r2, #0]
			param_info.i = paramGetInt(PARAMS[i]);
 800649e:	6062      	str	r2, [r4, #4]
			strcpy((char *) param_info.name, paramGetName(PARAMS[i]));
 80064a0:	4630      	mov	r0, r6
			param_info.f = paramGetFloat(PARAMS[i]);
 80064a2:	60a2      	str	r2, [r4, #8]
			strcpy((char *) param_info.name, paramGetName(PARAMS[i]));
 80064a4:	f000 f8ef 	bl	8006686 <strcpy>
			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
					sizeof(param_info) - sizeof(param_info.name)
							+ strlen((char *) param_info.name) + 1);
 80064a8:	4630      	mov	r0, r6
 80064aa:	f7f9 fe91 	bl	80001d0 <strlen>
			msgSend(MSG_TOPIC_PARAM_INFO, &param_info,
 80064ae:	4908      	ldr	r1, [pc, #32]	; (80064d0 <paramsThread+0x58>)
 80064b0:	f100 020d 	add.w	r2, r0, #13
 80064b4:	2002      	movs	r0, #2
 80064b6:	f7ff ff47 	bl	8006348 <msgSend>
		for (i = 0; i < N_PARAMS; i++)
 80064ba:	3501      	adds	r5, #1
			osDelay(1);
 80064bc:	2001      	movs	r0, #1
 80064be:	f7fd fffa 	bl	80044b6 <osDelay>
		for (i = 0; i < N_PARAMS; i++)
 80064c2:	2d10      	cmp	r5, #16
 80064c4:	d1e3      	bne.n	800648e <paramsThread+0x16>
		}
		osThreadSuspend(osThreadGetId());
 80064c6:	f7fd ffeb 	bl	80044a0 <osThreadGetId>
 80064ca:	f7fe f85b 	bl	8004584 <osThreadSuspend>
		for (i = 0; i < N_PARAMS; i++)
 80064ce:	e7dd      	b.n	800648c <paramsThread+0x14>
 80064d0:	2000435a 	.word	0x2000435a
 80064d4:	08006d34 	.word	0x08006d34

080064d8 <paramsInit>:
		paramResetValue(PARAMS[i]);
 80064d8:	480b      	ldr	r0, [pc, #44]	; (8006508 <paramsInit+0x30>)
{
 80064da:	b508      	push	{r3, lr}
	for (i = 0; i < N_PARAMS; i++)
 80064dc:	2300      	movs	r3, #0
		paramResetValue(PARAMS[i]);
 80064de:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
	for (i = 0; i < N_PARAMS; i++)
 80064e2:	3301      	adds	r3, #1
	*(ParamValue *)param->ptr = param->default_value;
 80064e4:	6891      	ldr	r1, [r2, #8]
 80064e6:	68d2      	ldr	r2, [r2, #12]
 80064e8:	600a      	str	r2, [r1, #0]
 80064ea:	2b10      	cmp	r3, #16
 80064ec:	d1f7      	bne.n	80064de <paramsInit+0x6>
	params_thread = osThreadCreate(osThread(params_thread), NULL);
 80064ee:	2100      	movs	r1, #0
 80064f0:	4806      	ldr	r0, [pc, #24]	; (800650c <paramsInit+0x34>)
 80064f2:	f7fd ffbd 	bl	8004470 <osThreadCreate>
 80064f6:	4b06      	ldr	r3, [pc, #24]	; (8006510 <paramsInit+0x38>)
	msgSetCallback(MSG_TOPIC_PARAM, paramSetCallback);
 80064f8:	4906      	ldr	r1, [pc, #24]	; (8006514 <paramsInit+0x3c>)
	params_thread = osThreadCreate(osThread(params_thread), NULL);
 80064fa:	6018      	str	r0, [r3, #0]
	msgSetCallback(MSG_TOPIC_PARAM, paramSetCallback);
 80064fc:	2001      	movs	r0, #1
}
 80064fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	msgSetCallback(MSG_TOPIC_PARAM, paramSetCallback);
 8006502:	f7ff bf19 	b.w	8006338 <msgSetCallback>
 8006506:	bf00      	nop
 8006508:	08006d34 	.word	0x08006d34
 800650c:	08006d74 	.word	0x08006d74
 8006510:	20004e9c 	.word	0x20004e9c
 8006514:	080063c1 	.word	0x080063c1

08006518 <uartRecvStart>:
#include "uart.h"

bool uartRecvStart(const UARTDev * dev, uint8_t * buffer, size_t len)
{
	// Enable idle interrupt.
	__HAL_UART_ENABLE_IT(dev->uart, UART_IT_IDLE);
 8006518:	6800      	ldr	r0, [r0, #0]
{
 800651a:	b510      	push	{r4, lr}
	__HAL_UART_ENABLE_IT(dev->uart, UART_IT_IDLE);
 800651c:	6804      	ldr	r4, [r0, #0]
 800651e:	68e3      	ldr	r3, [r4, #12]
 8006520:	f043 0310 	orr.w	r3, r3, #16
 8006524:	60e3      	str	r3, [r4, #12]
	return HAL_UART_Receive_DMA(dev->uart, buffer, len) == HAL_OK;
 8006526:	b292      	uxth	r2, r2
 8006528:	f7fd fcc2 	bl	8003eb0 <HAL_UART_Receive_DMA>
}
 800652c:	fab0 f080 	clz	r0, r0
 8006530:	0940      	lsrs	r0, r0, #5
 8006532:	bd10      	pop	{r4, pc}

08006534 <uartSendAsync>:

bool uartSendAsync(const UARTDev * dev, uint8_t * buffer, size_t len)
{
 8006534:	b508      	push	{r3, lr}
	return HAL_UART_Transmit_DMA(dev->uart, buffer, len) == HAL_OK;
 8006536:	b292      	uxth	r2, r2
 8006538:	6800      	ldr	r0, [r0, #0]
 800653a:	f7fd fc7f 	bl	8003e3c <HAL_UART_Transmit_DMA>
}
 800653e:	fab0 f080 	clz	r0, r0
 8006542:	0940      	lsrs	r0, r0, #5
 8006544:	bd08      	pop	{r3, pc}
	...

08006548 <HAL_UART_ExtraIRQHandler>:

// Deal with IDEL interrupt.
// Should be called before HAL_UART_IRQHandler().
void HAL_UART_ExtraIRQHandler(UART_HandleTypeDef * huart)
{
	uint32_t it_flag_idle = __HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE);
 8006548:	6803      	ldr	r3, [r0, #0]
{
 800654a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint32_t it_flag_idle = __HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE);
 800654c:	6819      	ldr	r1, [r3, #0]
	uint32_t it_source_idle = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_IDLE);
 800654e:	68da      	ldr	r2, [r3, #12]
	if ((it_flag_idle != RESET) && (it_source_idle != RESET))
 8006550:	06c9      	lsls	r1, r1, #27
{
 8006552:	4605      	mov	r5, r0
	if ((it_flag_idle != RESET) && (it_source_idle != RESET))
 8006554:	d50d      	bpl.n	8006572 <HAL_UART_ExtraIRQHandler+0x2a>
 8006556:	06d2      	lsls	r2, r2, #27
 8006558:	d50b      	bpl.n	8006572 <HAL_UART_ExtraIRQHandler+0x2a>
	{
		size_t i = 0;
		__HAL_UART_CLEAR_IDLEFLAG(huart);
 800655a:	2400      	movs	r4, #0
 800655c:	9401      	str	r4, [sp, #4]
 800655e:	681a      	ldr	r2, [r3, #0]
 8006560:	9201      	str	r2, [sp, #4]
 8006562:	685b      	ldr	r3, [r3, #4]
 8006564:	9301      	str	r3, [sp, #4]
 8006566:	9b01      	ldr	r3, [sp, #4]
		for (i = 0; i < N_UART_DEVS; i++)
 8006568:	4b08      	ldr	r3, [pc, #32]	; (800658c <HAL_UART_ExtraIRQHandler+0x44>)
		{
			if (huart == UART_DEVS[i]->uart)
 800656a:	4f09      	ldr	r7, [pc, #36]	; (8006590 <HAL_UART_ExtraIRQHandler+0x48>)
		for (i = 0; i < N_UART_DEVS; i++)
 800656c:	681e      	ldr	r6, [r3, #0]
 800656e:	42b4      	cmp	r4, r6
 8006570:	d301      	bcc.n	8006576 <HAL_UART_ExtraIRQHandler+0x2e>
					UART_DEVS[i]->idle_callback(UART_DEVS[i]);
				}
			}
		}
	}
}
 8006572:	b003      	add	sp, #12
 8006574:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (huart == UART_DEVS[i]->uart)
 8006576:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 800657a:	6803      	ldr	r3, [r0, #0]
 800657c:	429d      	cmp	r5, r3
 800657e:	d102      	bne.n	8006586 <HAL_UART_ExtraIRQHandler+0x3e>
				if (UART_DEVS[i]->idle_callback != NULL)
 8006580:	68c3      	ldr	r3, [r0, #12]
 8006582:	b103      	cbz	r3, 8006586 <HAL_UART_ExtraIRQHandler+0x3e>
					UART_DEVS[i]->idle_callback(UART_DEVS[i]);
 8006584:	4798      	blx	r3
		for (i = 0; i < N_UART_DEVS; i++)
 8006586:	3401      	adds	r4, #1
 8006588:	e7f1      	b.n	800656e <HAL_UART_ExtraIRQHandler+0x26>
 800658a:	bf00      	nop
 800658c:	080066fc 	.word	0x080066fc
 8006590:	20000050 	.word	0x20000050

08006594 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef * huart)
{
 8006594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	size_t i = 0;
	for (i = 0; i < N_UART_DEVS; i++)
 8006596:	4b09      	ldr	r3, [pc, #36]	; (80065bc <HAL_UART_TxCpltCallback+0x28>)
	{
		if (huart == UART_DEVS[i]->uart)
 8006598:	4f09      	ldr	r7, [pc, #36]	; (80065c0 <HAL_UART_TxCpltCallback+0x2c>)
	for (i = 0; i < N_UART_DEVS; i++)
 800659a:	681d      	ldr	r5, [r3, #0]
{
 800659c:	4606      	mov	r6, r0
	for (i = 0; i < N_UART_DEVS; i++)
 800659e:	2400      	movs	r4, #0
 80065a0:	42ac      	cmp	r4, r5
 80065a2:	d300      	bcc.n	80065a6 <HAL_UART_TxCpltCallback+0x12>
			{
				UART_DEVS[i]->tc_callback(UART_DEVS[i]);
			}
		}
	}
}
 80065a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (huart == UART_DEVS[i]->uart)
 80065a6:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 80065aa:	6803      	ldr	r3, [r0, #0]
 80065ac:	42b3      	cmp	r3, r6
 80065ae:	d102      	bne.n	80065b6 <HAL_UART_TxCpltCallback+0x22>
			if (UART_DEVS[i]->tc_callback != NULL)
 80065b0:	6903      	ldr	r3, [r0, #16]
 80065b2:	b103      	cbz	r3, 80065b6 <HAL_UART_TxCpltCallback+0x22>
				UART_DEVS[i]->tc_callback(UART_DEVS[i]);
 80065b4:	4798      	blx	r3
	for (i = 0; i < N_UART_DEVS; i++)
 80065b6:	3401      	adds	r4, #1
 80065b8:	e7f2      	b.n	80065a0 <HAL_UART_TxCpltCallback+0xc>
 80065ba:	bf00      	nop
 80065bc:	080066fc 	.word	0x080066fc
 80065c0:	20000050 	.word	0x20000050

080065c4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80065c4:	f8df d034 	ldr.w	sp, [pc, #52]	; 80065fc <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80065c8:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80065ca:	e003      	b.n	80065d4 <LoopCopyDataInit>

080065cc <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80065cc:	4b0c      	ldr	r3, [pc, #48]	; (8006600 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80065ce:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80065d0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80065d2:	3104      	adds	r1, #4

080065d4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80065d4:	480b      	ldr	r0, [pc, #44]	; (8006604 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80065d6:	4b0c      	ldr	r3, [pc, #48]	; (8006608 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80065d8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80065da:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80065dc:	d3f6      	bcc.n	80065cc <CopyDataInit>
  ldr  r2, =_sbss
 80065de:	4a0b      	ldr	r2, [pc, #44]	; (800660c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80065e0:	e002      	b.n	80065e8 <LoopFillZerobss>

080065e2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80065e2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80065e4:	f842 3b04 	str.w	r3, [r2], #4

080065e8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80065e8:	4b09      	ldr	r3, [pc, #36]	; (8006610 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80065ea:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80065ec:	d3f9      	bcc.n	80065e2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80065ee:	f7fa fcb9 	bl	8000f64 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80065f2:	f000 f811 	bl	8006618 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80065f6:	f7fa fa49 	bl	8000a8c <main>
  bx  lr    
 80065fa:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 80065fc:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8006600:	08006da8 	.word	0x08006da8
  ldr  r0, =_sdata
 8006604:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8006608:	20000208 	.word	0x20000208
  ldr  r2, =_sbss
 800660c:	20000208 	.word	0x20000208
  ldr  r3, = _ebss
 8006610:	20004ea0 	.word	0x20004ea0

08006614 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8006614:	e7fe      	b.n	8006614 <ADC_IRQHandler>
	...

08006618 <__libc_init_array>:
 8006618:	b570      	push	{r4, r5, r6, lr}
 800661a:	4e0d      	ldr	r6, [pc, #52]	; (8006650 <__libc_init_array+0x38>)
 800661c:	4c0d      	ldr	r4, [pc, #52]	; (8006654 <__libc_init_array+0x3c>)
 800661e:	1ba4      	subs	r4, r4, r6
 8006620:	10a4      	asrs	r4, r4, #2
 8006622:	2500      	movs	r5, #0
 8006624:	42a5      	cmp	r5, r4
 8006626:	d109      	bne.n	800663c <__libc_init_array+0x24>
 8006628:	4e0b      	ldr	r6, [pc, #44]	; (8006658 <__libc_init_array+0x40>)
 800662a:	4c0c      	ldr	r4, [pc, #48]	; (800665c <__libc_init_array+0x44>)
 800662c:	f000 f834 	bl	8006698 <_init>
 8006630:	1ba4      	subs	r4, r4, r6
 8006632:	10a4      	asrs	r4, r4, #2
 8006634:	2500      	movs	r5, #0
 8006636:	42a5      	cmp	r5, r4
 8006638:	d105      	bne.n	8006646 <__libc_init_array+0x2e>
 800663a:	bd70      	pop	{r4, r5, r6, pc}
 800663c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006640:	4798      	blx	r3
 8006642:	3501      	adds	r5, #1
 8006644:	e7ee      	b.n	8006624 <__libc_init_array+0xc>
 8006646:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800664a:	4798      	blx	r3
 800664c:	3501      	adds	r5, #1
 800664e:	e7f2      	b.n	8006636 <__libc_init_array+0x1e>
 8006650:	08006da0 	.word	0x08006da0
 8006654:	08006da0 	.word	0x08006da0
 8006658:	08006da0 	.word	0x08006da0
 800665c:	08006da4 	.word	0x08006da4

08006660 <memcpy>:
 8006660:	b510      	push	{r4, lr}
 8006662:	1e43      	subs	r3, r0, #1
 8006664:	440a      	add	r2, r1
 8006666:	4291      	cmp	r1, r2
 8006668:	d100      	bne.n	800666c <memcpy+0xc>
 800666a:	bd10      	pop	{r4, pc}
 800666c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8006670:	f803 4f01 	strb.w	r4, [r3, #1]!
 8006674:	e7f7      	b.n	8006666 <memcpy+0x6>

08006676 <memset>:
 8006676:	4402      	add	r2, r0
 8006678:	4603      	mov	r3, r0
 800667a:	4293      	cmp	r3, r2
 800667c:	d100      	bne.n	8006680 <memset+0xa>
 800667e:	4770      	bx	lr
 8006680:	f803 1b01 	strb.w	r1, [r3], #1
 8006684:	e7f9      	b.n	800667a <memset+0x4>

08006686 <strcpy>:
 8006686:	4603      	mov	r3, r0
 8006688:	f811 2b01 	ldrb.w	r2, [r1], #1
 800668c:	f803 2b01 	strb.w	r2, [r3], #1
 8006690:	2a00      	cmp	r2, #0
 8006692:	d1f9      	bne.n	8006688 <strcpy+0x2>
 8006694:	4770      	bx	lr
	...

08006698 <_init>:
 8006698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800669a:	bf00      	nop
 800669c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800669e:	bc08      	pop	{r3}
 80066a0:	469e      	mov	lr, r3
 80066a2:	4770      	bx	lr

080066a4 <_fini>:
 80066a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80066a6:	bf00      	nop
 80066a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80066aa:	bc08      	pop	{r3}
 80066ac:	469e      	mov	lr, r3
 80066ae:	4770      	bx	lr
